---
title: HDU-2066 一个人的旅行
date: 2016-12-28 16:31:57
mathjax: true
tags: 
    - 图论
    - dijkstra
categories: Algorithm
---

*类型： 最短路，多集合到多集合*

### Problem Description

虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。

### Input

输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；
 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=<(a,b)<=1000;a,b 之间可能有多条路)
 接着的第T+1行有S个数，表示和草儿家相连的城市；
 接着的第T+2行有D个数，表示草儿想去地方。

### Output

输出草儿能去某个喜欢的城市的最短时间。

### Sample Input

6 2 3
1 3 5
1 4 7
2 8 12
3 8 4
4 9 12
9 10 2
1 2
8 9 10

### Sample Output

9

### 题解：

对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。

```c++
include <iostream>
include <cstring>
include <vector>
include <queue>
include <cstdio>
using namespace std;

const int INF = 0x3f3f3f3f;

struct Edge {
	int vertex, weight;
};

class Graph {
private:
	int n;
	vector<Edge> * edges;
    bool * visited;
public:
	int * dist;
	Graph (int input_n) {
		n = input_n;
		edges = new vector<Edge>[n];
		dist = new int[n];
        visited = new bool[n];
        memset(visited, 0, n);
		memset(dist, 0x3f, n * sizeof(int));
	}
	~Graph() {
		delete[] dist;
		delete[] edges;
        delete[] visited;
	}
    void insert(int x, int y, int weight) {
        edges[x].push_back(Edge{y, weight});
        edges[y].push_back(Edge{x, weight});
    }
    void dijkstra(int v) {
        dist[v] = 0;
        for(int i = 0;i < n;i++){
            int min_dist = INF,min_vertex;
            for(int j = 0;j < n; j++){
                if(!visited[j] && dist[j] < min_dist){
                    min_dist = dist[j];
                    min_vertex = j;
                }
            }
            visited[min_vertex] = 1;
            for(Edge &j: edges[min_vertex]){
                if( min_dist + j.weight < dist[j.vertex]){
                    dist[j.vertex] = min_dist + j.weight;
                }
            }

        }
    }
};

int main() {

	int T,S,D,maxn;
	while(scanf("%d%d%d",&T,&S,&D)!=EOF){
        Graph g(1010);
        maxn = 0;
        for (int i = 0; i < T; i++) {
            int a, b, c;
            cin >> a >> b >> c;
            maxn = max(max(a,b),maxn);
            g.insert(a, b, c);
        }
        maxn++;
        for (int i = 0; i < S; i++) {
            int tmp;
            cin >> tmp;
            g.insert(0, tmp, 0);
        }
        for (int i = 0; i < D; i++) {
            int tmp;
            cin >> tmp;
            g.insert(maxn, tmp, 0);
        }
        g.dijkstra(0);
        cout << g.dist[maxn] << endl;
	}
	return 0;
}
```



