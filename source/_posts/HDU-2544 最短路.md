---
title: HDU-2544  最短路
date: 2016-12-28 16:31:57
mathjax: true
tags: 
    - 图论
    - dijkstra
categories: Algorithm
---

*类型： dijkstra*

### Problem Description

在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？

### Input

输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。

输入保证至少存在1条商店到赛场的路线。

### Output

对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间

### Sample Input

2 1

1 2 3

3 3

1 2 5

2 3 5

3 1 2

0 0

### Sample Output

3

2

### 题解：

此题解包括dijkstra的讲解。

**dijistra的简述：**将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。

**题目简述：** 简单的最短路。

### 代码：

```c++
include <iostream>
include <cstring>
include <vector>
include <queue>
using namespace std;

const int INF = 0x3f3f3f3f;

struct Edge {
	int vertex, weight;
};

class Graph {
private:
	int n;
	vector<Edge> * edges;
    bool * visited;
public:
	int * dist;
	Graph (int input_n) {
		n = input_n;
		edges = new vector<Edge>[n];
		dist = new int[n];
        visited = new bool[n];
        memset(visited, 0, n);
		memset(dist, 0x3f, n * sizeof(int));
	}
	~Graph() {
		delete[] dist;
		delete[] edges;
        delete[] visited;
	}
    void insert(int x, int y, int weight) {
        edges[x].push_back(Edge{y, weight});
        edges[y].push_back(Edge{x, weight});
    }
    void dijkstra(int v) {
        dist[v] = 0;
        for(int i = 0;i < n;i++){
            int min_dist = INF,min_vertex;
            for(int j = 0;j < n; j++){
                if(!visited[j] && dist[j] < min_dist){
                    min_dist = dist[j];
                    min_vertex = j;
                }
            }
            visited[min_vertex] = 1;
            for(Edge &j: edges[min_vertex]){
                if( min_dist + j.weight < dist[j.vertex]){
                    dist[j.vertex] = min_dist + j.weight;
                }
            }
        }
    }
};

int main() {
	int n, m;
	while ((cin >> n >> m) && n && m){
	Graph g(n);
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		g.insert(a-1, b-1, c);
	}
	g.dijkstra(0);

		cout << g.dist[n-1] << endl;
    }
	return 0;
}
```





