{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/media/15305992039707.jpg","path":"media/15305992039707.jpg","modified":0,"renderable":0},{"_id":"source/media/avatar.png","path":"media/avatar.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8fa1bd664119ddd1fa795e45ed6cb1f0cff67f42","modified":1530601563571},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1530589441797},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1530589441798},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1530589441798},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1530589441798},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1530589441800},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1530589441801},{"_id":"themes/next/_config.yml","hash":"28fdf244f3f05007a3dda7e621f7ddce1bab0070","modified":1530602019491},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1530589441801},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1530589441801},{"_id":"themes/next/README.md","hash":"c1d6d1c6b75736b892e179865833ea58da5ca9d2","modified":1530589441802},{"_id":"themes/next/bower.json","hash":"a8c832da6aad5245052aed7ff26c246f85d68c6c","modified":1530589441802},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1530589441803},{"_id":"themes/next/package.json","hash":"11a0b27f92da8abf1efbea6e7a0af4271d7bff9e","modified":1530589441838},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1530589441810},{"_id":"source/_posts/51nod bash v2.md","hash":"a42e8a601a4a17eac0718c81a2aabb70a24b9d61","modified":1530599398136},{"_id":"source/_posts/ACM数学知识整理.md","hash":"fb1cf4e931e464f74c86e414593cdc9a1b17f875","modified":1530599384236},{"_id":"source/_posts/Codeforces-400-C-Molly-s-Chemicals.md","hash":"4219a141ffecc78db2d1c07bdccc4d6811a54df9","modified":1530599384773},{"_id":"source/.MWebMetaData/setting.json","hash":"293af0bbd042f4d707275e43012727ec1af7f1e0","modified":1530597360368},{"_id":"source/_posts/HDU-1043 Eight.md","hash":"390403886c98ddadde4ed7898d9bcac520d3b85b","modified":1530599397581},{"_id":"source/_posts/.DS_Store","hash":"66dbb0876be963a015360b92fca273f5db884d6b","modified":1530601494902},{"_id":"source/_posts/HDU-1272 小希的迷宫.md","hash":"89f4c15b5fe26b934ba1756e6f171f7d33ce7343","modified":1530599396990},{"_id":"source/_posts/HDU-1851 A Simple Game.md","hash":"305d278ef07312bd82e447d40ea4266f3a640cfc","modified":1530599396213},{"_id":"source/_posts/HDU-2066 一个人的旅行.md","hash":"c5b84e6f843974478d2c521fd1c2f440a337963c","modified":1530599395844},{"_id":"source/_posts/HDU-2196 Computer.md","hash":"fafa89f32fc8b66ff7fe2e79b0c2d9a34c21ad48","modified":1530599394709},{"_id":"source/_posts/HDU-2444 The Accomodation of Students.md","hash":"af8868d250679f72c0669b02b9c5835bc7415920","modified":1530599393681},{"_id":"source/_posts/HDU-2544 最短路.md","hash":"3bc530d4222ddd6387535a002f01a05d54f4579d","modified":1530599393219},{"_id":"source/_posts/Hdu-2686 Matrix.md","hash":"8003ddf6fc25d89c4a0d1e4657b3fe1f4c5d072e","modified":1530599392478},{"_id":"source/_posts/Liner-Regressionmd.md","hash":"52e1ba660fbd7e7f51056da5c2761449a2388a23","modified":1530601519200},{"_id":"source/_posts/Nim游戏.md","hash":"4094e4cc6e1c4d8cf7ccbf0530aab996cb418495","modified":1530599391950},{"_id":"source/_posts/Normalization-and-Regularization.md","hash":"b9015cf10574cdb667da42632fc7bce72c5f2d9f","modified":1530604278333},{"_id":"source/_posts/POJ-2449.md","hash":"a7cd7e560394f080cd82b18c06c12fd2a9f3738b","modified":1530599391440},{"_id":"source/_posts/SYNU-2015-training-题解.md","hash":"64ea177bcea6dba63b36700c8f0a29d29168b11c","modified":1530599390914},{"_id":"source/_posts/伸展树——Splay Tree .md","hash":"ef2aea4301738dd5fc7411d6b7407c39df5e942f","modified":1530590545873},{"_id":"source/_posts/博客的开始——如何搭建Hexo.md","hash":"b4d48774263cccf7b05b3c23f47a89b816026aab","modified":1530599390322},{"_id":"source/_posts/威佐夫博奕（Wythoff Game）.md","hash":"bdc8c01541353e78793de47ca814a3dfc5cf8371","modified":1530599389533},{"_id":"source/_posts/容斥原理.md","hash":"99b35413b3601532cc5eb0fb0f5af5f15572e856","modified":1530599388330},{"_id":"source/_posts/巴什博奕（Bash Game）.md","hash":"26146e7eb5fc02ce8da97856ba05301eec092c9a","modified":1530599387721},{"_id":"source/_posts/康托展开.md","hash":"454d49a761f6dd82f703378f5958e75c0f83c2e5","modified":1530599386812},{"_id":"source/_posts/抽屉原理.md","hash":"e8618fefe6803786d0750c58e444896abe8fcd4f","modified":1530599386058},{"_id":"source/_posts/最大子矩阵和.md","hash":"5303e992faa37425c005e1a20bbded4f0cd0cb72","modified":1530599385609},{"_id":"source/_posts/裴蜀等式.md","hash":"c8c4a21f6d926acedca8845d82116df9b8a191c6","modified":1530599385185},{"_id":"source/_posts/求极限-题一.md","hash":"d165f7922ef6f25d5912ee71bced1621bb632dbd","modified":1530603294567},{"_id":"source/_posts/隐函数存在定理.md","hash":"65fbcdb2fc527b934e8b6c5911924cccdfcf3332","modified":1530599383080},{"_id":"source/media/15305992039707.jpg","hash":"02c93c9de0c3749222522774c679b8fba7aeb1ae","modified":1530599203981},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1530589441799},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"f846118d7fc68c053df47b24e1f661241645373f","modified":1530589441799},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1530589441799},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1530589441800},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1530589441800},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1530589441800},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1530589441803},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1530589441804},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1530589441804},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1530589441804},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1530589441805},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1530589441805},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1530589441805},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1530589441806},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1530589441806},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1530589441811},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1530589441811},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1530589441811},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1530589441812},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1530589441811},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1530589441812},{"_id":"themes/next/languages/ja.yml","hash":"5f8e54c666393d1ca2e257f6b1e3b4116f6657d8","modified":1530589441812},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1530589441813},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1530589441813},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1530589441813},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1530589441813},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1530589441814},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1530589441814},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1530589441815},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1530589441815},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1530589441815},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1530589441815},{"_id":"themes/next/layout/_layout.swig","hash":"09e8a6bfe5aa901c66d314601c872e57f05509e8","modified":1530589441816},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1530589441837},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1530589441837},{"_id":"themes/next/layout/index.swig","hash":"53300ca42c00cba050bc98b0a3f2d888d71829b1","modified":1530589441837},{"_id":"themes/next/layout/post.swig","hash":"e7458f896ac33086d9427979f0f963475b43338e","modified":1530589441838},{"_id":"themes/next/scripts/helpers.js","hash":"4cc592788f088a99dd1d70875e8344b6e16cc34d","modified":1530589441839},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1530589441839},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1530589441838},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1530589441837},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1530589441840},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1530589441838},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1530589441895},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1530589441895},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1530589441895},{"_id":"source/media/avatar.png","hash":"295d936d1fd9aa547573bfd170517b8099f270ef","modified":1511709444000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441875},{"_id":"themes/next/docs/ru/README.md","hash":"edfe0cfb8b2c9f0effd3beb868af9bfd0fabb3a6","modified":1530589441807},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1530589441807},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1530589441806},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1530589441807},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1530589441808},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1530589441808},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"44e4fb7ce2eca20dfa98cdd1700b50d6def4086f","modified":1530589441808},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1530589441808},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1530589441809},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1530589441809},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1530589441809},{"_id":"themes/next/docs/zh-CN/README.md","hash":"46b264623af21211a0a9c4ba0cf1318a80eeb9fb","modified":1530589441810},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1530589441810},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1530589441816},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1530589441816},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1530589441816},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1530589441817},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1530589441818},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1530589441818},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1530589441818},{"_id":"themes/next/layout/_macro/post.swig","hash":"686e60ede86547bdd7bc34c3629e4c9dbd134a21","modified":1530589441818},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1530589441819},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1530589441819},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1530589441819},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1530589441819},{"_id":"themes/next/layout/_partials/footer.swig","hash":"cf8fe76993b513b97f379832222b6ec7e41a1c15","modified":1530589441820},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1530589441822},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1530589441822},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1530589441824},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1530589441825},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1530589441825},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1530589441826},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1530589441830},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1530589441832},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1530589441833},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1530589441834},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1530589441834},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1530589441833},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1530589441834},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1530589441834},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1530589441835},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1530589441840},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1530589441840},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1530589441841},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1530589441841},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1d59b968af4b8d147f8bc9bc295d596e41be8348","modified":1530589441841},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"545102e3aa3ce494f7046abf71cefb7aaf671559","modified":1530589441841},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1530589441842},{"_id":"themes/next/scripts/tags/note.js","hash":"265dc7ee83d3fe317e88058e80aa8170230a005e","modified":1530589441842},{"_id":"themes/next/scripts/tags/tabs.js","hash":"6bdf2a1a23cb9922fa809c79af3b06339c28cd70","modified":1530589441842},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1530589441875},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1530589441876},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530589441876},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530589441876},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1530589441876},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1530589441877},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1530589441878},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1530589441877},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1530589441877},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1530589441878},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1530589441879},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530589441879},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530589441879},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530589441879},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530589441880},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530589441880},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1530589441880},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1530589441881},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1530589441881},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441826},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441826},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441874},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441875},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441867},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441867},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530589441868},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1530589441817},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1530589441817},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1530589441820},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1530589441820},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1530589441820},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1530589441821},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1530589441821},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1530589441821},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1530589441821},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1530589441823},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1530589441822},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1530589441823},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1530589441823},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1530589441824},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1530589441824},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1530589441824},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1530589441824},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1530589441825},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1530589441825},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1530589441826},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1530589441827},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1530589441827},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1530589441827},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1530589441826},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1530589441827},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1530589441827},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1530589441828},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1530589441828},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1530589441828},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"cee047575ae324398025423696b760db64d04e6f","modified":1530589441828},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1530589441829},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1530589441829},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1530589441829},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"8878241797f8494a70968756c57cacdfc77b61c7","modified":1530589441830},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1530589441831},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1530589441830},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1530589441831},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1530589441831},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1530589441832},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1530589441832},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1530589441832},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1530589441833},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1530589441833},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1530589441833},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1530589441836},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1530589441835},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1530589441836},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1530589441836},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1530589441867},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1530589441874},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1530589441874},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"66fd28196b8c2ffaddda27e66c4cf4428d7a12ce","modified":1530589441874},{"_id":"themes/next/source/css/_variables/base.styl","hash":"04d0daf587243a983754876fe2928070c3e3b2a8","modified":1530589441875},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1530589441867},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1530589441867},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1530589441868},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1530589441885},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1530589441885},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1530589441885},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1530589441885},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1530589441886},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1530589441881},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1530589441882},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1530589441881},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1530589441882},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1530589441882},{"_id":"themes/next/source/js/src/motion.js","hash":"4726b2cf26e9aebb56cf607905471f3acbd690ae","modified":1530589441883},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1530589441883},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1530589441883},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1530589441884},{"_id":"themes/next/source/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1530589441884},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1530589441894},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1530589441895},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1530589441894},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1530589441891},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1530589441835},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1530589441835},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1530589441843},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1530589441843},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1530589441843},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1530589441843},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1530589441844},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1530589441849},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1530589441858},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1530589441868},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1530589441864},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1530589441865},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1530589441865},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1530589441865},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1530589441866},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1530589441866},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1530589441872},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1530589441872},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1530589441866},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1530589441873},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1530589441873},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1530589441873},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1530589441874},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1530589441873},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1530589441868},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1530589441869},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1530589441870},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1530589441871},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1530589441871},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1530589441871},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1530589441871},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1530589441887},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1530589441886},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1530589441887},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1530589441891},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1530589441892},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1530589441883},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1530589441890},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1530589441890},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1530589441893},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1530589441846},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1530589441845},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1530589441844},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1530589441844},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1530589441846},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1530589441846},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1530589441845},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1530589441847},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1530589441847},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1530589441848},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1530589441848},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1530589441847},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1530589441848},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1530589441849},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1530589441849},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1530589441849},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1530589441851},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1530589441850},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1530589441850},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1530589441851},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1530589441850},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1530589441851},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1530589441852},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1530589441851},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1530589441852},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1530589441853},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1530589441852},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1530589441853},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1530589441854},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1530589441854},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1530589441853},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1530589441853},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1530589441859},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1530589441859},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1530589441859},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"cf2185a0ea170fd8450f592e859a6c941141e5ee","modified":1530589441858},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1530589441860},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1530589441859},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1530589441860},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1530589441860},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1530589441858},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1530589441861},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1530589441862},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1530589441861},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1530589441862},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1530589441862},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1530589441863},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1530589441863},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1530589441863},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1530589441863},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1530589441864},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"bbe0d111f6451fc04e52719fd538bd0753ec17f9","modified":1530589441855},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1530589441855},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1530589441855},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1530589441856},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1530589441856},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1530589441856},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1530589441856},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1530589441857},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1530589441857},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1530589441857},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1530589441870},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1530589441870},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1530589441872},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1530589441889},{"_id":"public/archives/page/3/index.html","hash":"105902ebfe0930683108ef71c756cd6f39700103","modified":1530604290451},{"_id":"public/archives/2017/index.html","hash":"0a0300a23fdcfebbdaed339bf49a16a1fc6e2b1e","modified":1530604290451},{"_id":"public/archives/2017/02/index.html","hash":"51c9bcae7495a6c1e85492f7a87859c80ff81c33","modified":1530604290452},{"_id":"public/archives/2017/08/index.html","hash":"175f039a647f6f80f75770d3e526d90e28d3a3be","modified":1530604290452},{"_id":"public/archives/2017/11/index.html","hash":"db6af5b501f7f0588ab9a5af8af7b6b19c9fc4ce","modified":1530604290452},{"_id":"public/archives/2018/index.html","hash":"c411db1a9ef67c4c565f1f8240282a7b9345e9ab","modified":1530604290452},{"_id":"public/archives/2018/07/index.html","hash":"248603231bd592020a2f9b879755e9740c989a7b","modified":1530604290452},{"_id":"public/categories/Algorithm/page/3/index.html","hash":"f6772755addc30b4eba820b62f56fa8fa1ea823b","modified":1530604290452},{"_id":"public/categories/Machine-Learning/index.html","hash":"14f1007c9b1a18c13d27a58c4260f2c300a84b74","modified":1530604290452},{"_id":"public/categories/考研/index.html","hash":"4128c0dd08682f28950c3426960831ffd416f49b","modified":1530604290452},{"_id":"public/categories/技术类/index.html","hash":"4dee6eeadc160e108f290fa1f799e9bd48b4b1f0","modified":1530604290452},{"_id":"public/tags/博弈/index.html","hash":"d7a8ad724487e8871ee7d74ac7d42f3e219668fa","modified":1530604290452},{"_id":"public/tags/巴什博奕/index.html","hash":"cd870dd3ee7a58c4419cb0fdff0f8d544e804e58","modified":1530604290452},{"_id":"public/tags/数学/index.html","hash":"fddd805e6bb88655ef90bf57128ec92a323ec3ab","modified":1530604290452},{"_id":"public/tags/思维技巧/index.html","hash":"276428fa655c36de2102fdf9b4c25f83a1b12679","modified":1530604290452},{"_id":"public/tags/搜索/index.html","hash":"408371ee6055a7566e159e8a53602f6b1713de63","modified":1530604290452},{"_id":"public/tags/A-算法/index.html","hash":"bc79be66423fa74a22c9eae896bc2fe4a30c16b4","modified":1530604290452},{"_id":"public/tags/图论/index.html","hash":"3e4bab8bec6a7bdfdf4ab2731545a694123db1da","modified":1530604290452},{"_id":"public/tags/并查集/index.html","hash":"443550996e1e51f8eb569d7418dafe201426f90c","modified":1530604290452},{"_id":"public/tags/SG函数/index.html","hash":"72a73b1f98e2b3d9d67aa3550598cf8078580f50","modified":1530604290452},{"_id":"public/tags/dijkstra/index.html","hash":"131ccd3cfed065380edfe28b2a67c951294ec5fe","modified":1530604290453},{"_id":"public/tags/树形DP/index.html","hash":"81478393d59def5de2858fcaab7afbee3f953542","modified":1530604290453},{"_id":"public/tags/二分图/index.html","hash":"9c7f2cf2a803b09a447bc4226aa12adbc9c0e9e1","modified":1530604290453},{"_id":"public/tags/最大匹配/index.html","hash":"3b9a83803310c3fef71199d043b113e524ed6cae","modified":1530604290453},{"_id":"public/tags/Muti-treaded/index.html","hash":"76c7ea365c722af38dc66f9ec7ed9c78e91749ae","modified":1530604290453},{"_id":"public/tags/DP/index.html","hash":"7bedf4c18b38679d269577a97348ff04a1961de9","modified":1530604290453},{"_id":"public/tags/Nim游戏/index.html","hash":"64eae51457a35dc827d1aa89c9f205822e1c936a","modified":1530604290453},{"_id":"public/tags/Machine-Learning/index.html","hash":"3a1247e25d563bfcdbb04ca56641ce3347d063b1","modified":1530604290453},{"_id":"public/tags/A/index.html","hash":"b2cfc3d78a54a2eeb7f42c5460de68d047132a11","modified":1530604290453},{"_id":"public/tags/Splay/index.html","hash":"8a268ab5f02d79eeaadbc218fc900d4de11b80f7","modified":1530604290453},{"_id":"public/tags/威佐夫博奕（Wythoff-Game）/index.html","hash":"9ac26c32a229f5ece01ee495a7c295caa200a8d1","modified":1530604290453},{"_id":"public/tags/组合数学/index.html","hash":"19414d41ea37fcfd61de6802917773a1fb0a30c2","modified":1530604290453},{"_id":"public/tags/容斥原理/index.html","hash":"021ca73fd60b842d99337ab905a79a8b756713a7","modified":1530604290453},{"_id":"public/tags/巴什博奕（Bash-Game）/index.html","hash":"4ca60651894f98c5cf706f6f3b8813d914e615b4","modified":1530604290453},{"_id":"public/tags/康托展开/index.html","hash":"fcaafa4af868584f19a43a0c115bc409db8d22ce","modified":1530604290453},{"_id":"public/tags/抽屉原理/index.html","hash":"04cfbea0137806fe7c1fe2afb5f20e36e887a861","modified":1530604290453},{"_id":"public/tags/基本-DP/index.html","hash":"ec41bf9346f95b49d5d79a5e0f4ad6ba9391eb81","modified":1530604290453},{"_id":"public/tags/裴蜀等式/index.html","hash":"e39ac02bdf2bd8d71531d6dfc1d5e25bce1a0245","modified":1530604290453},{"_id":"public/tags/高等数学/index.html","hash":"4bfc814f27a2152df85ef4a10702a22e51416102","modified":1530604290453},{"_id":"public/tags/题解/index.html","hash":"aa2a78387cf56e43ce48cc29d863cfb5f864ea81","modified":1530604290453},{"_id":"public/2018/07/03/Normalization-and-Regularization/index.html","hash":"8cdbf5e024539efdcf04d53db9865d50854e6b2a","modified":1530604290454},{"_id":"public/2018/07/03/求极限-题一/index.html","hash":"20b5edadfeb0a62d0f180c6804fd0b0d7c56d79a","modified":1530604290454},{"_id":"public/2018/07/03/隐函数存在定理/index.html","hash":"0dfd073df49197e52c9aa3052173b277fc22321d","modified":1530604290454},{"_id":"public/2018/07/03/ACM数学知识整理/index.html","hash":"ff32cbc99209774ec8b8a8888d311a0696bf6121","modified":1530604290454},{"_id":"public/2018/07/03/Codeforces-400-C-Molly-s-Chemicals/index.html","hash":"630d5934561a7a101b2f0cf83143463c0307392b","modified":1530604290454},{"_id":"public/2017/11/05/Liner-Regressionmd/index.html","hash":"2e5b88faffd92a8513628a6b39079472bbb55dde","modified":1530604290454},{"_id":"public/2017/08/18/POJ-2449/index.html","hash":"638ade0985c9c9866ef570ca1d784937efd2926a","modified":1530604290454},{"_id":"public/2017/08/18/伸展树——Splay Tree /index.html","hash":"bce445c0e753f58dc6c6d0b582ddc7f00bd39123","modified":1530604290454},{"_id":"public/2017/02/12/SYNU-2015-training-题解/index.html","hash":"9fe64869e822f94a431c1498077afce848befb0b","modified":1530604290454},{"_id":"public/2016/12/28/HDU-2544 最短路/index.html","hash":"42f482dc2c0c93d63f4a3c64f5b3461e3dedbc3b","modified":1530604290454},{"_id":"public/2016/12/28/Hdu-2686 Matrix/index.html","hash":"9a1b75262e9a7b6f65f2f3b02d369b4828ec87b2","modified":1530604290454},{"_id":"public/2016/12/28/Nim游戏/index.html","hash":"add792780f480e8f663acbb82aca36116bc6e0f9","modified":1530604290454},{"_id":"public/2016/12/28/51nod bash v2/index.html","hash":"b8a491f620cdc1284b60736d2919f04f4457ad88","modified":1530604290454},{"_id":"public/2016/12/28/HDU-1043 Eight/index.html","hash":"1ae34ae6995add13d03233672c21372b299f93ea","modified":1530604290454},{"_id":"public/2016/12/28/HDU-1272 小希的迷宫/index.html","hash":"437f8bebfcc62ed1dae4bc07b4fd128bd5786376","modified":1530604290455},{"_id":"public/2016/12/28/威佐夫博奕（Wythoff Game）/index.html","hash":"fe9837b2d24274001fd44d5e5714ff7a88841e32","modified":1530604290455},{"_id":"public/2016/12/28/容斥原理/index.html","hash":"5b72432af1d5fdd52db73bfe3fbf9550f674f9b1","modified":1530604290455},{"_id":"public/2016/12/28/巴什博奕（Bash Game）/index.html","hash":"0fca6d8f4eca7cbbf33376dc4038ed9a4479c608","modified":1530604290455},{"_id":"public/2016/12/28/康托展开/index.html","hash":"62dfc11e72c09a945fb599d413ff7ab2eb01dabe","modified":1530604290455},{"_id":"public/2016/12/28/抽屉原理/index.html","hash":"02d0dd8753436107fbd4d8046848dc92cd427245","modified":1530604290455},{"_id":"public/2016/12/28/最大子矩阵和/index.html","hash":"10725e4ca1eb486b46783ee85013368c3f9e6a7c","modified":1530604290455},{"_id":"public/2016/12/28/裴蜀等式/index.html","hash":"ec37ed0c39673f3d9fb452b3fa2584bb94892481","modified":1530604290455},{"_id":"public/2016/12/28/HDU-2066 一个人的旅行/index.html","hash":"b5cf460f4a1d6af2fcf01f4563a15ddacb26d389","modified":1530604290455},{"_id":"public/2016/12/28/HDU-1851 A Simple Game/index.html","hash":"bdb6618b397cc4aea70d6bef4142db9e336d0595","modified":1530604290455},{"_id":"public/2016/12/28/HDU-2196 Computer/index.html","hash":"d983793115bb3c22eff80a52215f855229c356ec","modified":1530604290455},{"_id":"public/2016/12/28/HDU-2444 The Accomodation of Students/index.html","hash":"e8dfb68801867c6db97bcf9e0924dcbc7a35be3c","modified":1530604290455},{"_id":"public/2016/12/27/博客的开始——如何搭建Hexo/index.html","hash":"3e34ac581b9be905174f9d6715f85f70464ba764","modified":1530604290455},{"_id":"public/archives/index.html","hash":"c4a28b0e92f112f9b057a84848604d9c68fe587c","modified":1530604290456},{"_id":"public/archives/page/2/index.html","hash":"bf2c9fec56d0da19bfc193c32913024085fac1a8","modified":1530604290456},{"_id":"public/archives/2016/index.html","hash":"ab53f870ee8f7b1ec9aafcaf8478f4a096d6e8ab","modified":1530604290456},{"_id":"public/archives/2016/page/2/index.html","hash":"e10dd5eb1a8a83cdec4090d209dbd67f5d1f157a","modified":1530604290456},{"_id":"public/archives/2016/12/index.html","hash":"0dd2e9a07144d608c060c078c3506b1736c70fb7","modified":1530604290456},{"_id":"public/archives/2016/12/page/2/index.html","hash":"2d6cc6e92b208a78662f90e0468251f0920bd800","modified":1530604290456},{"_id":"public/categories/Algorithm/index.html","hash":"4af28ddfb203561b5b4f2aaf3b80dda736a78771","modified":1530604290456},{"_id":"public/categories/Algorithm/page/2/index.html","hash":"6d293aef5b2e4a1f282d2ac6883914be82d3b505","modified":1530604290457},{"_id":"public/index.html","hash":"02e967ce25ebc7019dc08832359feb33791148a5","modified":1530604290457},{"_id":"public/page/2/index.html","hash":"2d73de5453b6fab30bb893cc2d51be913b0b6756","modified":1530604290457},{"_id":"public/page/3/index.html","hash":"47d31cb21b133e3c2c24e303682e430ce901c424","modified":1530604290457},{"_id":"public/tags/Hexo/index.html","hash":"8dd7397485baa7c8f454fa43b9cb5fe043895ca5","modified":1530604290465},{"_id":"public/media/15305992039707.jpg","hash":"02c93c9de0c3749222522774c679b8fba7aeb1ae","modified":1530604290465},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1530604290465},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530604290465},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530604290465},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1530604290466},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1530604290466},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1530604290466},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1530604290466},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1530604290466},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1530604290466},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1530604290466},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530604290466},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530604290466},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530604290466},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530604290466},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530604290466},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1530604290466},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1530604290466},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1530604290466},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1530604290466},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1530604290466},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1530604290987},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1530604290987},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1530604290990},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1530604290990},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1530604290991},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1530604290991},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1530604290991},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1530604290991},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1530604290991},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1530604290991},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1530604290991},{"_id":"public/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1530604290991},{"_id":"public/css/main.css","hash":"c3bef58cd52735042e91cbd424cc13064213ab35","modified":1530604290991},{"_id":"public/media/avatar.png","hash":"295d936d1fd9aa547573bfd170517b8099f270ef","modified":1530604290991},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1530604290991},{"_id":"public/js/src/motion.js","hash":"4726b2cf26e9aebb56cf607905471f3acbd690ae","modified":1530604290995},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1530604290995},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1530604290995},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1530604290995},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1530604290995},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1530604290998},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1530604291000},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1530604291000},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1530604291000},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1530604291012},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1530604291039}],"Category":[{"name":"Algorithm","_id":"cjj5e9tup0002plxp6yjy6t3e"},{"name":"Machine Learning","_id":"cjj5e9tvg000zplxpjgxotvmm"},{"name":"考研","_id":"cjj5e9tvy001tplxpkbeytnyi"},{"name":"技术类","_id":"cjj5e9u1o003splxpi0fwg1c1"}],"Data":[],"Page":[],"Post":[{"title":"51nod bash v2","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n### 描述：\n有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。\n\n### Input\n第1行：一个数T，表示后面用作输入测试的数的数量。（1 <= T <= 10000)第2 - T + 1行：每行1个数N。(1 <= N <= 10^9)\n\n### Output\n共T行，如果A获胜输出A，如果B获胜输出B。\n\n### Input示例\n3234\n### Output示例\nBAA\n### 题解：\n\n从1个石子推下去发现7个一循环\n\n### 代码\n\n```c++\ninclude<stdio.h>\nint main()\n{\n    freopen(\"a.txt\",\"r\",stdin);\n    long long N,K;\n    int t;\n    scanf(\"%d\",&t);\n    int bo[7]={0,1,0,1,1,1,1};\n    while(t--){\n        scanf(\"%d\",&N);\n        N%=7;\n        printf(\"%d \",N);\n        if(bo[N])\n        \tprintf(\"A\\n\");\n        else\n        \tprintf(\"B\\n\");\n    }\n}\n```","source":"_posts/51nod bash v2.md","raw":"---\ntitle: 51nod bash v2\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 博弈\n    - 巴什博奕\ncategories: Algorithm\n---\n\n### 描述：\n有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。\n\n### Input\n第1行：一个数T，表示后面用作输入测试的数的数量。（1 <= T <= 10000)第2 - T + 1行：每行1个数N。(1 <= N <= 10^9)\n\n### Output\n共T行，如果A获胜输出A，如果B获胜输出B。\n\n### Input示例\n3234\n### Output示例\nBAA\n### 题解：\n\n从1个石子推下去发现7个一循环\n\n### 代码\n\n```c++\ninclude<stdio.h>\nint main()\n{\n    freopen(\"a.txt\",\"r\",stdin);\n    long long N,K;\n    int t;\n    scanf(\"%d\",&t);\n    int bo[7]={0,1,0,1,1,1,1};\n    while(t--){\n        scanf(\"%d\",&N);\n        N%=7;\n        printf(\"%d \",N);\n        if(bo[N])\n        \tprintf(\"A\\n\");\n        else\n        \tprintf(\"B\\n\");\n    }\n}\n```","slug":"51nod bash v2","published":1,"updated":"2018-07-03T06:29:58.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tuj0000plxpdt0ne13n","content":"<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>\n<h3 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h3><p>3234</p>\n<h3 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h3><p>BAA</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>从1个石子推下去发现7个一循环</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    freopen(<span class=\"string\">\"a.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N,K;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bo[<span class=\"number\">7</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;N);</span><br><span class=\"line\">        N%=<span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,N);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bo[N])</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"A\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"B\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>\n<h3 id=\"Input示例\"><a href=\"#Input示例\" class=\"headerlink\" title=\"Input示例\"></a>Input示例</h3><p>3234</p>\n<h3 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h3><p>BAA</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>从1个石子推下去发现7个一循环</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    freopen(<span class=\"string\">\"a.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N,K;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bo[<span class=\"number\">7</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;N);</span><br><span class=\"line\">        N%=<span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,N);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bo[N])</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"A\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"B\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ACM数学知识整理","date":"2018-07-03T06:22:46.000Z","mathjax":true,"_content":"\n*数学*\n\n## 数论\n### 素数，整数分解，欧拉函数  \n    辗转相除法\n    筛法：  \n        pku2689 Prime Distance（很好的一个应用）  \n    反素数：  \n        zoj2562 More Divisors  \n    素数判断，整数分解：  \n        pku1811 Prime Test  \n        pku2429 GCD & LCM Inverse  \n    欧拉函数：  \n        pku1284 Primitive Roots （很水）  \n        pku2407 Relatives （很水）  \n        pku2773 Happy 2006  \n        pku2478 Farey Sequence （快速求欧拉函数）  \n        pku3090 Visible Lattice Points （法雷级数）  \n    推荐：（欧拉函数，费马小定理）  \n        pku3358 Period of an Infinite Binary Expansion \n    整数分解  \n        pku2992 Divisors  \n        fzu1753 Another Easy Problem   \n        hit2813 Garden visiting \n        pku3101 Astronomy （分数的最小公倍数） \n### 扩展欧几里得，线性同余，中国剩余定理  \n    简单题：  \n        pku1006 Biorhythms  \n        pku1061 青蛙的约会\n        pku2891 Strange Way to Express Integers  \n        pku2115 C Looooops  \n        pku2142 The Balance  \n        *强烈推荐：  \n        pku3708 Recurrent Function （经典）\n### 高次同余方程  \n    pku3243 Clever Y    \n    pku2417 Discrete Loggin\n### 高斯消元法解方程  \n    简单题：  \n        pku1222 EXTENDED LIGHTS OUT    \n        pku1681 Painter's Problem    \n        pku1830 开关问题    \n    推荐：  \n        pku2947 Widget Factory    \n        pku2065 SETI    \n    强烈推荐：  \n        pku1753 Flip Game    \n        pku3185 The Water Bowls    \n    变态题：  \n        pku1487 Single-Player Games \n### 数位类统计问题  \n    简单：  \n        ural1057 Amount of degrees\n        spoj1182 Sorted bit squence \n        hdu3271 SNIBB    \n    较难：  \n        spoj2319 Sequence  \n        sgu390 Tickets \n\n## 组合数学\n### 容斥原理，鸽巢原理  \n    鸽巢原理：  \n        pku2365 Find a multiple    \n        pku3370 Halloween treats    \n    容斥原理：  \n        hdu1695 GCD    \n        hdu2461 Rectangles  \n### 排列组合，区间计数，计数序列  \n    简单题：  \n        pku1850 Code    \n        pku1150 The Last Non-zero Digit    \n        pku1715 Hexadecimal Numbers    \n        pku2282 The Counting Problem    \n        pku3286 How many 0's?    \n    推荐：  \n        pku3252 Round Numbers    \n    计数序列：  \n        pku1430 Binary Stirling Numbers    \n        pku2515 Birthday Cake    \n        pku1707 Sum of powers    \n### 置换，置换的运算\n    简单题：（应该理解概念就可以了）  \n        pku3270 Cow Sorting  \n        pku1026 Cipher \n    置换幂运算：  \n        pku1721 CARDS  \n        pku3128 Leonardo's Notebook            \n    推荐：（不错的应用）  \n        pku3590 The shuffle Problem \n### burnside定理，polya计数法\n    简单题：（直接用套公式就可以了)\n        pku2409 Let it Bead\n        pku2154 Color\n        pku1286 Necklace of Beads\n    强烈推荐：（这题很不错哦，很巧妙）  \n        pku2888 Magic Bracelet\n### 稳定婚姻问题  \n    pku3487 The Stable Marriage Problem    \n    zoj1576 Marriage is Stable \n###  MoBius反演\n### 偏序关系理论\n\n## 计算方法\n### 矩阵  \n    简单：  \n        pku3070 Fibonacci    \n        pku3233 Matrix Power Series    \n        pku3735 Training little cats \n### 矩阵变换\n### 递推关系\n    POJ3252\n    poj1850\n    poj1019\n    poj1942\n### 约瑟夫环问题  \n    简单题：  \n        pku3517 And Then There Was One  \n        pku1781 In Danger  \n        pku1012 Joseph   \n        pku2244 Eeny Meeny Moo   \n### 找规律，推公式 \n    pku3372 Candy Distribution    \n    pku3244 Difference between Triplets    \n    pku1809 Regetni    \n    pku1831 不定方程组    \n    pku1737 Connected Graph    \n    pku2480 Longge's problem    \n    pku1792 Hexagonal Routes\n### 二分法求解单调函数相关知识.\n        pku3273Monthly Expense \n        pku3258River Hopscotch  \n        pku1905Expanding Rods \n        pku3122Pie \n        pku1845 Sumdiv \n        poj3273\n        poj3258\n        poj1905\n        poj3122\n### 三分法求解单峰(单谷)的极值.\n### 0/1分数规划. (poj2976)\n### 矩阵法\n### 随机化算法\n    poj3318\n    poj2454\n### 迭代逼近\n    poj3301\n### 扫描线算法\n\n\n\n##  博弈论\n### 巴什博奕（BashGame）\n###  威佐夫博奕（WythoffGame）\n###  尼姆博奕（NimmGame）\n### 组合博弈\n\n## 计算几何\n### 叉积和点积的运用(如线段相交的判定,点到线段的距离等).\n        poj2031\n        poj1039\n### 多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)\n    poj1408\n    poj1584\n###  二维、三维凸包\n    poj2187\n    poj1113\n### 扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).\n### 半平面求交\n    poj3384\n    poj2540\n    poj3130\n    poj3335\n### 点集最小圆覆盖.\n### 对踵点（最远点对）\n    poj2079\n### 几何工具的综合应用.\n    poj1819\n    poj1066\n    poj2043\n    poj3227\n    poj2165\n    poj3429\n\n","source":"_posts/ACM数学知识整理.md","raw":"---\ntitle: ACM数学知识整理\ndate: 2018-07-03 14:22:46\nmathjax: true\ntags: \n    - 数学\ncategories: Algorithm\n---\n\n*数学*\n\n## 数论\n### 素数，整数分解，欧拉函数  \n    辗转相除法\n    筛法：  \n        pku2689 Prime Distance（很好的一个应用）  \n    反素数：  \n        zoj2562 More Divisors  \n    素数判断，整数分解：  \n        pku1811 Prime Test  \n        pku2429 GCD & LCM Inverse  \n    欧拉函数：  \n        pku1284 Primitive Roots （很水）  \n        pku2407 Relatives （很水）  \n        pku2773 Happy 2006  \n        pku2478 Farey Sequence （快速求欧拉函数）  \n        pku3090 Visible Lattice Points （法雷级数）  \n    推荐：（欧拉函数，费马小定理）  \n        pku3358 Period of an Infinite Binary Expansion \n    整数分解  \n        pku2992 Divisors  \n        fzu1753 Another Easy Problem   \n        hit2813 Garden visiting \n        pku3101 Astronomy （分数的最小公倍数） \n### 扩展欧几里得，线性同余，中国剩余定理  \n    简单题：  \n        pku1006 Biorhythms  \n        pku1061 青蛙的约会\n        pku2891 Strange Way to Express Integers  \n        pku2115 C Looooops  \n        pku2142 The Balance  \n        *强烈推荐：  \n        pku3708 Recurrent Function （经典）\n### 高次同余方程  \n    pku3243 Clever Y    \n    pku2417 Discrete Loggin\n### 高斯消元法解方程  \n    简单题：  \n        pku1222 EXTENDED LIGHTS OUT    \n        pku1681 Painter's Problem    \n        pku1830 开关问题    \n    推荐：  \n        pku2947 Widget Factory    \n        pku2065 SETI    \n    强烈推荐：  \n        pku1753 Flip Game    \n        pku3185 The Water Bowls    \n    变态题：  \n        pku1487 Single-Player Games \n### 数位类统计问题  \n    简单：  \n        ural1057 Amount of degrees\n        spoj1182 Sorted bit squence \n        hdu3271 SNIBB    \n    较难：  \n        spoj2319 Sequence  \n        sgu390 Tickets \n\n## 组合数学\n### 容斥原理，鸽巢原理  \n    鸽巢原理：  \n        pku2365 Find a multiple    \n        pku3370 Halloween treats    \n    容斥原理：  \n        hdu1695 GCD    \n        hdu2461 Rectangles  \n### 排列组合，区间计数，计数序列  \n    简单题：  \n        pku1850 Code    \n        pku1150 The Last Non-zero Digit    \n        pku1715 Hexadecimal Numbers    \n        pku2282 The Counting Problem    \n        pku3286 How many 0's?    \n    推荐：  \n        pku3252 Round Numbers    \n    计数序列：  \n        pku1430 Binary Stirling Numbers    \n        pku2515 Birthday Cake    \n        pku1707 Sum of powers    \n### 置换，置换的运算\n    简单题：（应该理解概念就可以了）  \n        pku3270 Cow Sorting  \n        pku1026 Cipher \n    置换幂运算：  \n        pku1721 CARDS  \n        pku3128 Leonardo's Notebook            \n    推荐：（不错的应用）  \n        pku3590 The shuffle Problem \n### burnside定理，polya计数法\n    简单题：（直接用套公式就可以了)\n        pku2409 Let it Bead\n        pku2154 Color\n        pku1286 Necklace of Beads\n    强烈推荐：（这题很不错哦，很巧妙）  \n        pku2888 Magic Bracelet\n### 稳定婚姻问题  \n    pku3487 The Stable Marriage Problem    \n    zoj1576 Marriage is Stable \n###  MoBius反演\n### 偏序关系理论\n\n## 计算方法\n### 矩阵  \n    简单：  \n        pku3070 Fibonacci    \n        pku3233 Matrix Power Series    \n        pku3735 Training little cats \n### 矩阵变换\n### 递推关系\n    POJ3252\n    poj1850\n    poj1019\n    poj1942\n### 约瑟夫环问题  \n    简单题：  \n        pku3517 And Then There Was One  \n        pku1781 In Danger  \n        pku1012 Joseph   \n        pku2244 Eeny Meeny Moo   \n### 找规律，推公式 \n    pku3372 Candy Distribution    \n    pku3244 Difference between Triplets    \n    pku1809 Regetni    \n    pku1831 不定方程组    \n    pku1737 Connected Graph    \n    pku2480 Longge's problem    \n    pku1792 Hexagonal Routes\n### 二分法求解单调函数相关知识.\n        pku3273Monthly Expense \n        pku3258River Hopscotch  \n        pku1905Expanding Rods \n        pku3122Pie \n        pku1845 Sumdiv \n        poj3273\n        poj3258\n        poj1905\n        poj3122\n### 三分法求解单峰(单谷)的极值.\n### 0/1分数规划. (poj2976)\n### 矩阵法\n### 随机化算法\n    poj3318\n    poj2454\n### 迭代逼近\n    poj3301\n### 扫描线算法\n\n\n\n##  博弈论\n### 巴什博奕（BashGame）\n###  威佐夫博奕（WythoffGame）\n###  尼姆博奕（NimmGame）\n### 组合博弈\n\n## 计算几何\n### 叉积和点积的运用(如线段相交的判定,点到线段的距离等).\n        poj2031\n        poj1039\n### 多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)\n    poj1408\n    poj1584\n###  二维、三维凸包\n    poj2187\n    poj1113\n### 扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).\n### 半平面求交\n    poj3384\n    poj2540\n    poj3130\n    poj3335\n### 点集最小圆覆盖.\n### 对踵点（最远点对）\n    poj2079\n### 几何工具的综合应用.\n    poj1819\n    poj1066\n    poj2043\n    poj3227\n    poj2165\n    poj3429\n\n","slug":"ACM数学知识整理","published":1,"updated":"2018-07-03T06:29:44.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tun0001plxp2t6qhbas","content":"<p><em>数学</em></p>\n<h2 id=\"数论\"><a href=\"#数论\" class=\"headerlink\" title=\"数论\"></a>数论</h2><h3 id=\"素数，整数分解，欧拉函数\"><a href=\"#素数，整数分解，欧拉函数\" class=\"headerlink\" title=\"素数，整数分解，欧拉函数\"></a>素数，整数分解，欧拉函数</h3><pre><code>辗转相除法\n筛法：  \n    pku2689 Prime Distance（很好的一个应用）  \n反素数：  \n    zoj2562 More Divisors  \n素数判断，整数分解：  \n    pku1811 Prime Test  \n    pku2429 GCD &amp; LCM Inverse  \n欧拉函数：  \n    pku1284 Primitive Roots （很水）  \n    pku2407 Relatives （很水）  \n    pku2773 Happy 2006  \n    pku2478 Farey Sequence （快速求欧拉函数）  \n    pku3090 Visible Lattice Points （法雷级数）  \n推荐：（欧拉函数，费马小定理）  \n    pku3358 Period of an Infinite Binary Expansion \n整数分解  \n    pku2992 Divisors  \n    fzu1753 Another Easy Problem   \n    hit2813 Garden visiting \n    pku3101 Astronomy （分数的最小公倍数） \n</code></pre><h3 id=\"扩展欧几里得，线性同余，中国剩余定理\"><a href=\"#扩展欧几里得，线性同余，中国剩余定理\" class=\"headerlink\" title=\"扩展欧几里得，线性同余，中国剩余定理\"></a>扩展欧几里得，线性同余，中国剩余定理</h3><pre><code>简单题：  \n    pku1006 Biorhythms  \n    pku1061 青蛙的约会\n    pku2891 Strange Way to Express Integers  \n    pku2115 C Looooops  \n    pku2142 The Balance  \n    *强烈推荐：  \n    pku3708 Recurrent Function （经典）\n</code></pre><h3 id=\"高次同余方程\"><a href=\"#高次同余方程\" class=\"headerlink\" title=\"高次同余方程\"></a>高次同余方程</h3><pre><code>pku3243 Clever Y    \npku2417 Discrete Loggin\n</code></pre><h3 id=\"高斯消元法解方程\"><a href=\"#高斯消元法解方程\" class=\"headerlink\" title=\"高斯消元法解方程\"></a>高斯消元法解方程</h3><pre><code>简单题：  \n    pku1222 EXTENDED LIGHTS OUT    \n    pku1681 Painter&apos;s Problem    \n    pku1830 开关问题    \n推荐：  \n    pku2947 Widget Factory    \n    pku2065 SETI    \n强烈推荐：  \n    pku1753 Flip Game    \n    pku3185 The Water Bowls    \n变态题：  \n    pku1487 Single-Player Games \n</code></pre><h3 id=\"数位类统计问题\"><a href=\"#数位类统计问题\" class=\"headerlink\" title=\"数位类统计问题\"></a>数位类统计问题</h3><pre><code>简单：  \n    ural1057 Amount of degrees\n    spoj1182 Sorted bit squence \n    hdu3271 SNIBB    \n较难：  \n    spoj2319 Sequence  \n    sgu390 Tickets \n</code></pre><h2 id=\"组合数学\"><a href=\"#组合数学\" class=\"headerlink\" title=\"组合数学\"></a>组合数学</h2><h3 id=\"容斥原理，鸽巢原理\"><a href=\"#容斥原理，鸽巢原理\" class=\"headerlink\" title=\"容斥原理，鸽巢原理\"></a>容斥原理，鸽巢原理</h3><pre><code>鸽巢原理：  \n    pku2365 Find a multiple    \n    pku3370 Halloween treats    \n容斥原理：  \n    hdu1695 GCD    \n    hdu2461 Rectangles  \n</code></pre><h3 id=\"排列组合，区间计数，计数序列\"><a href=\"#排列组合，区间计数，计数序列\" class=\"headerlink\" title=\"排列组合，区间计数，计数序列\"></a>排列组合，区间计数，计数序列</h3><pre><code>简单题：  \n    pku1850 Code    \n    pku1150 The Last Non-zero Digit    \n    pku1715 Hexadecimal Numbers    \n    pku2282 The Counting Problem    \n    pku3286 How many 0&apos;s?    \n推荐：  \n    pku3252 Round Numbers    \n计数序列：  \n    pku1430 Binary Stirling Numbers    \n    pku2515 Birthday Cake    \n    pku1707 Sum of powers    \n</code></pre><h3 id=\"置换，置换的运算\"><a href=\"#置换，置换的运算\" class=\"headerlink\" title=\"置换，置换的运算\"></a>置换，置换的运算</h3><pre><code>简单题：（应该理解概念就可以了）  \n    pku3270 Cow Sorting  \n    pku1026 Cipher \n置换幂运算：  \n    pku1721 CARDS  \n    pku3128 Leonardo&apos;s Notebook            \n推荐：（不错的应用）  \n    pku3590 The shuffle Problem \n</code></pre><h3 id=\"burnside定理，polya计数法\"><a href=\"#burnside定理，polya计数法\" class=\"headerlink\" title=\"burnside定理，polya计数法\"></a>burnside定理，polya计数法</h3><pre><code>简单题：（直接用套公式就可以了)\n    pku2409 Let it Bead\n    pku2154 Color\n    pku1286 Necklace of Beads\n强烈推荐：（这题很不错哦，很巧妙）  \n    pku2888 Magic Bracelet\n</code></pre><h3 id=\"稳定婚姻问题\"><a href=\"#稳定婚姻问题\" class=\"headerlink\" title=\"稳定婚姻问题\"></a>稳定婚姻问题</h3><pre><code>pku3487 The Stable Marriage Problem    \nzoj1576 Marriage is Stable \n</code></pre><h3 id=\"MoBius反演\"><a href=\"#MoBius反演\" class=\"headerlink\" title=\"MoBius反演\"></a>MoBius反演</h3><h3 id=\"偏序关系理论\"><a href=\"#偏序关系理论\" class=\"headerlink\" title=\"偏序关系理论\"></a>偏序关系理论</h3><h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><pre><code>简单：  \n    pku3070 Fibonacci    \n    pku3233 Matrix Power Series    \n    pku3735 Training little cats \n</code></pre><h3 id=\"矩阵变换\"><a href=\"#矩阵变换\" class=\"headerlink\" title=\"矩阵变换\"></a>矩阵变换</h3><h3 id=\"递推关系\"><a href=\"#递推关系\" class=\"headerlink\" title=\"递推关系\"></a>递推关系</h3><pre><code>POJ3252\npoj1850\npoj1019\npoj1942\n</code></pre><h3 id=\"约瑟夫环问题\"><a href=\"#约瑟夫环问题\" class=\"headerlink\" title=\"约瑟夫环问题\"></a>约瑟夫环问题</h3><pre><code>简单题：  \n    pku3517 And Then There Was One  \n    pku1781 In Danger  \n    pku1012 Joseph   \n    pku2244 Eeny Meeny Moo   \n</code></pre><h3 id=\"找规律，推公式\"><a href=\"#找规律，推公式\" class=\"headerlink\" title=\"找规律，推公式\"></a>找规律，推公式</h3><pre><code>pku3372 Candy Distribution    \npku3244 Difference between Triplets    \npku1809 Regetni    \npku1831 不定方程组    \npku1737 Connected Graph    \npku2480 Longge&apos;s problem    \npku1792 Hexagonal Routes\n</code></pre><h3 id=\"二分法求解单调函数相关知识\"><a href=\"#二分法求解单调函数相关知识\" class=\"headerlink\" title=\"二分法求解单调函数相关知识.\"></a>二分法求解单调函数相关知识.</h3><pre><code>pku3273Monthly Expense \npku3258River Hopscotch  \npku1905Expanding Rods \npku3122Pie \npku1845 Sumdiv \npoj3273\npoj3258\npoj1905\npoj3122\n</code></pre><h3 id=\"三分法求解单峰-单谷-的极值\"><a href=\"#三分法求解单峰-单谷-的极值\" class=\"headerlink\" title=\"三分法求解单峰(单谷)的极值.\"></a>三分法求解单峰(单谷)的极值.</h3><h3 id=\"0-1分数规划-poj2976\"><a href=\"#0-1分数规划-poj2976\" class=\"headerlink\" title=\"0/1分数规划. (poj2976)\"></a>0/1分数规划. (poj2976)</h3><h3 id=\"矩阵法\"><a href=\"#矩阵法\" class=\"headerlink\" title=\"矩阵法\"></a>矩阵法</h3><h3 id=\"随机化算法\"><a href=\"#随机化算法\" class=\"headerlink\" title=\"随机化算法\"></a>随机化算法</h3><pre><code>poj3318\npoj2454\n</code></pre><h3 id=\"迭代逼近\"><a href=\"#迭代逼近\" class=\"headerlink\" title=\"迭代逼近\"></a>迭代逼近</h3><pre><code>poj3301\n</code></pre><h3 id=\"扫描线算法\"><a href=\"#扫描线算法\" class=\"headerlink\" title=\"扫描线算法\"></a>扫描线算法</h3><h2 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h2><h3 id=\"巴什博奕（BashGame）\"><a href=\"#巴什博奕（BashGame）\" class=\"headerlink\" title=\"巴什博奕（BashGame）\"></a>巴什博奕（BashGame）</h3><h3 id=\"威佐夫博奕（WythoffGame）\"><a href=\"#威佐夫博奕（WythoffGame）\" class=\"headerlink\" title=\"威佐夫博奕（WythoffGame）\"></a>威佐夫博奕（WythoffGame）</h3><h3 id=\"尼姆博奕（NimmGame）\"><a href=\"#尼姆博奕（NimmGame）\" class=\"headerlink\" title=\"尼姆博奕（NimmGame）\"></a>尼姆博奕（NimmGame）</h3><h3 id=\"组合博弈\"><a href=\"#组合博弈\" class=\"headerlink\" title=\"组合博弈\"></a>组合博弈</h3><h2 id=\"计算几何\"><a href=\"#计算几何\" class=\"headerlink\" title=\"计算几何\"></a>计算几何</h2><h3 id=\"叉积和点积的运用-如线段相交的判定-点到线段的距离等\"><a href=\"#叉积和点积的运用-如线段相交的判定-点到线段的距离等\" class=\"headerlink\" title=\"叉积和点积的运用(如线段相交的判定,点到线段的距离等).\"></a>叉积和点积的运用(如线段相交的判定,点到线段的距离等).</h3><pre><code>poj2031\npoj1039\n</code></pre><h3 id=\"多边型的简单算法-求面积-和相关判定-点在多边型内-多边型是否相交\"><a href=\"#多边型的简单算法-求面积-和相关判定-点在多边型内-多边型是否相交\" class=\"headerlink\" title=\"多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)\"></a>多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)</h3><pre><code>poj1408\npoj1584\n</code></pre><h3 id=\"二维、三维凸包\"><a href=\"#二维、三维凸包\" class=\"headerlink\" title=\"二维、三维凸包\"></a>二维、三维凸包</h3><pre><code>poj2187\npoj1113\n</code></pre><h3 id=\"扫描线算法-例如求矩形的面积和周长并-常和线段树或堆一起使用\"><a href=\"#扫描线算法-例如求矩形的面积和周长并-常和线段树或堆一起使用\" class=\"headerlink\" title=\"扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).\"></a>扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).</h3><h3 id=\"半平面求交\"><a href=\"#半平面求交\" class=\"headerlink\" title=\"半平面求交\"></a>半平面求交</h3><pre><code>poj3384\npoj2540\npoj3130\npoj3335\n</code></pre><h3 id=\"点集最小圆覆盖\"><a href=\"#点集最小圆覆盖\" class=\"headerlink\" title=\"点集最小圆覆盖.\"></a>点集最小圆覆盖.</h3><h3 id=\"对踵点（最远点对）\"><a href=\"#对踵点（最远点对）\" class=\"headerlink\" title=\"对踵点（最远点对）\"></a>对踵点（最远点对）</h3><pre><code>poj2079\n</code></pre><h3 id=\"几何工具的综合应用\"><a href=\"#几何工具的综合应用\" class=\"headerlink\" title=\"几何工具的综合应用.\"></a>几何工具的综合应用.</h3><pre><code>poj1819\npoj1066\npoj2043\npoj3227\npoj2165\npoj3429\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><em>数学</em></p>\n<h2 id=\"数论\"><a href=\"#数论\" class=\"headerlink\" title=\"数论\"></a>数论</h2><h3 id=\"素数，整数分解，欧拉函数\"><a href=\"#素数，整数分解，欧拉函数\" class=\"headerlink\" title=\"素数，整数分解，欧拉函数\"></a>素数，整数分解，欧拉函数</h3><pre><code>辗转相除法\n筛法：  \n    pku2689 Prime Distance（很好的一个应用）  \n反素数：  \n    zoj2562 More Divisors  \n素数判断，整数分解：  \n    pku1811 Prime Test  \n    pku2429 GCD &amp; LCM Inverse  \n欧拉函数：  \n    pku1284 Primitive Roots （很水）  \n    pku2407 Relatives （很水）  \n    pku2773 Happy 2006  \n    pku2478 Farey Sequence （快速求欧拉函数）  \n    pku3090 Visible Lattice Points （法雷级数）  \n推荐：（欧拉函数，费马小定理）  \n    pku3358 Period of an Infinite Binary Expansion \n整数分解  \n    pku2992 Divisors  \n    fzu1753 Another Easy Problem   \n    hit2813 Garden visiting \n    pku3101 Astronomy （分数的最小公倍数） \n</code></pre><h3 id=\"扩展欧几里得，线性同余，中国剩余定理\"><a href=\"#扩展欧几里得，线性同余，中国剩余定理\" class=\"headerlink\" title=\"扩展欧几里得，线性同余，中国剩余定理\"></a>扩展欧几里得，线性同余，中国剩余定理</h3><pre><code>简单题：  \n    pku1006 Biorhythms  \n    pku1061 青蛙的约会\n    pku2891 Strange Way to Express Integers  \n    pku2115 C Looooops  \n    pku2142 The Balance  \n    *强烈推荐：  \n    pku3708 Recurrent Function （经典）\n</code></pre><h3 id=\"高次同余方程\"><a href=\"#高次同余方程\" class=\"headerlink\" title=\"高次同余方程\"></a>高次同余方程</h3><pre><code>pku3243 Clever Y    \npku2417 Discrete Loggin\n</code></pre><h3 id=\"高斯消元法解方程\"><a href=\"#高斯消元法解方程\" class=\"headerlink\" title=\"高斯消元法解方程\"></a>高斯消元法解方程</h3><pre><code>简单题：  \n    pku1222 EXTENDED LIGHTS OUT    \n    pku1681 Painter&apos;s Problem    \n    pku1830 开关问题    \n推荐：  \n    pku2947 Widget Factory    \n    pku2065 SETI    \n强烈推荐：  \n    pku1753 Flip Game    \n    pku3185 The Water Bowls    \n变态题：  \n    pku1487 Single-Player Games \n</code></pre><h3 id=\"数位类统计问题\"><a href=\"#数位类统计问题\" class=\"headerlink\" title=\"数位类统计问题\"></a>数位类统计问题</h3><pre><code>简单：  \n    ural1057 Amount of degrees\n    spoj1182 Sorted bit squence \n    hdu3271 SNIBB    \n较难：  \n    spoj2319 Sequence  \n    sgu390 Tickets \n</code></pre><h2 id=\"组合数学\"><a href=\"#组合数学\" class=\"headerlink\" title=\"组合数学\"></a>组合数学</h2><h3 id=\"容斥原理，鸽巢原理\"><a href=\"#容斥原理，鸽巢原理\" class=\"headerlink\" title=\"容斥原理，鸽巢原理\"></a>容斥原理，鸽巢原理</h3><pre><code>鸽巢原理：  \n    pku2365 Find a multiple    \n    pku3370 Halloween treats    \n容斥原理：  \n    hdu1695 GCD    \n    hdu2461 Rectangles  \n</code></pre><h3 id=\"排列组合，区间计数，计数序列\"><a href=\"#排列组合，区间计数，计数序列\" class=\"headerlink\" title=\"排列组合，区间计数，计数序列\"></a>排列组合，区间计数，计数序列</h3><pre><code>简单题：  \n    pku1850 Code    \n    pku1150 The Last Non-zero Digit    \n    pku1715 Hexadecimal Numbers    \n    pku2282 The Counting Problem    \n    pku3286 How many 0&apos;s?    \n推荐：  \n    pku3252 Round Numbers    \n计数序列：  \n    pku1430 Binary Stirling Numbers    \n    pku2515 Birthday Cake    \n    pku1707 Sum of powers    \n</code></pre><h3 id=\"置换，置换的运算\"><a href=\"#置换，置换的运算\" class=\"headerlink\" title=\"置换，置换的运算\"></a>置换，置换的运算</h3><pre><code>简单题：（应该理解概念就可以了）  \n    pku3270 Cow Sorting  \n    pku1026 Cipher \n置换幂运算：  \n    pku1721 CARDS  \n    pku3128 Leonardo&apos;s Notebook            \n推荐：（不错的应用）  \n    pku3590 The shuffle Problem \n</code></pre><h3 id=\"burnside定理，polya计数法\"><a href=\"#burnside定理，polya计数法\" class=\"headerlink\" title=\"burnside定理，polya计数法\"></a>burnside定理，polya计数法</h3><pre><code>简单题：（直接用套公式就可以了)\n    pku2409 Let it Bead\n    pku2154 Color\n    pku1286 Necklace of Beads\n强烈推荐：（这题很不错哦，很巧妙）  \n    pku2888 Magic Bracelet\n</code></pre><h3 id=\"稳定婚姻问题\"><a href=\"#稳定婚姻问题\" class=\"headerlink\" title=\"稳定婚姻问题\"></a>稳定婚姻问题</h3><pre><code>pku3487 The Stable Marriage Problem    \nzoj1576 Marriage is Stable \n</code></pre><h3 id=\"MoBius反演\"><a href=\"#MoBius反演\" class=\"headerlink\" title=\"MoBius反演\"></a>MoBius反演</h3><h3 id=\"偏序关系理论\"><a href=\"#偏序关系理论\" class=\"headerlink\" title=\"偏序关系理论\"></a>偏序关系理论</h3><h2 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h2><h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><pre><code>简单：  \n    pku3070 Fibonacci    \n    pku3233 Matrix Power Series    \n    pku3735 Training little cats \n</code></pre><h3 id=\"矩阵变换\"><a href=\"#矩阵变换\" class=\"headerlink\" title=\"矩阵变换\"></a>矩阵变换</h3><h3 id=\"递推关系\"><a href=\"#递推关系\" class=\"headerlink\" title=\"递推关系\"></a>递推关系</h3><pre><code>POJ3252\npoj1850\npoj1019\npoj1942\n</code></pre><h3 id=\"约瑟夫环问题\"><a href=\"#约瑟夫环问题\" class=\"headerlink\" title=\"约瑟夫环问题\"></a>约瑟夫环问题</h3><pre><code>简单题：  \n    pku3517 And Then There Was One  \n    pku1781 In Danger  \n    pku1012 Joseph   \n    pku2244 Eeny Meeny Moo   \n</code></pre><h3 id=\"找规律，推公式\"><a href=\"#找规律，推公式\" class=\"headerlink\" title=\"找规律，推公式\"></a>找规律，推公式</h3><pre><code>pku3372 Candy Distribution    \npku3244 Difference between Triplets    \npku1809 Regetni    \npku1831 不定方程组    \npku1737 Connected Graph    \npku2480 Longge&apos;s problem    \npku1792 Hexagonal Routes\n</code></pre><h3 id=\"二分法求解单调函数相关知识\"><a href=\"#二分法求解单调函数相关知识\" class=\"headerlink\" title=\"二分法求解单调函数相关知识.\"></a>二分法求解单调函数相关知识.</h3><pre><code>pku3273Monthly Expense \npku3258River Hopscotch  \npku1905Expanding Rods \npku3122Pie \npku1845 Sumdiv \npoj3273\npoj3258\npoj1905\npoj3122\n</code></pre><h3 id=\"三分法求解单峰-单谷-的极值\"><a href=\"#三分法求解单峰-单谷-的极值\" class=\"headerlink\" title=\"三分法求解单峰(单谷)的极值.\"></a>三分法求解单峰(单谷)的极值.</h3><h3 id=\"0-1分数规划-poj2976\"><a href=\"#0-1分数规划-poj2976\" class=\"headerlink\" title=\"0/1分数规划. (poj2976)\"></a>0/1分数规划. (poj2976)</h3><h3 id=\"矩阵法\"><a href=\"#矩阵法\" class=\"headerlink\" title=\"矩阵法\"></a>矩阵法</h3><h3 id=\"随机化算法\"><a href=\"#随机化算法\" class=\"headerlink\" title=\"随机化算法\"></a>随机化算法</h3><pre><code>poj3318\npoj2454\n</code></pre><h3 id=\"迭代逼近\"><a href=\"#迭代逼近\" class=\"headerlink\" title=\"迭代逼近\"></a>迭代逼近</h3><pre><code>poj3301\n</code></pre><h3 id=\"扫描线算法\"><a href=\"#扫描线算法\" class=\"headerlink\" title=\"扫描线算法\"></a>扫描线算法</h3><h2 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h2><h3 id=\"巴什博奕（BashGame）\"><a href=\"#巴什博奕（BashGame）\" class=\"headerlink\" title=\"巴什博奕（BashGame）\"></a>巴什博奕（BashGame）</h3><h3 id=\"威佐夫博奕（WythoffGame）\"><a href=\"#威佐夫博奕（WythoffGame）\" class=\"headerlink\" title=\"威佐夫博奕（WythoffGame）\"></a>威佐夫博奕（WythoffGame）</h3><h3 id=\"尼姆博奕（NimmGame）\"><a href=\"#尼姆博奕（NimmGame）\" class=\"headerlink\" title=\"尼姆博奕（NimmGame）\"></a>尼姆博奕（NimmGame）</h3><h3 id=\"组合博弈\"><a href=\"#组合博弈\" class=\"headerlink\" title=\"组合博弈\"></a>组合博弈</h3><h2 id=\"计算几何\"><a href=\"#计算几何\" class=\"headerlink\" title=\"计算几何\"></a>计算几何</h2><h3 id=\"叉积和点积的运用-如线段相交的判定-点到线段的距离等\"><a href=\"#叉积和点积的运用-如线段相交的判定-点到线段的距离等\" class=\"headerlink\" title=\"叉积和点积的运用(如线段相交的判定,点到线段的距离等).\"></a>叉积和点积的运用(如线段相交的判定,点到线段的距离等).</h3><pre><code>poj2031\npoj1039\n</code></pre><h3 id=\"多边型的简单算法-求面积-和相关判定-点在多边型内-多边型是否相交\"><a href=\"#多边型的简单算法-求面积-和相关判定-点在多边型内-多边型是否相交\" class=\"headerlink\" title=\"多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)\"></a>多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)</h3><pre><code>poj1408\npoj1584\n</code></pre><h3 id=\"二维、三维凸包\"><a href=\"#二维、三维凸包\" class=\"headerlink\" title=\"二维、三维凸包\"></a>二维、三维凸包</h3><pre><code>poj2187\npoj1113\n</code></pre><h3 id=\"扫描线算法-例如求矩形的面积和周长并-常和线段树或堆一起使用\"><a href=\"#扫描线算法-例如求矩形的面积和周长并-常和线段树或堆一起使用\" class=\"headerlink\" title=\"扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).\"></a>扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).</h3><h3 id=\"半平面求交\"><a href=\"#半平面求交\" class=\"headerlink\" title=\"半平面求交\"></a>半平面求交</h3><pre><code>poj3384\npoj2540\npoj3130\npoj3335\n</code></pre><h3 id=\"点集最小圆覆盖\"><a href=\"#点集最小圆覆盖\" class=\"headerlink\" title=\"点集最小圆覆盖.\"></a>点集最小圆覆盖.</h3><h3 id=\"对踵点（最远点对）\"><a href=\"#对踵点（最远点对）\" class=\"headerlink\" title=\"对踵点（最远点对）\"></a>对踵点（最远点对）</h3><pre><code>poj2079\n</code></pre><h3 id=\"几何工具的综合应用\"><a href=\"#几何工具的综合应用\" class=\"headerlink\" title=\"几何工具的综合应用.\"></a>几何工具的综合应用.</h3><pre><code>poj1819\npoj1066\npoj2043\npoj3227\npoj2165\npoj3429\n</code></pre>"},{"title":"Codeforces","date":"2018-07-03T06:18:14.000Z","mathjax":true,"_content":"\n*思维技巧*\n\n## description\n\n>Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.\nMolly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.\nHelp her to do so in finding the total number of such segments.\n\n## Input\n\n>The first line of input contains two integers, n and k, the number of chemicals and the number, such that the total affection value is a non-negative power of this number k. (1 ≤ n ≤ 105, 1 ≤ |k| ≤ 10).\nNext line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — affection values of chemicals.\n\n## Output\n\n>Output a single integer — the number of valid segments.\n\n## Examples \n### input\n\n>4 2\n2 2 2 2\n\n### output\n\n>8\n\n### input\n\n>4 -3\n3 -6 -3 12\n\n### output\n\n>3\n\n## 题解\n\n>首先输入n，k。之后输入n个数，求子序列和为 k ^ m ( m = 0,1,2,3 ...) 的数量。\n>定义 sum[i] 为前i个数的和，则有 sum[i] - sum[j] == k ^ m, 但是算两次 sum[i] 和 sum[j] 时间复杂度就较大；我们来转化一下公式，使它变成 以下这样  sum[i] - k ^ m ==  sum[j] ，我们可以发现，如果存在 sum[i] - k ^ m 的值，那么就可以说明有这么一对 i ， j 使结果存在，但是时间复杂度为 o( m lg n )。 \n \n## code\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <cctype>\n#include <set>\n#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))\n#define Fors(i,a,b) for(int (i)=(a);(i) > (b); --(i))\n#define sd(x) cout << \"start debug:\" << (x) << endl;\n#define ed(x) cout << \"end debug:\" << (x) << endl;\n#define rei(x) scanf(\"%d\",&x)\n#define rel(x) scanf(\"%lld\",&x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long LL;\nconst LL INF = 1e14;\n\nint n;\nLL k,sum[100050];\nmap<LL,LL>x;\nset<LL>a;\nset<LL>::iterator it;\n\nint main()\n{\n    while(~scanf(\"%d %lld\",&n,&k))\n    {\n        x.clear();\n        a.clear();\n        sum[0]=0;\n        for(int i=1;i<=n;i++) scanf(\"%lld\",&sum[i]),sum[i]+=sum[i-1];\n\n        a.insert(1);\n        LL temp=k;\n        for(int i=1;i<=60;i++){\n            if(temp>INF) break;\n            a.insert(temp);\n            temp*=k;\n        }\n\n        LL ans=0;\n        x[0]=1;\n        for(int i=1;i<=n;i++){\n            for(it=a.begin();it!=a.end();it++) ans+=x[sum[i]-*it];\n            x[sum[i]]++;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n","source":"_posts/Codeforces-400-C-Molly-s-Chemicals.md","raw":"---\ntitle: Codeforces #400 C. Molly's Chemicals\ndate: 2018-07-03 14:18:14\nmathjax: true\ntags: \n    - 思维技巧\ncategories: Algorithm\n---\n\n*思维技巧*\n\n## description\n\n>Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.\nMolly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.\nHelp her to do so in finding the total number of such segments.\n\n## Input\n\n>The first line of input contains two integers, n and k, the number of chemicals and the number, such that the total affection value is a non-negative power of this number k. (1 ≤ n ≤ 105, 1 ≤ |k| ≤ 10).\nNext line contains n integers a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — affection values of chemicals.\n\n## Output\n\n>Output a single integer — the number of valid segments.\n\n## Examples \n### input\n\n>4 2\n2 2 2 2\n\n### output\n\n>8\n\n### input\n\n>4 -3\n3 -6 -3 12\n\n### output\n\n>3\n\n## 题解\n\n>首先输入n，k。之后输入n个数，求子序列和为 k ^ m ( m = 0,1,2,3 ...) 的数量。\n>定义 sum[i] 为前i个数的和，则有 sum[i] - sum[j] == k ^ m, 但是算两次 sum[i] 和 sum[j] 时间复杂度就较大；我们来转化一下公式，使它变成 以下这样  sum[i] - k ^ m ==  sum[j] ，我们可以发现，如果存在 sum[i] - k ^ m 的值，那么就可以说明有这么一对 i ， j 使结果存在，但是时间复杂度为 o( m lg n )。 \n \n## code\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <cctype>\n#include <set>\n#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))\n#define Fors(i,a,b) for(int (i)=(a);(i) > (b); --(i))\n#define sd(x) cout << \"start debug:\" << (x) << endl;\n#define ed(x) cout << \"end debug:\" << (x) << endl;\n#define rei(x) scanf(\"%d\",&x)\n#define rel(x) scanf(\"%lld\",&x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long LL;\nconst LL INF = 1e14;\n\nint n;\nLL k,sum[100050];\nmap<LL,LL>x;\nset<LL>a;\nset<LL>::iterator it;\n\nint main()\n{\n    while(~scanf(\"%d %lld\",&n,&k))\n    {\n        x.clear();\n        a.clear();\n        sum[0]=0;\n        for(int i=1;i<=n;i++) scanf(\"%lld\",&sum[i]),sum[i]+=sum[i-1];\n\n        a.insert(1);\n        LL temp=k;\n        for(int i=1;i<=60;i++){\n            if(temp>INF) break;\n            a.insert(temp);\n            temp*=k;\n        }\n\n        LL ans=0;\n        x[0]=1;\n        for(int i=1;i<=n;i++){\n            for(it=a.begin();it!=a.end();it++) ans+=x[sum[i]-*it];\n            x[sum[i]]++;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n","slug":"Codeforces-400-C-Molly-s-Chemicals","published":1,"updated":"2018-07-03T06:29:44.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tur0004plxpuqlpafei","content":"<p><em>思维技巧</em></p>\n<h2 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h2><blockquote>\n<p>Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.<br>Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.<br>Help her to do so in finding the total number of such segments.</p>\n</blockquote>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><blockquote>\n<p>The first line of input contains two integers, n and k, the number of chemicals and the number, such that the total affection value is a non-negative power of this number k. (1 ≤ n ≤ 105, 1 ≤ |k| ≤ 10).<br>Next line contains n integers a1, a2, …, an ( - 109 ≤ ai ≤ 109) — affection values of chemicals.</p>\n</blockquote>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><blockquote>\n<p>Output a single integer — the number of valid segments.</p>\n</blockquote>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h3 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h3><blockquote>\n<p>4 2<br>2 2 2 2</p>\n</blockquote>\n<h3 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h3><blockquote>\n<p>8</p>\n</blockquote>\n<h3 id=\"input-1\"><a href=\"#input-1\" class=\"headerlink\" title=\"input\"></a>input</h3><blockquote>\n<p>4 -3<br>3 -6 -3 12</p>\n</blockquote>\n<h3 id=\"output-1\"><a href=\"#output-1\" class=\"headerlink\" title=\"output\"></a>output</h3><blockquote>\n<p>3</p>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><blockquote>\n<p>首先输入n，k。之后输入n个数，求子序列和为 k ^ m ( m = 0,1,2,3 …) 的数量。<br>定义 sum[i] 为前i个数的和，则有 sum[i] - sum[j] == k ^ m, 但是算两次 sum[i] 和 sum[j] 时间复杂度就较大；我们来转化一下公式，使它变成 以下这样  sum[i] - k ^ m ==  sum[j] ，我们可以发现，如果存在 sum[i] - k ^ m 的值，那么就可以说明有这么一对 i ， j 使结果存在，但是时间复杂度为 o( m lg n )。 </p>\n</blockquote>\n<h2 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> For(i,a,b) for(int (i)=(a);(i) &lt; (b); ++(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Fors(i,a,b) for(int (i)=(a);(i) &gt; (b); --(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> sd(x) cout &lt;&lt; <span class=\"meta-string\">\"start debug:\"</span> &lt;&lt; (x) &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ed(x) cout &lt;&lt; <span class=\"meta-string\">\"end debug:\"</span> &lt;&lt; (x) &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rei(x) scanf(<span class=\"meta-string\">\"%d\"</span>,&amp;x)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rel(x) scanf(<span class=\"meta-string\">\"%lld\"</span>,&amp;x)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vi;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; qi;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">1e14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">LL k,sum[<span class=\"number\">100050</span>];</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;LL,LL&gt;x;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;LL&gt;a;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;LL&gt;::iterator it;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %lld\"</span>,&amp;n,&amp;k))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x.clear();</span><br><span class=\"line\">        a.clear();</span><br><span class=\"line\">        sum[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;sum[i]),sum[i]+=sum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        a.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">        LL temp=k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">60</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp&gt;INF) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            a.insert(temp);</span><br><span class=\"line\">            temp*=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        LL ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        x[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(it=a.begin();it!=a.end();it++) ans+=x[sum[i]-*it];</span><br><span class=\"line\">            x[sum[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>思维技巧</em></p>\n<h2 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h2><blockquote>\n<p>Molly Hooper has n different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The i-th of them has affection value ai.<br>Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of k. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.<br>Help her to do so in finding the total number of such segments.</p>\n</blockquote>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><blockquote>\n<p>The first line of input contains two integers, n and k, the number of chemicals and the number, such that the total affection value is a non-negative power of this number k. (1 ≤ n ≤ 105, 1 ≤ |k| ≤ 10).<br>Next line contains n integers a1, a2, …, an ( - 109 ≤ ai ≤ 109) — affection values of chemicals.</p>\n</blockquote>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><blockquote>\n<p>Output a single integer — the number of valid segments.</p>\n</blockquote>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h3 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h3><blockquote>\n<p>4 2<br>2 2 2 2</p>\n</blockquote>\n<h3 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h3><blockquote>\n<p>8</p>\n</blockquote>\n<h3 id=\"input-1\"><a href=\"#input-1\" class=\"headerlink\" title=\"input\"></a>input</h3><blockquote>\n<p>4 -3<br>3 -6 -3 12</p>\n</blockquote>\n<h3 id=\"output-1\"><a href=\"#output-1\" class=\"headerlink\" title=\"output\"></a>output</h3><blockquote>\n<p>3</p>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><blockquote>\n<p>首先输入n，k。之后输入n个数，求子序列和为 k ^ m ( m = 0,1,2,3 …) 的数量。<br>定义 sum[i] 为前i个数的和，则有 sum[i] - sum[j] == k ^ m, 但是算两次 sum[i] 和 sum[j] 时间复杂度就较大；我们来转化一下公式，使它变成 以下这样  sum[i] - k ^ m ==  sum[j] ，我们可以发现，如果存在 sum[i] - k ^ m 的值，那么就可以说明有这么一对 i ， j 使结果存在，但是时间复杂度为 o( m lg n )。 </p>\n</blockquote>\n<h2 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> For(i,a,b) for(int (i)=(a);(i) &lt; (b); ++(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Fors(i,a,b) for(int (i)=(a);(i) &gt; (b); --(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> sd(x) cout &lt;&lt; <span class=\"meta-string\">\"start debug:\"</span> &lt;&lt; (x) &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ed(x) cout &lt;&lt; <span class=\"meta-string\">\"end debug:\"</span> &lt;&lt; (x) &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rei(x) scanf(<span class=\"meta-string\">\"%d\"</span>,&amp;x)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rel(x) scanf(<span class=\"meta-string\">\"%lld\"</span>,&amp;x)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vi;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; qi;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LL INF = <span class=\"number\">1e14</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">LL k,sum[<span class=\"number\">100050</span>];</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;LL,LL&gt;x;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;LL&gt;a;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;LL&gt;::iterator it;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %lld\"</span>,&amp;n,&amp;k))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x.clear();</span><br><span class=\"line\">        a.clear();</span><br><span class=\"line\">        sum[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;sum[i]),sum[i]+=sum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        a.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">        LL temp=k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">60</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp&gt;INF) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            a.insert(temp);</span><br><span class=\"line\">            temp*=k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        LL ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        x[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(it=a.begin();it!=a.end();it++) ans+=x[sum[i]-*it];</span><br><span class=\"line\">            x[sum[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-1043 Eight","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型： A\\*算法*\n\n## EXAMPLE\n\n### description\n\nThe 15-puzzle has been around for over 100 years; even if you don't know it by that name, you've seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let's call the missing tile 'x'; the object of the puzzle is to arrange the tiles so that they are ordered as: \n\n1   2   3   4\n5   6   7   8\n9   10 11 12\n13 14 15  x\n\nwhere the only legal operation is to exchange 'x' with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: \n\n 1   2   3   4       1   2   3   4      1   2   3   4       1   2   3   4\n 5   6   7   8       5   6   7   8      5   6   7   8       5   6   7   8\n 9   x  10 12      9  10  x  12     9  10 11 12     9  10 11 12\n13 14 11 15    13 14 11 15    13 14  x  15    13 14 15  x\n\nThe letters in the previous row indicate which neighbor of the 'x' tile is swapped with the 'x' tile at each step; legal values are 'r','l','u' and 'd', for right, left, up, and down, respectively. \n\nNot all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and \nfrustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing 'x' tile, of course). \n\nIn this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three \narrangement. \n\n### Input\n\nYou will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus 'x'. For example, this puzzle \n\n1 2 3 \nx 4 6 \n7 5 8 \n\nis described by this list: \n\n1 2 3 x 4 6 7 5 8 \n\n### Output\n\nYou will print to standard output either the word ``unsolvable'', if the puzzle has no solution, or a string consisting entirely of the letters 'r', 'l', 'u' and 'd' that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. \n\n### Sample Input\n\n2  3  4  1  5  x  7  6  8\n\n### Sample Output\n\nullddrurdllurdruldr\n\n## 题解\n\n这题核心思想是使用A*算法，并且需要通过hash确定每种状态的序号，以用来访问数组来确定时候被访问过和父节点的存储。\n\n首先hash的核心算法是康托展开。其次A\\*算法使用估值函数确定最优节点，以放入队列中进行搜索。A\\*算法的参数有三个f、h、g，f = h + g，g为已花费的代价（题中指已经走过的步数），h为估算的代价（题中指在无障碍的情况下最少还需要多少步到达终点目标），正式地，这个距离叫做曼哈顿距离。\n\n最后一点，每次数字的移动会使状态的逆序数改变，但是不改变奇偶性。\n\n## 代码\n\n```c++\ninclude<iostream>\ninclude<cstdio>\ninclude<cstring>\ninclude<queue>\ninclude<cmath>\nusing namespace std;\n\nstruct node     //状态\n{\n    int a[10];\n    int f, h, g;\n    int x;      //x在的位置\n\n    friend bool operator < (node a, node b)\n    {\n        return a.f > b.f;\n    }\n};\n\npriority_queue<node>que;\nint fac[10];\n//46233\nstruct\n{\n    int father;\n    char dir;\n}vis[362881];\n\nint get_h(int a[])\n{\n    int h = 0;\n    for(int i = 0; i < 8; i++)\n    {\n        if(a[i])\n            h += fabs((a[i]-1)/3 - i/3) + fabs((a[i]-1)%3 - i%3);\n    }\n    return h;\n}\n\nint Hash(int a[])\n{\n    int ans = 0;\n    for(int i = 0; i < 9; i++)\n    {\n        int tmp = 0;\n        for(int j = i+1; j < 9; j++)\n        {\n            if(a[i] > a[j]) tmp++;\n        }\n        ans += tmp*fac[8-i];\n    }\n    return ans+1;\n}\n\nvoid prin(int n)\n{\n//    printf(\"n=%d\\n\", n);\n    if(vis[n].father!=-1)\n    {\n        prin(vis[n].father);\n        printf(\"%c\", vis[n].dir);\n    }\n}\n\nvoid SWAP(int &x, int &y)\n{\n    int t = x;\n    x = y;\n    y = t;\n}\n\nint dir[4][2] = { {1, 0}, {-1, 0}, {0, -1}, {0, 1} };\nchar dd[] = \"dulr\";\n\nbool is(int a[])\n{\n    int ans = 0;\n    for(int i = 0; i < 9; i++)\n    {\n        if(a[i])\n        for(int j = i+1; j < 9; j++)\n        {\n            if(a[i] > a[j] && a[j])\n                ans++;\n        }\n    }\n    return !(ans & 1);\n}\n\nvoid debug(int a[])\n{\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 3; j++)\n        {\n            printf(\"%d \", a[i*3+j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint bfs(node star)\n{\n    while(!que.empty()) que.pop();\n    que.push( star );\n    star.h = get_h( star.a );    star.g = 0;\n    star.f = star.g + star.h;\n    vis[ Hash( star.a ) ].father = -1;\n    while(!que.empty()){\n        node tmp = que.top(); que.pop();\n        int father = Hash(tmp.a);\n        for(int i = 0; i < 4; i++){\n            int x = dir[i][0] + tmp.x/3;\n            int y = dir[i][1] + tmp.x%3;\n            if(0 <= x && x < 3 && 0 <= y && y < 3){\n                node s = tmp; s.x = x*3+y;\n                SWAP( s.a[ tmp.x ], s.a[ s.x ] );\n                s.g++;\n                s.h = get_h( s.a ); s.f = s.h + s.g;\n                int son = Hash(s.a);\n\n                if(son == 46234){\n                    vis[ son ].father = father;\n                    vis[ son ].dir = dd[i];\n                    prin(46234);printf(\"\\n\");\n                    return 0;\n                }\n                if(!vis[ son ].father && is(s.a)){\n                    vis[ son ].father = father;\n                    vis[ son ].dir = dd[i];\n                    que.push( s );\n                }\n            }\n        }\n    }\n    return 1;\n}\n\n\nint main(void)\n{\n    int i;\n    fac[1] = 1;\n    for(i = 2; i < 10; i++) fac[i] = fac[i-1]*i;\n    node star;\n    char in[2];\n//    freopen(\"ou.txt\", \"w\", stdout);\n    while(~scanf(\"%s\", in))\n    {\n        memset(vis, 0, sizeof(vis));\n        if(in[0] == 'x')\n        {\n            star.a[0] = 0;\n            star.x = 0;\n        }\n        else star.a[0] = in[0] - '0';\n        for(i = 1; i < 9; i++)\n        {\n            scanf(\"%s\", in);\n            if(in[0] == 'x')\n            {\n                star.a[i] = 0;\n                star.x = i;\n            }\n            else star.a[i] = in[0] - '0';\n        }\n        if(!is(star.a))\n        {\n            printf(\"unsolvable\\n\");continue;\n        }\n        if(Hash(star.a) == 46234) {printf(\"\\n\"); continue;}\n        if(bfs(star))\n        {\n            printf(\"unsolvable\\n\");\n        }\n    }\n    return 0;\n}\n\n```\n\n","source":"_posts/HDU-1043 Eight.md","raw":"---\ntitle: HDU-1043 Eight\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 搜索\n    - A*算法\ncategories: Algorithm\n---\n\n*类型： A\\*算法*\n\n## EXAMPLE\n\n### description\n\nThe 15-puzzle has been around for over 100 years; even if you don't know it by that name, you've seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let's call the missing tile 'x'; the object of the puzzle is to arrange the tiles so that they are ordered as: \n\n1   2   3   4\n5   6   7   8\n9   10 11 12\n13 14 15  x\n\nwhere the only legal operation is to exchange 'x' with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: \n\n 1   2   3   4       1   2   3   4      1   2   3   4       1   2   3   4\n 5   6   7   8       5   6   7   8      5   6   7   8       5   6   7   8\n 9   x  10 12      9  10  x  12     9  10 11 12     9  10 11 12\n13 14 11 15    13 14 11 15    13 14  x  15    13 14 15  x\n\nThe letters in the previous row indicate which neighbor of the 'x' tile is swapped with the 'x' tile at each step; legal values are 'r','l','u' and 'd', for right, left, up, and down, respectively. \n\nNot all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and \nfrustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing 'x' tile, of course). \n\nIn this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three \narrangement. \n\n### Input\n\nYou will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus 'x'. For example, this puzzle \n\n1 2 3 \nx 4 6 \n7 5 8 \n\nis described by this list: \n\n1 2 3 x 4 6 7 5 8 \n\n### Output\n\nYou will print to standard output either the word ``unsolvable'', if the puzzle has no solution, or a string consisting entirely of the letters 'r', 'l', 'u' and 'd' that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. \n\n### Sample Input\n\n2  3  4  1  5  x  7  6  8\n\n### Sample Output\n\nullddrurdllurdruldr\n\n## 题解\n\n这题核心思想是使用A*算法，并且需要通过hash确定每种状态的序号，以用来访问数组来确定时候被访问过和父节点的存储。\n\n首先hash的核心算法是康托展开。其次A\\*算法使用估值函数确定最优节点，以放入队列中进行搜索。A\\*算法的参数有三个f、h、g，f = h + g，g为已花费的代价（题中指已经走过的步数），h为估算的代价（题中指在无障碍的情况下最少还需要多少步到达终点目标），正式地，这个距离叫做曼哈顿距离。\n\n最后一点，每次数字的移动会使状态的逆序数改变，但是不改变奇偶性。\n\n## 代码\n\n```c++\ninclude<iostream>\ninclude<cstdio>\ninclude<cstring>\ninclude<queue>\ninclude<cmath>\nusing namespace std;\n\nstruct node     //状态\n{\n    int a[10];\n    int f, h, g;\n    int x;      //x在的位置\n\n    friend bool operator < (node a, node b)\n    {\n        return a.f > b.f;\n    }\n};\n\npriority_queue<node>que;\nint fac[10];\n//46233\nstruct\n{\n    int father;\n    char dir;\n}vis[362881];\n\nint get_h(int a[])\n{\n    int h = 0;\n    for(int i = 0; i < 8; i++)\n    {\n        if(a[i])\n            h += fabs((a[i]-1)/3 - i/3) + fabs((a[i]-1)%3 - i%3);\n    }\n    return h;\n}\n\nint Hash(int a[])\n{\n    int ans = 0;\n    for(int i = 0; i < 9; i++)\n    {\n        int tmp = 0;\n        for(int j = i+1; j < 9; j++)\n        {\n            if(a[i] > a[j]) tmp++;\n        }\n        ans += tmp*fac[8-i];\n    }\n    return ans+1;\n}\n\nvoid prin(int n)\n{\n//    printf(\"n=%d\\n\", n);\n    if(vis[n].father!=-1)\n    {\n        prin(vis[n].father);\n        printf(\"%c\", vis[n].dir);\n    }\n}\n\nvoid SWAP(int &x, int &y)\n{\n    int t = x;\n    x = y;\n    y = t;\n}\n\nint dir[4][2] = { {1, 0}, {-1, 0}, {0, -1}, {0, 1} };\nchar dd[] = \"dulr\";\n\nbool is(int a[])\n{\n    int ans = 0;\n    for(int i = 0; i < 9; i++)\n    {\n        if(a[i])\n        for(int j = i+1; j < 9; j++)\n        {\n            if(a[i] > a[j] && a[j])\n                ans++;\n        }\n    }\n    return !(ans & 1);\n}\n\nvoid debug(int a[])\n{\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 3; j++)\n        {\n            printf(\"%d \", a[i*3+j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint bfs(node star)\n{\n    while(!que.empty()) que.pop();\n    que.push( star );\n    star.h = get_h( star.a );    star.g = 0;\n    star.f = star.g + star.h;\n    vis[ Hash( star.a ) ].father = -1;\n    while(!que.empty()){\n        node tmp = que.top(); que.pop();\n        int father = Hash(tmp.a);\n        for(int i = 0; i < 4; i++){\n            int x = dir[i][0] + tmp.x/3;\n            int y = dir[i][1] + tmp.x%3;\n            if(0 <= x && x < 3 && 0 <= y && y < 3){\n                node s = tmp; s.x = x*3+y;\n                SWAP( s.a[ tmp.x ], s.a[ s.x ] );\n                s.g++;\n                s.h = get_h( s.a ); s.f = s.h + s.g;\n                int son = Hash(s.a);\n\n                if(son == 46234){\n                    vis[ son ].father = father;\n                    vis[ son ].dir = dd[i];\n                    prin(46234);printf(\"\\n\");\n                    return 0;\n                }\n                if(!vis[ son ].father && is(s.a)){\n                    vis[ son ].father = father;\n                    vis[ son ].dir = dd[i];\n                    que.push( s );\n                }\n            }\n        }\n    }\n    return 1;\n}\n\n\nint main(void)\n{\n    int i;\n    fac[1] = 1;\n    for(i = 2; i < 10; i++) fac[i] = fac[i-1]*i;\n    node star;\n    char in[2];\n//    freopen(\"ou.txt\", \"w\", stdout);\n    while(~scanf(\"%s\", in))\n    {\n        memset(vis, 0, sizeof(vis));\n        if(in[0] == 'x')\n        {\n            star.a[0] = 0;\n            star.x = 0;\n        }\n        else star.a[0] = in[0] - '0';\n        for(i = 1; i < 9; i++)\n        {\n            scanf(\"%s\", in);\n            if(in[0] == 'x')\n            {\n                star.a[i] = 0;\n                star.x = i;\n            }\n            else star.a[i] = in[0] - '0';\n        }\n        if(!is(star.a))\n        {\n            printf(\"unsolvable\\n\");continue;\n        }\n        if(Hash(star.a) == 46234) {printf(\"\\n\"); continue;}\n        if(bfs(star))\n        {\n            printf(\"unsolvable\\n\");\n        }\n    }\n    return 0;\n}\n\n```\n\n","slug":"HDU-1043 Eight","published":1,"updated":"2018-07-03T06:29:57.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tut0005plxplbqhg5if","content":"<p><em>类型： A\\</em>算法*</p>\n<h2 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h2><h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p>\n<p>1   2   3   4<br>5   6   7   8<br>9   10 11 12<br>13 14 15  x</p>\n<p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p>\n<p> 1   2   3   4       1   2   3   4      1   2   3   4       1   2   3   4<br> 5   6   7   8       5   6   7   8      5   6   7   8       5   6   7   8<br> 9   x  10 12      9  10  x  12     9  10 11 12     9  10 11 12<br>13 14 11 15    13 14 11 15    13 14  x  15    13 14 15  x</p>\n<p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively. </p>\n<p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course). </p>\n<p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle </p>\n<p>1 2 3<br>x 4 6<br>7 5 8 </p>\n<p>is described by this list: </p>\n<p>1 2 3 x 4 6 7 5 8 </p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>You will print to standard output either the word <code></code>unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. </p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2  3  4  1  5  x  7  6  8</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>ullddrurdllurdruldr</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题核心思想是使用A*算法，并且需要通过hash确定每种状态的序号，以用来访问数组来确定时候被访问过和父节点的存储。</p>\n<p>首先hash的核心算法是康托展开。其次A*算法使用估值函数确定最优节点，以放入队列中进行搜索。A*算法的参数有三个f、h、g，f = h + g，g为已花费的代价（题中指已经走过的步数），h为估算的代价（题中指在无障碍的情况下最少还需要多少步到达终点目标），正式地，这个距离叫做曼哈顿距离。</p>\n<p>最后一点，每次数字的移动会使状态的逆序数改变，但是不改变奇偶性。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;iostream&gt;</span><br><span class=\"line\">include&lt;cstdio&gt;</span><br><span class=\"line\">include&lt;cstring&gt;</span><br><span class=\"line\">include&lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include&lt;cmath&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>     //状态</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, h, g;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;      <span class=\"comment\">//x在的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (node a, node b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.f &gt; b.f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">priority_queue&lt;node&gt;que;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fac[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//46233</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> father;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dir;</span><br><span class=\"line\">&#125;vis[<span class=\"number\">362881</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_h</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i])</span><br><span class=\"line\">            h += <span class=\"built_in\">fabs</span>((a[i]<span class=\"number\">-1</span>)/<span class=\"number\">3</span> - i/<span class=\"number\">3</span>) + <span class=\"built_in\">fabs</span>((a[i]<span class=\"number\">-1</span>)%<span class=\"number\">3</span> - i%<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; <span class=\"number\">9</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt; a[j]) tmp++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += tmp*fac[<span class=\"number\">8</span>-i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prin</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    printf(\"n=%d\\n\", n);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vis[n].father!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        prin(vis[n].father);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, vis[n].dir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SWAP</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dir[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123; &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> dd[] = <span class=\"string\">\"dulr\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i])</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; <span class=\"number\">9</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt; a[j] &amp;&amp; a[j])</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(ans &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, a[i*<span class=\"number\">3</span>+j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(node star)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty()) que.pop();</span><br><span class=\"line\">    que.push( star );</span><br><span class=\"line\">    star.h = get_h( star.a );    star.g = <span class=\"number\">0</span>;</span><br><span class=\"line\">    star.f = star.g + star.h;</span><br><span class=\"line\">    vis[ Hash( star.a ) ].father = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        node tmp = que.top(); que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> father = Hash(tmp.a);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = dir[i][<span class=\"number\">0</span>] + tmp.x/<span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = dir[i][<span class=\"number\">1</span>] + tmp.x%<span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt;= x &amp;&amp; x &lt; <span class=\"number\">3</span> &amp;&amp; <span class=\"number\">0</span> &lt;= y &amp;&amp; y &lt; <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">                node s = tmp; s.x = x*<span class=\"number\">3</span>+y;</span><br><span class=\"line\">                SWAP( s.a[ tmp.x ], s.a[ s.x ] );</span><br><span class=\"line\">                s.g++;</span><br><span class=\"line\">                s.h = get_h( s.a ); s.f = s.h + s.g;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> son = Hash(s.a);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(son == <span class=\"number\">46234</span>)&#123;</span><br><span class=\"line\">                    vis[ son ].father = father;</span><br><span class=\"line\">                    vis[ son ].dir = dd[i];</span><br><span class=\"line\">                    prin(<span class=\"number\">46234</span>);<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[ son ].father &amp;&amp; is(s.a))&#123;</span><br><span class=\"line\">                    vis[ son ].father = father;</span><br><span class=\"line\">                    vis[ son ].dir = dd[i];</span><br><span class=\"line\">                    que.push( s );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    fac[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt; <span class=\"number\">10</span>; i++) fac[i] = fac[i<span class=\"number\">-1</span>]*i;</span><br><span class=\"line\">    node star;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> in[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">//    freopen(\"ou.txt\", \"w\", stdout);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, in))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            star.a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            star.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> star.a[<span class=\"number\">0</span>] = in[<span class=\"number\">0</span>] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, in);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(in[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                star.a[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                star.x = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> star.a[i] = in[<span class=\"number\">0</span>] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!is(star.a))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unsolvable\\n\"</span>);<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Hash(star.a) == <span class=\"number\">46234</span>) &#123;<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>); <span class=\"keyword\">continue</span>;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bfs(star))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unsolvable\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： A\\</em>算法*</p>\n<h2 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h2><h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: </p>\n<p>1   2   3   4<br>5   6   7   8<br>9   10 11 12<br>13 14 15  x</p>\n<p>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: </p>\n<p> 1   2   3   4       1   2   3   4      1   2   3   4       1   2   3   4<br> 5   6   7   8       5   6   7   8      5   6   7   8       5   6   7   8<br> 9   x  10 12      9  10  x  12     9  10 11 12     9  10 11 12<br>13 14 11 15    13 14 11 15    13 14  x  15    13 14 15  x</p>\n<p>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively. </p>\n<p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course). </p>\n<p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle </p>\n<p>1 2 3<br>x 4 6<br>7 5 8 </p>\n<p>is described by this list: </p>\n<p>1 2 3 x 4 6 7 5 8 </p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>You will print to standard output either the word <code></code>unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. </p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2  3  4  1  5  x  7  6  8</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>ullddrurdllurdruldr</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题核心思想是使用A*算法，并且需要通过hash确定每种状态的序号，以用来访问数组来确定时候被访问过和父节点的存储。</p>\n<p>首先hash的核心算法是康托展开。其次A*算法使用估值函数确定最优节点，以放入队列中进行搜索。A*算法的参数有三个f、h、g，f = h + g，g为已花费的代价（题中指已经走过的步数），h为估算的代价（题中指在无障碍的情况下最少还需要多少步到达终点目标），正式地，这个距离叫做曼哈顿距离。</p>\n<p>最后一点，每次数字的移动会使状态的逆序数改变，但是不改变奇偶性。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;iostream&gt;</span><br><span class=\"line\">include&lt;cstdio&gt;</span><br><span class=\"line\">include&lt;cstring&gt;</span><br><span class=\"line\">include&lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include&lt;cmath&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>     //状态</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, h, g;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;      <span class=\"comment\">//x在的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (node a, node b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.f &gt; b.f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">priority_queue&lt;node&gt;que;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fac[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//46233</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> father;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dir;</span><br><span class=\"line\">&#125;vis[<span class=\"number\">362881</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_h</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i])</span><br><span class=\"line\">            h += <span class=\"built_in\">fabs</span>((a[i]<span class=\"number\">-1</span>)/<span class=\"number\">3</span> - i/<span class=\"number\">3</span>) + <span class=\"built_in\">fabs</span>((a[i]<span class=\"number\">-1</span>)%<span class=\"number\">3</span> - i%<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; <span class=\"number\">9</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt; a[j]) tmp++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += tmp*fac[<span class=\"number\">8</span>-i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prin</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    printf(\"n=%d\\n\", n);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vis[n].father!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        prin(vis[n].father);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, vis[n].dir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SWAP</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dir[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123; &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> dd[] = <span class=\"string\">\"dulr\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i])</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; <span class=\"number\">9</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i] &gt; a[j] &amp;&amp; a[j])</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(ans &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, a[i*<span class=\"number\">3</span>+j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">(node star)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty()) que.pop();</span><br><span class=\"line\">    que.push( star );</span><br><span class=\"line\">    star.h = get_h( star.a );    star.g = <span class=\"number\">0</span>;</span><br><span class=\"line\">    star.f = star.g + star.h;</span><br><span class=\"line\">    vis[ Hash( star.a ) ].father = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        node tmp = que.top(); que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> father = Hash(tmp.a);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = dir[i][<span class=\"number\">0</span>] + tmp.x/<span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = dir[i][<span class=\"number\">1</span>] + tmp.x%<span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt;= x &amp;&amp; x &lt; <span class=\"number\">3</span> &amp;&amp; <span class=\"number\">0</span> &lt;= y &amp;&amp; y &lt; <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">                node s = tmp; s.x = x*<span class=\"number\">3</span>+y;</span><br><span class=\"line\">                SWAP( s.a[ tmp.x ], s.a[ s.x ] );</span><br><span class=\"line\">                s.g++;</span><br><span class=\"line\">                s.h = get_h( s.a ); s.f = s.h + s.g;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> son = Hash(s.a);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(son == <span class=\"number\">46234</span>)&#123;</span><br><span class=\"line\">                    vis[ son ].father = father;</span><br><span class=\"line\">                    vis[ son ].dir = dd[i];</span><br><span class=\"line\">                    prin(<span class=\"number\">46234</span>);<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[ son ].father &amp;&amp; is(s.a))&#123;</span><br><span class=\"line\">                    vis[ son ].father = father;</span><br><span class=\"line\">                    vis[ son ].dir = dd[i];</span><br><span class=\"line\">                    que.push( s );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    fac[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt; <span class=\"number\">10</span>; i++) fac[i] = fac[i<span class=\"number\">-1</span>]*i;</span><br><span class=\"line\">    node star;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> in[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">//    freopen(\"ou.txt\", \"w\", stdout);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, in))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            star.a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            star.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> star.a[<span class=\"number\">0</span>] = in[<span class=\"number\">0</span>] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, in);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(in[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                star.a[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                star.x = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> star.a[i] = in[<span class=\"number\">0</span>] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!is(star.a))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unsolvable\\n\"</span>);<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Hash(star.a) == <span class=\"number\">46234</span>) &#123;<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>); <span class=\"keyword\">continue</span>;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bfs(star))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unsolvable\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-1272 小希的迷宫","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n\n*类型： 并查集*\n\n## 并查集简述：\n\n### 定义：\n\n并查集(union-find sets)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。\n\n### 基本操作：\n\n1. Make_Set(x) 把每一个元素**初始化**为一个集合：\n\n   初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。\n\n2. Find_Set(x) 查找一个元素所在的集合:\n\n   查找一个元素所在的集合，其精髓是找到**这个元素所在集合的祖先**！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。\n\n3. Union(x,y) 合并x,y所在的两个集合：\n\n   合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。具体过程为，利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。\n\n4. Find_Set(x)时 路径压缩：\n\n   寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？\n\n   答案是肯定的，这就是路径压缩，即当我们经过\"递推\"找到祖先节点后，**\"回溯\"的时候顺便将它的子孙节点都直接指向祖先**，这样以后再次Find_Set(x)时复杂度就变成O(1)了。\n\n5. Union(x,y)时 按秩合并：\n\n   即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。\n\n\n## 例题：\n\n### Problem Description\n\n上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 \n\n\n\n![HDU_1272](HDU_1272.png)\n\n\n\n### Input\n\n输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。 \n整个文件以两个-1结尾。\n\n### Output\n\n对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出\"Yes\"，否则输出\"No\"。\n\n### Sample Input\n\n6 8  5 3  5 2  6 4\n5 6  0 0\n\n8 1  7 3  6 2  8 9  7 5\n7 4  7 8  7 6  0 0\n\n3 8  6 8  6 4\n5 3  5 6  5 2  0 0\n\n-1 -1\n\n### Sample Output\n\nYes\nYes\nNo\n\n### 题解：\n\n此题是并查集的基本应用。只需要使用并查集判断是否有环路 且 是否只有单个集合。\n\n有坑。。。 输入 0 0 输出Yes\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <cstring>\nusing namespace std;\n\nconst int MAX = 100005;\nint flag = 0,maxx=0;\nint vis[MAX],pre[MAX]; // pre用来存index的父节点，路径压缩后存的是根节点。\n\t\t\t\t\t   //vis用来判断是否用到这个点。\n\nvoid init(){  //初始化\n\tfor (int i = 0; i < MAX; ++i)\n\t{\n\t\tpre[i] = i;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tflag = 0;\n\tmaxx=0;\n}\nint find(int v){ // find操作\n\tint r = v;\n\twhile(pre[r] != r){ // 寻到当前状态的根节点\n\t\tr = pre[r];\n\t}\n\n\tint i = v,j;\n\twhile(i != r){ // 回溯过程 将所有子节点的pre改为父节点。\n\t\tj = pre[i];\n\t\tpre[i] = r;\n\t\ti = j;\n\t}\n\treturn r;\n}\n\nvoid join(int v1,int v2){\n\tint newX = find(v1),newY = find(v2);\n\n\tif(newX == newY && v1 != v2) // 使用并查集判断时候有环路。\n\t{\n\t\tflag = 1;\n\t}\n\telse\n\t{\n\t\tpre[newX] = newY; // 吧点加入集合\n\t}\n}\n\nvoid isconnect(){ // 判断是否有只有单个图。\n\n    int val = find(pre[maxx]);\n\tfor (int i = 0; i < maxx; ++i)\n\t{\n\t\tif(vis[i] != 0){\n\t\t\tif(find(pre[i]) != find(pre[maxx])){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main()\n{\n\n    int x,y;\n    while(scanf(\"%d%d\",&x,&y))\n    {\n    \tinit();\n    \tif(x==0&&y==0){\n    \t\tprintf(\"Yes\\n\");\n    \t\tcontinue;\n    \t}\n\n    \tif(x == -1 && y == -1)\n    \t\tbreak;\n\n        vis[x] = 1;\n        vis[y] = 1;\n        maxx = max(maxx,max(x,y));\n        join(x,y);\n\n    \twhile(scanf(\"%d%d\",&x,&y) && x && y){\n    \t\tvis[x] = 1;\n    \t\tvis[y] = 1;\n    \t\tmaxx = max(maxx,max(x,y));\n    \t\tjoin(x,y);\n    \t}\n\n    \tisconnect();\n\n    \tif(flag)\n    \t\tprintf(\"No\\n\");\n    \telse\n            printf(\"Yes\\n\");\n    }\n    return 0;\n}\n```\n\n","source":"_posts/HDU-1272 小希的迷宫.md","raw":"---\ntitle: HDU-1272 小希的迷宫\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 图论\n    - 并查集\ncategories: Algorithm\n---\n\n\n*类型： 并查集*\n\n## 并查集简述：\n\n### 定义：\n\n并查集(union-find sets)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。\n\n### 基本操作：\n\n1. Make_Set(x) 把每一个元素**初始化**为一个集合：\n\n   初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。\n\n2. Find_Set(x) 查找一个元素所在的集合:\n\n   查找一个元素所在的集合，其精髓是找到**这个元素所在集合的祖先**！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。\n\n3. Union(x,y) 合并x,y所在的两个集合：\n\n   合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。具体过程为，利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。\n\n4. Find_Set(x)时 路径压缩：\n\n   寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？\n\n   答案是肯定的，这就是路径压缩，即当我们经过\"递推\"找到祖先节点后，**\"回溯\"的时候顺便将它的子孙节点都直接指向祖先**，这样以后再次Find_Set(x)时复杂度就变成O(1)了。\n\n5. Union(x,y)时 按秩合并：\n\n   即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。\n\n\n## 例题：\n\n### Problem Description\n\n上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 \n\n\n\n![HDU_1272](HDU_1272.png)\n\n\n\n### Input\n\n输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。 \n整个文件以两个-1结尾。\n\n### Output\n\n对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出\"Yes\"，否则输出\"No\"。\n\n### Sample Input\n\n6 8  5 3  5 2  6 4\n5 6  0 0\n\n8 1  7 3  6 2  8 9  7 5\n7 4  7 8  7 6  0 0\n\n3 8  6 8  6 4\n5 3  5 6  5 2  0 0\n\n-1 -1\n\n### Sample Output\n\nYes\nYes\nNo\n\n### 题解：\n\n此题是并查集的基本应用。只需要使用并查集判断是否有环路 且 是否只有单个集合。\n\n有坑。。。 输入 0 0 输出Yes\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <cstring>\nusing namespace std;\n\nconst int MAX = 100005;\nint flag = 0,maxx=0;\nint vis[MAX],pre[MAX]; // pre用来存index的父节点，路径压缩后存的是根节点。\n\t\t\t\t\t   //vis用来判断是否用到这个点。\n\nvoid init(){  //初始化\n\tfor (int i = 0; i < MAX; ++i)\n\t{\n\t\tpre[i] = i;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tflag = 0;\n\tmaxx=0;\n}\nint find(int v){ // find操作\n\tint r = v;\n\twhile(pre[r] != r){ // 寻到当前状态的根节点\n\t\tr = pre[r];\n\t}\n\n\tint i = v,j;\n\twhile(i != r){ // 回溯过程 将所有子节点的pre改为父节点。\n\t\tj = pre[i];\n\t\tpre[i] = r;\n\t\ti = j;\n\t}\n\treturn r;\n}\n\nvoid join(int v1,int v2){\n\tint newX = find(v1),newY = find(v2);\n\n\tif(newX == newY && v1 != v2) // 使用并查集判断时候有环路。\n\t{\n\t\tflag = 1;\n\t}\n\telse\n\t{\n\t\tpre[newX] = newY; // 吧点加入集合\n\t}\n}\n\nvoid isconnect(){ // 判断是否有只有单个图。\n\n    int val = find(pre[maxx]);\n\tfor (int i = 0; i < maxx; ++i)\n\t{\n\t\tif(vis[i] != 0){\n\t\t\tif(find(pre[i]) != find(pre[maxx])){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main()\n{\n\n    int x,y;\n    while(scanf(\"%d%d\",&x,&y))\n    {\n    \tinit();\n    \tif(x==0&&y==0){\n    \t\tprintf(\"Yes\\n\");\n    \t\tcontinue;\n    \t}\n\n    \tif(x == -1 && y == -1)\n    \t\tbreak;\n\n        vis[x] = 1;\n        vis[y] = 1;\n        maxx = max(maxx,max(x,y));\n        join(x,y);\n\n    \twhile(scanf(\"%d%d\",&x,&y) && x && y){\n    \t\tvis[x] = 1;\n    \t\tvis[y] = 1;\n    \t\tmaxx = max(maxx,max(x,y));\n    \t\tjoin(x,y);\n    \t}\n\n    \tisconnect();\n\n    \tif(flag)\n    \t\tprintf(\"No\\n\");\n    \telse\n            printf(\"Yes\\n\");\n    }\n    return 0;\n}\n```\n\n","slug":"HDU-1272 小希的迷宫","published":1,"updated":"2018-07-03T06:29:56.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tuu0006plxpg2uj2tzj","content":"<p><em>类型： 并查集</em></p>\n<h2 id=\"并查集简述：\"><a href=\"#并查集简述：\" class=\"headerlink\" title=\"并查集简述：\"></a>并查集简述：</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>并查集(union-find sets)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>\n<h3 id=\"基本操作：\"><a href=\"#基本操作：\" class=\"headerlink\" title=\"基本操作：\"></a>基本操作：</h3><ol>\n<li><p>Make_Set(x) 把每一个元素<strong>初始化</strong>为一个集合：</p>\n<p>初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。</p>\n</li>\n<li><p>Find_Set(x) 查找一个元素所在的集合:</p>\n<p>查找一个元素所在的集合，其精髓是找到<strong>这个元素所在集合的祖先</strong>！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。</p>\n</li>\n<li><p>Union(x,y) 合并x,y所在的两个集合：</p>\n<p>合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。具体过程为，利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。</p>\n</li>\n<li><p>Find_Set(x)时 路径压缩：</p>\n<p>寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？</p>\n<p>答案是肯定的，这就是路径压缩，即当我们经过”递推”找到祖先节点后，<strong>“回溯”的时候顺便将它的子孙节点都直接指向祖先</strong>，这样以后再次Find_Set(x)时复杂度就变成O(1)了。</p>\n</li>\n<li><p>Union(x,y)时 按秩合并：</p>\n<p>即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。</p>\n</li>\n</ol>\n<h2 id=\"例题：\"><a href=\"#例题：\" class=\"headerlink\" title=\"例题：\"></a>例题：</h2><h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 </p>\n<p><img src=\"HDU_1272.png\" alt=\"HDU_1272\"></p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>6 8  5 3  5 2  6 4<br>5 6  0 0</p>\n<p>8 1  7 3  6 2  8 9  7 5<br>7 4  7 8  7 6  0 0</p>\n<p>3 8  6 8  6 4<br>5 3  5 6  5 2  0 0</p>\n<p>-1 -1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>Yes<br>Yes<br>No</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题是并查集的基本应用。只需要使用并查集判断是否有环路 且 是否只有单个集合。</p>\n<p>有坑。。。 输入 0 0 输出Yes</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100005</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>,maxx=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> vis[MAX],pre[MAX]; <span class=\"comment\">// pre用来存index的父节点，路径压缩后存的是根节点。</span></span><br><span class=\"line\">\t\t\t\t\t   <span class=\"comment\">//vis用来判断是否用到这个点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpre[i] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tmaxx=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123; <span class=\"comment\">// find操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r = v;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pre[r] != r)&#123; <span class=\"comment\">// 寻到当前状态的根节点</span></span><br><span class=\"line\">\t\tr = pre[r];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = v,j;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i != r)&#123; <span class=\"comment\">// 回溯过程 将所有子节点的pre改为父节点。</span></span><br><span class=\"line\">\t\tj = pre[i];</span><br><span class=\"line\">\t\tpre[i] = r;</span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">int</span> v1,<span class=\"keyword\">int</span> v2)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> newX = find(v1),newY = find(v2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(newX == newY &amp;&amp; v1 != v2) <span class=\"comment\">// 使用并查集判断时候有环路。</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpre[newX] = newY; <span class=\"comment\">// 吧点加入集合</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">isconnect</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 判断是否有只有单个图。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = find(pre[maxx]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxx; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[i] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(find(pre[i]) != find(pre[maxx]))&#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tinit();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(x==<span class=\"number\">0</span>&amp;&amp;y==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(x == <span class=\"number\">-1</span> &amp;&amp; y == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    \t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        vis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        vis[y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        maxx = max(maxx,max(x,y));</span><br><span class=\"line\">        join(x,y);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y) &amp;&amp; x &amp;&amp; y)&#123;</span><br><span class=\"line\">    \t\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\tvis[y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\tmaxx = max(maxx,max(x,y));</span><br><span class=\"line\">    \t\tjoin(x,y);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tisconnect();</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">    \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： 并查集</em></p>\n<h2 id=\"并查集简述：\"><a href=\"#并查集简述：\" class=\"headerlink\" title=\"并查集简述：\"></a>并查集简述：</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>并查集(union-find sets)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>\n<h3 id=\"基本操作：\"><a href=\"#基本操作：\" class=\"headerlink\" title=\"基本操作：\"></a>基本操作：</h3><ol>\n<li><p>Make_Set(x) 把每一个元素<strong>初始化</strong>为一个集合：</p>\n<p>初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。</p>\n</li>\n<li><p>Find_Set(x) 查找一个元素所在的集合:</p>\n<p>查找一个元素所在的集合，其精髓是找到<strong>这个元素所在集合的祖先</strong>！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。</p>\n</li>\n<li><p>Union(x,y) 合并x,y所在的两个集合：</p>\n<p>合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。具体过程为，利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。</p>\n</li>\n<li><p>Find_Set(x)时 路径压缩：</p>\n<p>寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？</p>\n<p>答案是肯定的，这就是路径压缩，即当我们经过”递推”找到祖先节点后，<strong>“回溯”的时候顺便将它的子孙节点都直接指向祖先</strong>，这样以后再次Find_Set(x)时复杂度就变成O(1)了。</p>\n</li>\n<li><p>Union(x,y)时 按秩合并：</p>\n<p>即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。</p>\n</li>\n</ol>\n<h2 id=\"例题：\"><a href=\"#例题：\" class=\"headerlink\" title=\"例题：\"></a>例题：</h2><h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 </p>\n<p><img src=\"HDU_1272.png\" alt=\"HDU_1272\"></p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>6 8  5 3  5 2  6 4<br>5 6  0 0</p>\n<p>8 1  7 3  6 2  8 9  7 5<br>7 4  7 8  7 6  0 0</p>\n<p>3 8  6 8  6 4<br>5 3  5 6  5 2  0 0</p>\n<p>-1 -1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>Yes<br>Yes<br>No</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题是并查集的基本应用。只需要使用并查集判断是否有环路 且 是否只有单个集合。</p>\n<p>有坑。。。 输入 0 0 输出Yes</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">100005</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>,maxx=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> vis[MAX],pre[MAX]; <span class=\"comment\">// pre用来存index的父节点，路径压缩后存的是根节点。</span></span><br><span class=\"line\">\t\t\t\t\t   <span class=\"comment\">//vis用来判断是否用到这个点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;  <span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpre[i] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tmaxx=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123; <span class=\"comment\">// find操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r = v;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(pre[r] != r)&#123; <span class=\"comment\">// 寻到当前状态的根节点</span></span><br><span class=\"line\">\t\tr = pre[r];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = v,j;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i != r)&#123; <span class=\"comment\">// 回溯过程 将所有子节点的pre改为父节点。</span></span><br><span class=\"line\">\t\tj = pre[i];</span><br><span class=\"line\">\t\tpre[i] = r;</span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">int</span> v1,<span class=\"keyword\">int</span> v2)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> newX = find(v1),newY = find(v2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(newX == newY &amp;&amp; v1 != v2) <span class=\"comment\">// 使用并查集判断时候有环路。</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpre[newX] = newY; <span class=\"comment\">// 吧点加入集合</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">isconnect</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 判断是否有只有单个图。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = find(pre[maxx]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxx; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[i] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(find(pre[i]) != find(pre[maxx]))&#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tinit();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(x==<span class=\"number\">0</span>&amp;&amp;y==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(x == <span class=\"number\">-1</span> &amp;&amp; y == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    \t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        vis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        vis[y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        maxx = max(maxx,max(x,y));</span><br><span class=\"line\">        join(x,y);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;x,&amp;y) &amp;&amp; x &amp;&amp; y)&#123;</span><br><span class=\"line\">    \t\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\tvis[y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\tmaxx = max(maxx,max(x,y));</span><br><span class=\"line\">    \t\tjoin(x,y);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tisconnect();</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">    \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-1851 A Simple Game","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型： 博弈，SG函数*\n\n### 描述：\n\nAgrael likes play a simple game with his friend Animal during the classes. In this Game there are n piles of stones numbered from 1 to n, the 1st pile has M1 stones, the 2nd pile has M2 stones, ... and the n-th pile contain Mn stones. Agrael and Animal take turns to move and in each move each of the players can take at most L1 stones from the 1st pile or take at most L2 stones from the 2nd pile or ... or take Ln stones from the n-th pile. The player who takes the last stone wins.\n\nAfter Agrael and Animal have played the game for months, the teacher finally got angry and decided to punish them. But when he knows the rule of the game, he is so interested in this game that he asks Agrael to play the game with him and if Agrael wins, he won't be punished, can Agrael win the game if the teacher and Agrael both take the best move in their turn?\n\nThe teacher always moves first(-_-), and in each turn a player must takes at least 1 stones and they can't take stones from more than one piles.\n\n### INPUT：\n\nThe first line contains the number of test cases. Each test cases begin with the number n (n ≤ 10), represent there are n piles. Then there are n lines follows, the i-th line contains two numbers Mi and Li (20 ≥ Mi > 0, 20 ≥ Li > 0). \n\n### OUTPUT：\n\n\n\n\n\nYour program output one line per case, if Agrael can win the game print \"Yes\", else print \"No\". \n\n### Sample input：\n\n2\n1\n5 4\n2\n1 1\n2 2\n\n### sample output：\n\nYes\nNo\n\n### 题解：\n\n此题有两种办法一种是nim+bash，还有一种是通过SG函数来解决","source":"_posts/HDU-1851 A Simple Game.md","raw":"---\ntitle: HDU-1851 A Simple Game\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 博弈\n    - SG函数\ncategories: Algorithm\n---\n\n*类型： 博弈，SG函数*\n\n### 描述：\n\nAgrael likes play a simple game with his friend Animal during the classes. In this Game there are n piles of stones numbered from 1 to n, the 1st pile has M1 stones, the 2nd pile has M2 stones, ... and the n-th pile contain Mn stones. Agrael and Animal take turns to move and in each move each of the players can take at most L1 stones from the 1st pile or take at most L2 stones from the 2nd pile or ... or take Ln stones from the n-th pile. The player who takes the last stone wins.\n\nAfter Agrael and Animal have played the game for months, the teacher finally got angry and decided to punish them. But when he knows the rule of the game, he is so interested in this game that he asks Agrael to play the game with him and if Agrael wins, he won't be punished, can Agrael win the game if the teacher and Agrael both take the best move in their turn?\n\nThe teacher always moves first(-_-), and in each turn a player must takes at least 1 stones and they can't take stones from more than one piles.\n\n### INPUT：\n\nThe first line contains the number of test cases. Each test cases begin with the number n (n ≤ 10), represent there are n piles. Then there are n lines follows, the i-th line contains two numbers Mi and Li (20 ≥ Mi > 0, 20 ≥ Li > 0). \n\n### OUTPUT：\n\n\n\n\n\nYour program output one line per case, if Agrael can win the game print \"Yes\", else print \"No\". \n\n### Sample input：\n\n2\n1\n5 4\n2\n1 1\n2 2\n\n### sample output：\n\nYes\nNo\n\n### 题解：\n\n此题有两种办法一种是nim+bash，还有一种是通过SG函数来解决","slug":"HDU-1851 A Simple Game","published":1,"updated":"2018-07-03T06:29:56.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tux0009plxpne1iv234","content":"<p><em>类型： 博弈，SG函数</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>Agrael likes play a simple game with his friend Animal during the classes. In this Game there are n piles of stones numbered from 1 to n, the 1st pile has M1 stones, the 2nd pile has M2 stones, … and the n-th pile contain Mn stones. Agrael and Animal take turns to move and in each move each of the players can take at most L1 stones from the 1st pile or take at most L2 stones from the 2nd pile or … or take Ln stones from the n-th pile. The player who takes the last stone wins.</p>\n<p>After Agrael and Animal have played the game for months, the teacher finally got angry and decided to punish them. But when he knows the rule of the game, he is so interested in this game that he asks Agrael to play the game with him and if Agrael wins, he won’t be punished, can Agrael win the game if the teacher and Agrael both take the best move in their turn?</p>\n<p>The teacher always moves first(-_-), and in each turn a player must takes at least 1 stones and they can’t take stones from more than one piles.</p>\n<h3 id=\"INPUT：\"><a href=\"#INPUT：\" class=\"headerlink\" title=\"INPUT：\"></a>INPUT：</h3><p>The first line contains the number of test cases. Each test cases begin with the number n (n ≤ 10), represent there are n piles. Then there are n lines follows, the i-th line contains two numbers Mi and Li (20 ≥ Mi &gt; 0, 20 ≥ Li &gt; 0). </p>\n<h3 id=\"OUTPUT：\"><a href=\"#OUTPUT：\" class=\"headerlink\" title=\"OUTPUT：\"></a>OUTPUT：</h3><p>Your program output one line per case, if Agrael can win the game print “Yes”, else print “No”. </p>\n<h3 id=\"Sample-input：\"><a href=\"#Sample-input：\" class=\"headerlink\" title=\"Sample input：\"></a>Sample input：</h3><p>2<br>1<br>5 4<br>2<br>1 1<br>2 2</p>\n<h3 id=\"sample-output：\"><a href=\"#sample-output：\" class=\"headerlink\" title=\"sample output：\"></a>sample output：</h3><p>Yes<br>No</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题有两种办法一种是nim+bash，还有一种是通过SG函数来解决</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： 博弈，SG函数</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>Agrael likes play a simple game with his friend Animal during the classes. In this Game there are n piles of stones numbered from 1 to n, the 1st pile has M1 stones, the 2nd pile has M2 stones, … and the n-th pile contain Mn stones. Agrael and Animal take turns to move and in each move each of the players can take at most L1 stones from the 1st pile or take at most L2 stones from the 2nd pile or … or take Ln stones from the n-th pile. The player who takes the last stone wins.</p>\n<p>After Agrael and Animal have played the game for months, the teacher finally got angry and decided to punish them. But when he knows the rule of the game, he is so interested in this game that he asks Agrael to play the game with him and if Agrael wins, he won’t be punished, can Agrael win the game if the teacher and Agrael both take the best move in their turn?</p>\n<p>The teacher always moves first(-_-), and in each turn a player must takes at least 1 stones and they can’t take stones from more than one piles.</p>\n<h3 id=\"INPUT：\"><a href=\"#INPUT：\" class=\"headerlink\" title=\"INPUT：\"></a>INPUT：</h3><p>The first line contains the number of test cases. Each test cases begin with the number n (n ≤ 10), represent there are n piles. Then there are n lines follows, the i-th line contains two numbers Mi and Li (20 ≥ Mi &gt; 0, 20 ≥ Li &gt; 0). </p>\n<h3 id=\"OUTPUT：\"><a href=\"#OUTPUT：\" class=\"headerlink\" title=\"OUTPUT：\"></a>OUTPUT：</h3><p>Your program output one line per case, if Agrael can win the game print “Yes”, else print “No”. </p>\n<h3 id=\"Sample-input：\"><a href=\"#Sample-input：\" class=\"headerlink\" title=\"Sample input：\"></a>Sample input：</h3><p>2<br>1<br>5 4<br>2<br>1 1<br>2 2</p>\n<h3 id=\"sample-output：\"><a href=\"#sample-output：\" class=\"headerlink\" title=\"sample output：\"></a>sample output：</h3><p>Yes<br>No</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题有两种办法一种是nim+bash，还有一种是通过SG函数来解决</p>\n"},{"title":"HDU-2066 一个人的旅行","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型： 最短路，多集合到多集合*\n\n### Problem Description\n\n虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。\n\n### Input\n\n输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；\n 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=<(a,b)<=1000;a,b 之间可能有多条路)\n 接着的第T+1行有S个数，表示和草儿家相连的城市；\n 接着的第T+2行有D个数，表示草儿想去地方。\n\n### Output\n\n输出草儿能去某个喜欢的城市的最短时间。\n\n### Sample Input\n\n6 2 3\n1 3 5\n1 4 7\n2 8 12\n3 8 4\n4 9 12\n9 10 2\n1 2\n8 9 10\n\n### Sample Output\n\n9\n\n### 题解：\n\n对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <cstdio>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n\tint vertex, weight;\n};\n\nclass Graph {\nprivate:\n\tint n;\n\tvector<Edge> * edges;\n    bool * visited;\npublic:\n\tint * dist;\n\tGraph (int input_n) {\n\t\tn = input_n;\n\t\tedges = new vector<Edge>[n];\n\t\tdist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n);\n\t\tmemset(dist, 0x3f, n * sizeof(int));\n\t}\n\t~Graph() {\n\t\tdelete[] dist;\n\t\tdelete[] edges;\n        delete[] visited;\n\t}\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n            for(Edge &j: edges[min_vertex]){\n                if( min_dist + j.weight < dist[j.vertex]){\n                    dist[j.vertex] = min_dist + j.weight;\n                }\n            }\n\n        }\n    }\n};\n\nint main() {\n\n\tint T,S,D,maxn;\n\twhile(scanf(\"%d%d%d\",&T,&S,&D)!=EOF){\n        Graph g(1010);\n        maxn = 0;\n        for (int i = 0; i < T; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            maxn = max(max(a,b),maxn);\n            g.insert(a, b, c);\n        }\n        maxn++;\n        for (int i = 0; i < S; i++) {\n            int tmp;\n            cin >> tmp;\n            g.insert(0, tmp, 0);\n        }\n        for (int i = 0; i < D; i++) {\n            int tmp;\n            cin >> tmp;\n            g.insert(maxn, tmp, 0);\n        }\n        g.dijkstra(0);\n        cout << g.dist[maxn] << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/HDU-2066 一个人的旅行.md","raw":"---\ntitle: HDU-2066 一个人的旅行\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 图论\n    - dijkstra\ncategories: Algorithm\n---\n\n*类型： 最短路，多集合到多集合*\n\n### Problem Description\n\n虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。\n\n### Input\n\n输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；\n 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=<(a,b)<=1000;a,b 之间可能有多条路)\n 接着的第T+1行有S个数，表示和草儿家相连的城市；\n 接着的第T+2行有D个数，表示草儿想去地方。\n\n### Output\n\n输出草儿能去某个喜欢的城市的最短时间。\n\n### Sample Input\n\n6 2 3\n1 3 5\n1 4 7\n2 8 12\n3 8 4\n4 9 12\n9 10 2\n1 2\n8 9 10\n\n### Sample Output\n\n9\n\n### 题解：\n\n对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <cstdio>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n\tint vertex, weight;\n};\n\nclass Graph {\nprivate:\n\tint n;\n\tvector<Edge> * edges;\n    bool * visited;\npublic:\n\tint * dist;\n\tGraph (int input_n) {\n\t\tn = input_n;\n\t\tedges = new vector<Edge>[n];\n\t\tdist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n);\n\t\tmemset(dist, 0x3f, n * sizeof(int));\n\t}\n\t~Graph() {\n\t\tdelete[] dist;\n\t\tdelete[] edges;\n        delete[] visited;\n\t}\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n            for(Edge &j: edges[min_vertex]){\n                if( min_dist + j.weight < dist[j.vertex]){\n                    dist[j.vertex] = min_dist + j.weight;\n                }\n            }\n\n        }\n    }\n};\n\nint main() {\n\n\tint T,S,D,maxn;\n\twhile(scanf(\"%d%d%d\",&T,&S,&D)!=EOF){\n        Graph g(1010);\n        maxn = 0;\n        for (int i = 0; i < T; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            maxn = max(max(a,b),maxn);\n            g.insert(a, b, c);\n        }\n        maxn++;\n        for (int i = 0; i < S; i++) {\n            int tmp;\n            cin >> tmp;\n            g.insert(0, tmp, 0);\n        }\n        for (int i = 0; i < D; i++) {\n            int tmp;\n            cin >> tmp;\n            g.insert(maxn, tmp, 0);\n        }\n        g.dijkstra(0);\n        cout << g.dist[maxn] << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n","slug":"HDU-2066 一个人的旅行","published":1,"updated":"2018-07-03T06:29:55.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tuy000aplxp9d8u43u2","content":"<p><em>类型： 最短路，多集合到多集合</em></p>\n<h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br> 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br> 接着的第T+1行有S个数，表示和草儿家相连的城市；<br> 接着的第T+2行有D个数，表示草儿想去地方。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>输出草儿能去某个喜欢的城市的最短时间。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>6 2 3<br>1 3 5<br>1 4 7<br>2 8 12<br>3 8 4<br>4 9 12<br>9 10 2<br>1 2<br>8 9 10</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>9</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">\tGraph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">\t\tn = input_n;</span><br><span class=\"line\">\t\tedges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">\t\tdist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Graph() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Edge &amp;j: edges[min_vertex])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + j.weight &lt; dist[j.vertex])&#123;</span><br><span class=\"line\">                    dist[j.vertex] = min_dist + j.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> T,S,D,maxn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class=\"line\">        <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">1010</span>)</span></span>;</span><br><span class=\"line\">        maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">            maxn = max(max(a,b),maxn);</span><br><span class=\"line\">            g.insert(a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxn++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">            g.insert(<span class=\"number\">0</span>, tmp, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; D; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">            g.insert(maxn, tmp, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        g.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; g.dist[maxn] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： 最短路，多集合到多集合</em></p>\n<h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br> 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br> 接着的第T+1行有S个数，表示和草儿家相连的城市；<br> 接着的第T+2行有D个数，表示草儿想去地方。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>输出草儿能去某个喜欢的城市的最短时间。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>6 2 3<br>1 3 5<br>1 4 7<br>2 8 12<br>3 8 4<br>4 9 12<br>9 10 2<br>1 2<br>8 9 10</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>9</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">\tGraph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">\t\tn = input_n;</span><br><span class=\"line\">\t\tedges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">\t\tdist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Graph() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Edge &amp;j: edges[min_vertex])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + j.weight &lt; dist[j.vertex])&#123;</span><br><span class=\"line\">                    dist[j.vertex] = min_dist + j.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> T,S,D,maxn;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class=\"line\">        <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">1010</span>)</span></span>;</span><br><span class=\"line\">        maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">            maxn = max(max(a,b),maxn);</span><br><span class=\"line\">            g.insert(a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxn++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">            g.insert(<span class=\"number\">0</span>, tmp, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; D; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">            g.insert(maxn, tmp, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        g.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; g.dist[maxn] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-2196 Computer","date":"2016-12-28T08:31:57.000Z","_content":"\n*类型： 树形DP 、树的最长路*\n\n### Description\n\nA school bought the first computer some time ago(so this computer's id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. \n\n​\t\t\t\t\t\t\t ![hdu_2196](C:\\Users\\AndyFrancis\\Desktop\\hdu_2196.jpg)\n\nHint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. \n\n### Input\n\nInput file contains multiple test cases.In each case there is natural number N (N<=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.\n\n### Output\n\nFor each case output N lines. i-th line must contain number Si for i-th computer (1<=i<=N).\n\n### Sample Input\n\n5\n1 1\n2 1\n3 1\n1 1\n\n### Sample Output\n\n3\n2\n3\n4\n4\n\n### 题解：\n\n此题的意思为：树中一共n个节点，输出每个节点到其中任意一个节点的最远花费的值。\n\n有这么一个定理：\n\n> 首先假设树的最长路的两个叶子节点为v1,v2，那么现有结论，从任意一点u出发走到的最远的点一定是（v1,v2）中的一点，然后再从v1或者v2出发走到的最远点一定是v2或者v1。\n\n因此，经过三次搜索就能找到任意一点最长路径或者说是话费。\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <algorithm>\ninclude <vector>\ninclude <queue>\ninclude <cmath>\ninclude <cstring>\nusing namespace std;\n\nconst int MAX = 10010;\n\nstruct Tree{\n    int v;\n    int dis;\n};\nvector <struct Tree > tree[MAX];\nint ans[MAX];\nint max_len,root;\n\ninit(){\n    memset(ans,0,sizeof(ans));\n    memset(tree,0,sizeof(tree));\n}\n\nvoid trees(int u,int v,int len){ // v为当前节点，u为父节点\n    if(max_len < len ){\n        max_len = len;\n        root = v;\n    }\n\n    for(int i = 0;i < tree[v].size();i++){\n        struct Tree new_v = tree[v][i];\n        if(new_v.v == u)\n            continue;\n        trees(v,new_v.v,len + new_v.dis);\n        ans[new_v.v] = max (ans[new_v.v],new_v.dis + len);\n    }\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n) != EOF){\n        init();\n        int max_w = 0, w = 1;\n        for(int i = 2;i <= n; i++){\n            int tmp,tmp_d; cin >> tmp >> tmp_d;\n            tree[tmp].push_back(Tree{i,tmp_d});\n            tree[i].push_back(Tree{tmp,tmp_d});\n        }\n\n        max_len = 0;\n        trees(-1,1,0);\n        trees(-1,root,0);\n        trees(-1,root,0);\n\n        for(int i = 1;i <= n; i++){\n            cout << ans[i] <<endl;\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/HDU-2196 Computer.md","raw":"---\ntitle: HDU-2196 Computer\ndate: 2016-12-28 16:31:57\ntags: 树形DP\ncategories: Algorithm\n---\n\n*类型： 树形DP 、树的最长路*\n\n### Description\n\nA school bought the first computer some time ago(so this computer's id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. \n\n​\t\t\t\t\t\t\t ![hdu_2196](C:\\Users\\AndyFrancis\\Desktop\\hdu_2196.jpg)\n\nHint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. \n\n### Input\n\nInput file contains multiple test cases.In each case there is natural number N (N<=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.\n\n### Output\n\nFor each case output N lines. i-th line must contain number Si for i-th computer (1<=i<=N).\n\n### Sample Input\n\n5\n1 1\n2 1\n3 1\n1 1\n\n### Sample Output\n\n3\n2\n3\n4\n4\n\n### 题解：\n\n此题的意思为：树中一共n个节点，输出每个节点到其中任意一个节点的最远花费的值。\n\n有这么一个定理：\n\n> 首先假设树的最长路的两个叶子节点为v1,v2，那么现有结论，从任意一点u出发走到的最远的点一定是（v1,v2）中的一点，然后再从v1或者v2出发走到的最远点一定是v2或者v1。\n\n因此，经过三次搜索就能找到任意一点最长路径或者说是话费。\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <algorithm>\ninclude <vector>\ninclude <queue>\ninclude <cmath>\ninclude <cstring>\nusing namespace std;\n\nconst int MAX = 10010;\n\nstruct Tree{\n    int v;\n    int dis;\n};\nvector <struct Tree > tree[MAX];\nint ans[MAX];\nint max_len,root;\n\ninit(){\n    memset(ans,0,sizeof(ans));\n    memset(tree,0,sizeof(tree));\n}\n\nvoid trees(int u,int v,int len){ // v为当前节点，u为父节点\n    if(max_len < len ){\n        max_len = len;\n        root = v;\n    }\n\n    for(int i = 0;i < tree[v].size();i++){\n        struct Tree new_v = tree[v][i];\n        if(new_v.v == u)\n            continue;\n        trees(v,new_v.v,len + new_v.dis);\n        ans[new_v.v] = max (ans[new_v.v],new_v.dis + len);\n    }\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n) != EOF){\n        init();\n        int max_w = 0, w = 1;\n        for(int i = 2;i <= n; i++){\n            int tmp,tmp_d; cin >> tmp >> tmp_d;\n            tree[tmp].push_back(Tree{i,tmp_d});\n            tree[i].push_back(Tree{tmp,tmp_d});\n        }\n\n        max_len = 0;\n        trees(-1,1,0);\n        trees(-1,root,0);\n        trees(-1,root,0);\n\n        for(int i = 1;i <= n; i++){\n            cout << ans[i] <<endl;\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"HDU-2196 Computer","published":1,"updated":"2018-07-03T06:29:54.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tv0000eplxp4ovsolbx","content":"<p><em>类型： 树形DP 、树的最长路</em></p>\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. </p>\n<p>​                             <img src=\"C:\\Users\\AndyFrancis\\Desktop\\hdu_2196.jpg\" alt=\"hdu_2196\"></p>\n<p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3<br>2<br>3<br>4<br>4</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题的意思为：树中一共n个节点，输出每个节点到其中任意一个节点的最远花费的值。</p>\n<p>有这么一个定理：</p>\n<blockquote>\n<p>首先假设树的最长路的两个叶子节点为v1,v2，那么现有结论，从任意一点u出发走到的最远的点一定是（v1,v2）中的一点，然后再从v1或者v2出发走到的最远点一定是v2或者v1。</p>\n</blockquote>\n<p>因此，经过三次搜索就能找到任意一点最长路径或者说是话费。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;algorithm&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;cmath&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt;struct Tree &gt; tree[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> max_len,root;</span><br><span class=\"line\"></span><br><span class=\"line\">init()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tree,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(tree));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trees</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> len)</span></span>&#123; <span class=\"comment\">// v为当前节点，u为父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(max_len &lt; len )&#123;</span><br><span class=\"line\">        max_len = len;</span><br><span class=\"line\">        root = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; tree[v].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span> <span class=\"title\">new_v</span> = <span class=\"title\">tree</span>[<span class=\"title\">v</span>][<span class=\"title\">i</span>];</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(new_v.v == u)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        trees(v,new_v.v,len + new_v.dis);</span><br><span class=\"line\">        ans[new_v.v] = max (ans[new_v.v],new_v.dis + len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n) != EOF)&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_w = <span class=\"number\">0</span>, w = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp,tmp_d; <span class=\"built_in\">cin</span> &gt;&gt; tmp &gt;&gt; tmp_d;</span><br><span class=\"line\">            tree[tmp].push_back(Tree&#123;i,tmp_d&#125;);</span><br><span class=\"line\">            tree[i].push_back(Tree&#123;tmp,tmp_d&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,root,<span class=\"number\">0</span>);</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,root,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ans[i] &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： 树形DP 、树的最长路</em></p>\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. </p>\n<p>​                             <img src=\"C:\\Users\\AndyFrancis\\Desktop\\hdu_2196.jpg\" alt=\"hdu_2196\"></p>\n<p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3<br>2<br>3<br>4<br>4</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题的意思为：树中一共n个节点，输出每个节点到其中任意一个节点的最远花费的值。</p>\n<p>有这么一个定理：</p>\n<blockquote>\n<p>首先假设树的最长路的两个叶子节点为v1,v2，那么现有结论，从任意一点u出发走到的最远的点一定是（v1,v2）中的一点，然后再从v1或者v2出发走到的最远点一定是v2或者v1。</p>\n</blockquote>\n<p>因此，经过三次搜索就能找到任意一点最长路径或者说是话费。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;algorithm&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;cmath&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt;struct Tree &gt; tree[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> max_len,root;</span><br><span class=\"line\"></span><br><span class=\"line\">init()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tree,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(tree));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trees</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> len)</span></span>&#123; <span class=\"comment\">// v为当前节点，u为父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(max_len &lt; len )&#123;</span><br><span class=\"line\">        max_len = len;</span><br><span class=\"line\">        root = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; tree[v].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span> <span class=\"title\">new_v</span> = <span class=\"title\">tree</span>[<span class=\"title\">v</span>][<span class=\"title\">i</span>];</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(new_v.v == u)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        trees(v,new_v.v,len + new_v.dis);</span><br><span class=\"line\">        ans[new_v.v] = max (ans[new_v.v],new_v.dis + len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n) != EOF)&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_w = <span class=\"number\">0</span>, w = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp,tmp_d; <span class=\"built_in\">cin</span> &gt;&gt; tmp &gt;&gt; tmp_d;</span><br><span class=\"line\">            tree[tmp].push_back(Tree&#123;i,tmp_d&#125;);</span><br><span class=\"line\">            tree[i].push_back(Tree&#123;tmp,tmp_d&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,root,<span class=\"number\">0</span>);</span><br><span class=\"line\">        trees(<span class=\"number\">-1</span>,root,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ans[i] &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-2444 The Accomodation of Students","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型： 二分图的判断和最大匹配*\n\n### Problem Description：\n\nThere are a group of students. Some of them may know each other, while others don't. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other.\n\nNow you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don't know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room.\n\nCalculate the maximum number of pairs that can be arranged into these double rooms.\n\n### Input：\n\nFor each data set:\nThe first line gives two integers, n and m(1<n<=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs.\n\nProceed to the end of file.\n\n### Output：\n\nIf these students cannot be divided into two groups, print \"No\". Otherwise, print the maximum number of pairs that can be arranged in those rooms.\n\n### Sample Input：\n\n4 4\n1 2\n1 3\n1 4\n2 3\n6 5\n1 2\n1 3\n1 4\n2 5\n3 6\n\n### Sample Output：\n\nNo\n3\n\n### 题解：\n\n这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，\n建边是双向的所以要除以2。\n先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白\n色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻\n点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集\n合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。\n\n其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为：\n\n1. 定义一个空集U，放入起始点。\n2. 搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。\n3. 循环步骤2，如果不能继续则结束。\n\n### Code：\n\n```c++\ninclude\"stdio.h\"\ninclude\"string.h\"\ninclude\"iostream\"\ninclude\"queue\"\nusing namespace std;\ndefine N 205\nint mark[N],link[N],map[N][N],color[N],n;\nint find(int a)       //匈牙利算法\n{\n\tint i;\n\tfor(i=1;i<=n;i++){\n\t\tif(!mark[i]&&map[a][i]){\n\t\t\tmark[i]=1;\n\t\t\tif(!link[i]||find(link[i])){ //若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对\n\t\t\t\tlink[i]=a; //若可以则把i配给a\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint judge()        //判断是否是二分图\n{\n\tint i,cur;\n\tqueueq;       //队列声明\n\tq.push(1);       //把1加入队列\n\twhile(!q.empty()){\n\t\tcur=q.front();      //取队首元素\n\t\tq.pop();             //删除队首元素\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(map[cur][i]){      //1和2、3认识则把2、3均标记为2；  \n\t\t\t\tif(color[i]==-1){\n\t\t\t\t\tcolor[i]=1-color[cur];\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t\telse if(color[i]==color[cur])      //接下来到2出对时，color[3]=color\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint i,j,m,ans;\n\twhile(scanf(\"%d%d\",&n,&m)!=-1){\n\t\tmemset(link,0,sizeof(link));\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(color,-1,sizeof(color));\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d\",&i,&j);\n\t\t\tmap[i][j]=map[j][i]=1;\n\t\t}\n\t\tif(judge()==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tmemset(mark,0,sizeof(mark));\n\t\t\tans+=find(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans/2);\n\t}\n\treturn 0;\n}\n```\n\n","source":"_posts/HDU-2444 The Accomodation of Students.md","raw":"---\ntitle: HDU-2444 The Accomodation of Students\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 图论\n    - 二分图\n    - 最大匹配\ncategories: Algorithm\n---\n\n*类型： 二分图的判断和最大匹配*\n\n### Problem Description：\n\nThere are a group of students. Some of them may know each other, while others don't. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other.\n\nNow you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don't know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room.\n\nCalculate the maximum number of pairs that can be arranged into these double rooms.\n\n### Input：\n\nFor each data set:\nThe first line gives two integers, n and m(1<n<=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs.\n\nProceed to the end of file.\n\n### Output：\n\nIf these students cannot be divided into two groups, print \"No\". Otherwise, print the maximum number of pairs that can be arranged in those rooms.\n\n### Sample Input：\n\n4 4\n1 2\n1 3\n1 4\n2 3\n6 5\n1 2\n1 3\n1 4\n2 5\n3 6\n\n### Sample Output：\n\nNo\n3\n\n### 题解：\n\n这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，\n建边是双向的所以要除以2。\n先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白\n色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻\n点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集\n合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。\n\n其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为：\n\n1. 定义一个空集U，放入起始点。\n2. 搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。\n3. 循环步骤2，如果不能继续则结束。\n\n### Code：\n\n```c++\ninclude\"stdio.h\"\ninclude\"string.h\"\ninclude\"iostream\"\ninclude\"queue\"\nusing namespace std;\ndefine N 205\nint mark[N],link[N],map[N][N],color[N],n;\nint find(int a)       //匈牙利算法\n{\n\tint i;\n\tfor(i=1;i<=n;i++){\n\t\tif(!mark[i]&&map[a][i]){\n\t\t\tmark[i]=1;\n\t\t\tif(!link[i]||find(link[i])){ //若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对\n\t\t\t\tlink[i]=a; //若可以则把i配给a\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint judge()        //判断是否是二分图\n{\n\tint i,cur;\n\tqueueq;       //队列声明\n\tq.push(1);       //把1加入队列\n\twhile(!q.empty()){\n\t\tcur=q.front();      //取队首元素\n\t\tq.pop();             //删除队首元素\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(map[cur][i]){      //1和2、3认识则把2、3均标记为2；  \n\t\t\t\tif(color[i]==-1){\n\t\t\t\t\tcolor[i]=1-color[cur];\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t\telse if(color[i]==color[cur])      //接下来到2出对时，color[3]=color\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint i,j,m,ans;\n\twhile(scanf(\"%d%d\",&n,&m)!=-1){\n\t\tmemset(link,0,sizeof(link));\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(color,-1,sizeof(color));\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d\",&i,&j);\n\t\t\tmap[i][j]=map[j][i]=1;\n\t\t}\n\t\tif(judge()==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tmemset(mark,0,sizeof(mark));\n\t\t\tans+=find(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans/2);\n\t}\n\treturn 0;\n}\n```\n\n","slug":"HDU-2444 The Accomodation of Students","published":1,"updated":"2018-07-03T06:29:53.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tv3000hplxpp08muwe0","content":"<p><em>类型： 二分图的判断和最大匹配</em></p>\n<h3 id=\"Problem-Description：\"><a href=\"#Problem-Description：\" class=\"headerlink\" title=\"Problem Description：\"></a>Problem Description：</h3><p>There are a group of students. Some of them may know each other, while others don’t. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other.</p>\n<p>Now you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don’t know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room.</p>\n<p>Calculate the maximum number of pairs that can be arranged into these double rooms.</p>\n<h3 id=\"Input：\"><a href=\"#Input：\" class=\"headerlink\" title=\"Input：\"></a>Input：</h3><p>For each data set:<br>The first line gives two integers, n and m(1&lt;n&lt;=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs.</p>\n<p>Proceed to the end of file.</p>\n<h3 id=\"Output：\"><a href=\"#Output：\" class=\"headerlink\" title=\"Output：\"></a>Output：</h3><p>If these students cannot be divided into two groups, print “No”. Otherwise, print the maximum number of pairs that can be arranged in those rooms.</p>\n<h3 id=\"Sample-Input：\"><a href=\"#Sample-Input：\" class=\"headerlink\" title=\"Sample Input：\"></a>Sample Input：</h3><p>4 4<br>1 2<br>1 3<br>1 4<br>2 3<br>6 5<br>1 2<br>1 3<br>1 4<br>2 5<br>3 6</p>\n<h3 id=\"Sample-Output：\"><a href=\"#Sample-Output：\" class=\"headerlink\" title=\"Sample Output：\"></a>Sample Output：</h3><p>No<br>3</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，<br>建边是双向的所以要除以2。<br>先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白<br>色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻<br>点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集<br>合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。</p>\n<p>其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为：</p>\n<ol>\n<li>定义一个空集U，放入起始点。</li>\n<li>搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。</li>\n<li>循环步骤2，如果不能继续则结束。</li>\n</ol>\n<h3 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include<span class=\"string\">\"stdio.h\"</span></span><br><span class=\"line\">include<span class=\"string\">\"string.h\"</span></span><br><span class=\"line\">include<span class=\"string\">\"iostream\"</span></span><br><span class=\"line\">include<span class=\"string\">\"queue\"</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\">define N <span class=\"number\">205</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mark[N],link[N],<span class=\"built_in\">map</span>[N][N],color[N],n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span>       <span class=\"comment\">//匈牙利算法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!mark[i]&amp;&amp;<span class=\"built_in\">map</span>[a][i])&#123;</span><br><span class=\"line\">\t\t\tmark[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!link[i]||find(link[i]))&#123; <span class=\"comment\">//若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对</span></span><br><span class=\"line\">\t\t\t\tlink[i]=a; <span class=\"comment\">//若可以则把i配给a</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">judge</span><span class=\"params\">()</span>        <span class=\"comment\">//判断是否是二分图</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,cur;</span><br><span class=\"line\">\tqueueq;       <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">\tq.push(<span class=\"number\">1</span>);       <span class=\"comment\">//把1加入队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">\t\tcur=q.front();      <span class=\"comment\">//取队首元素</span></span><br><span class=\"line\">\t\tq.pop();             <span class=\"comment\">//删除队首元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>[cur][i])&#123;      <span class=\"comment\">//1和2、3认识则把2、3均标记为2；  </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(color[i]==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcolor[i]=<span class=\"number\">1</span>-color[cur];</span><br><span class=\"line\">\t\t\t\t\tq.push(i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(color[i]==color[cur])      <span class=\"comment\">//接下来到2出对时，color[3]=color</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,j,m,ans;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m)!=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(link,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(link));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(<span class=\"built_in\">map</span>,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">map</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(color,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(color));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;i,&amp;j);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">map</span>[i][j]=<span class=\"built_in\">map</span>[j][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(judge()==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(mark,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(mark));</span><br><span class=\"line\">\t\t\tans+=find(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： 二分图的判断和最大匹配</em></p>\n<h3 id=\"Problem-Description：\"><a href=\"#Problem-Description：\" class=\"headerlink\" title=\"Problem Description：\"></a>Problem Description：</h3><p>There are a group of students. Some of them may know each other, while others don’t. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other.</p>\n<p>Now you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don’t know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room.</p>\n<p>Calculate the maximum number of pairs that can be arranged into these double rooms.</p>\n<h3 id=\"Input：\"><a href=\"#Input：\" class=\"headerlink\" title=\"Input：\"></a>Input：</h3><p>For each data set:<br>The first line gives two integers, n and m(1&lt;n&lt;=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs.</p>\n<p>Proceed to the end of file.</p>\n<h3 id=\"Output：\"><a href=\"#Output：\" class=\"headerlink\" title=\"Output：\"></a>Output：</h3><p>If these students cannot be divided into two groups, print “No”. Otherwise, print the maximum number of pairs that can be arranged in those rooms.</p>\n<h3 id=\"Sample-Input：\"><a href=\"#Sample-Input：\" class=\"headerlink\" title=\"Sample Input：\"></a>Sample Input：</h3><p>4 4<br>1 2<br>1 3<br>1 4<br>2 3<br>6 5<br>1 2<br>1 3<br>1 4<br>2 5<br>3 6</p>\n<h3 id=\"Sample-Output：\"><a href=\"#Sample-Output：\" class=\"headerlink\" title=\"Sample Output：\"></a>Sample Output：</h3><p>No<br>3</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，<br>建边是双向的所以要除以2。<br>先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白<br>色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻<br>点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集<br>合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。</p>\n<p>其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为：</p>\n<ol>\n<li>定义一个空集U，放入起始点。</li>\n<li>搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。</li>\n<li>循环步骤2，如果不能继续则结束。</li>\n</ol>\n<h3 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include<span class=\"string\">\"stdio.h\"</span></span><br><span class=\"line\">include<span class=\"string\">\"string.h\"</span></span><br><span class=\"line\">include<span class=\"string\">\"iostream\"</span></span><br><span class=\"line\">include<span class=\"string\">\"queue\"</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\">define N <span class=\"number\">205</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mark[N],link[N],<span class=\"built_in\">map</span>[N][N],color[N],n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span>       <span class=\"comment\">//匈牙利算法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!mark[i]&amp;&amp;<span class=\"built_in\">map</span>[a][i])&#123;</span><br><span class=\"line\">\t\t\tmark[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!link[i]||find(link[i]))&#123; <span class=\"comment\">//若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对</span></span><br><span class=\"line\">\t\t\t\tlink[i]=a; <span class=\"comment\">//若可以则把i配给a</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">judge</span><span class=\"params\">()</span>        <span class=\"comment\">//判断是否是二分图</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,cur;</span><br><span class=\"line\">\tqueueq;       <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">\tq.push(<span class=\"number\">1</span>);       <span class=\"comment\">//把1加入队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">\t\tcur=q.front();      <span class=\"comment\">//取队首元素</span></span><br><span class=\"line\">\t\tq.pop();             <span class=\"comment\">//删除队首元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>[cur][i])&#123;      <span class=\"comment\">//1和2、3认识则把2、3均标记为2；  </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(color[i]==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcolor[i]=<span class=\"number\">1</span>-color[cur];</span><br><span class=\"line\">\t\t\t\t\tq.push(i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(color[i]==color[cur])      <span class=\"comment\">//接下来到2出对时，color[3]=color</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,j,m,ans;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m)!=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(link,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(link));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(<span class=\"built_in\">map</span>,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">map</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(color,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(color));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;i,&amp;j);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">map</span>[i][j]=<span class=\"built_in\">map</span>[j][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(judge()==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(mark,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(mark));</span><br><span class=\"line\">\t\t\tans+=find(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-2544  最短路","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型： dijkstra*\n\n### Problem Description\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n### Input\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。\n\n输入保证至少存在1条商店到赛场的路线。\n\n### Output\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n### Sample Input\n\n2 1\n\n1 2 3\n\n3 3\n\n1 2 5\n\n2 3 5\n\n3 1 2\n\n0 0\n\n### Sample Output\n\n3\n\n2\n\n### 题解：\n\n此题解包括dijkstra的讲解。\n\n**dijistra的简述：**将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。\n\n**题目简述：** 简单的最短路。\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n\tint vertex, weight;\n};\n\nclass Graph {\nprivate:\n\tint n;\n\tvector<Edge> * edges;\n    bool * visited;\npublic:\n\tint * dist;\n\tGraph (int input_n) {\n\t\tn = input_n;\n\t\tedges = new vector<Edge>[n];\n\t\tdist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n);\n\t\tmemset(dist, 0x3f, n * sizeof(int));\n\t}\n\t~Graph() {\n\t\tdelete[] dist;\n\t\tdelete[] edges;\n        delete[] visited;\n\t}\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n            for(Edge &j: edges[min_vertex]){\n                if( min_dist + j.weight < dist[j.vertex]){\n                    dist[j.vertex] = min_dist + j.weight;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n\tint n, m;\n\twhile ((cin >> n >> m) && n && m){\n\tGraph g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tg.insert(a-1, b-1, c);\n\t}\n\tg.dijkstra(0);\n\n\t\tcout << g.dist[n-1] << endl;\n    }\n\treturn 0;\n}\n```\n\n\n\n\n\n","source":"_posts/HDU-2544 最短路.md","raw":"---\ntitle: HDU-2544  最短路\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 图论\n    - dijkstra\ncategories: Algorithm\n---\n\n*类型： dijkstra*\n\n### Problem Description\n\n在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？\n\n### Input\n\n输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。\n\n输入保证至少存在1条商店到赛场的路线。\n\n### Output\n\n对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间\n\n### Sample Input\n\n2 1\n\n1 2 3\n\n3 3\n\n1 2 5\n\n2 3 5\n\n3 1 2\n\n0 0\n\n### Sample Output\n\n3\n\n2\n\n### 题解：\n\n此题解包括dijkstra的讲解。\n\n**dijistra的简述：**将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。\n\n**题目简述：** 简单的最短路。\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n\tint vertex, weight;\n};\n\nclass Graph {\nprivate:\n\tint n;\n\tvector<Edge> * edges;\n    bool * visited;\npublic:\n\tint * dist;\n\tGraph (int input_n) {\n\t\tn = input_n;\n\t\tedges = new vector<Edge>[n];\n\t\tdist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n);\n\t\tmemset(dist, 0x3f, n * sizeof(int));\n\t}\n\t~Graph() {\n\t\tdelete[] dist;\n\t\tdelete[] edges;\n        delete[] visited;\n\t}\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n            for(Edge &j: edges[min_vertex]){\n                if( min_dist + j.weight < dist[j.vertex]){\n                    dist[j.vertex] = min_dist + j.weight;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n\tint n, m;\n\twhile ((cin >> n >> m) && n && m){\n\tGraph g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tg.insert(a-1, b-1, c);\n\t}\n\tg.dijkstra(0);\n\n\t\tcout << g.dist[n-1] << endl;\n    }\n\treturn 0;\n}\n```\n\n\n\n\n\n","slug":"HDU-2544 最短路","published":1,"updated":"2018-07-03T06:29:53.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tv7000lplxpedrwthzt","content":"<p><em>类型： dijkstra</em></p>\n<h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。</p>\n<p>输入保证至少存在1条商店到赛场的路线。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2 1</p>\n<p>1 2 3</p>\n<p>3 3</p>\n<p>1 2 5</p>\n<p>2 3 5</p>\n<p>3 1 2</p>\n<p>0 0</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3</p>\n<p>2</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题解包括dijkstra的讲解。</p>\n<p><strong>dijistra的简述：</strong>将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。</p>\n<p><strong>题目简述：</strong> 简单的最短路。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">\tGraph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">\t\tn = input_n;</span><br><span class=\"line\">\t\tedges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">\t\tdist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Graph() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Edge &amp;j: edges[min_vertex])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + j.weight &lt; dist[j.vertex])&#123;</span><br><span class=\"line\">                    dist[j.vertex] = min_dist + j.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m) &amp;&amp; n &amp;&amp; m)&#123;</span><br><span class=\"line\">\t<span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">\t\tg.insert(a<span class=\"number\">-1</span>, b<span class=\"number\">-1</span>, c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tg.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; g.dist[n<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型： dijkstra</em></p>\n<h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。</p>\n<p>输入保证至少存在1条商店到赛场的路线。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2 1</p>\n<p>1 2 3</p>\n<p>3 3</p>\n<p>1 2 5</p>\n<p>2 3 5</p>\n<p>3 1 2</p>\n<p>0 0</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3</p>\n<p>2</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>此题解包括dijkstra的讲解。</p>\n<p><strong>dijistra的简述：</strong>将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。</p>\n<p><strong>题目简述：</strong> 简单的最短路。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">\tGraph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">\t\tn = input_n;</span><br><span class=\"line\">\t\tedges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">\t\tdist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Graph() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Edge &amp;j: edges[min_vertex])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + j.weight &lt; dist[j.vertex])&#123;</span><br><span class=\"line\">                    dist[j.vertex] = min_dist + j.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m) &amp;&amp; n &amp;&amp; m)&#123;</span><br><span class=\"line\">\t<span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">\t\tg.insert(a<span class=\"number\">-1</span>, b<span class=\"number\">-1</span>, c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tg.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; g.dist[n<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Hdu-2686 Matrix","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型：多线程DP*\n\n### 描述：\n\nYifenfei very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.\nEvery time yifenfei should to do is that choose a detour which frome the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix yifenfei choose. But from the top to the bottom can only choose right and down, from the bottom to the top can only choose left and up. And yifenfei can not pass the same area of the Matrix except the start and end. \n\n### Input\n\nThe input contains multiple test cases.\nEach case first line given the integer n (2<n<30) \nThan n lines,each line include n positive integers.(<100)\n\n### output\n\nFor each test case output the maximal values yifenfei can get.\n\n### sample Input\n\n2\n10 3\n5 10\n3\n10 3 3\n2 5 3\n6 7 10\n5\n1 2 3 4 5\n2 3 4 5 6\n3 4 5 6 7\n4 5 6 7 8\n5 6 7 8 9\n\n### Samput Output\n\n28\n46\n80\n\n### 题解：\n\n这个题目是一道 **多线程DP** ，题目简单的可理解为，在矩阵中选择两条不相交的最优路径，最优理解为使路径上数字的和最大。简单分析之后，可以发现此题由原来方向为==左上 -> 右下 -> 左上== 的路径可转换为两条方向为==左上 -> 右下== 的路径同时出发，且不相交，**多线程 ** 得到体现。\n\n规定dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~]表示为两条路径的终点分别为（x~1~ ，y~1~）,（x~2~ ,y~2~），原矩阵数据存在MAP\\[]\\[]中。对于当前时刻的状态，因为一个点的位置的前一个状态有两种可能性，所以一共有四种可能性，状态转移方程具体为：\n\ndp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] = max(dp\\[x~1~-1]\\[y~1~][x~2~-1]\\[y~2~],dp\\[x~1~-1]\\[y~1~][x~2~]\\[y~2~-1],dp\\[x~1~]\\[y~1~-1][x~2~-1]\\[y~2~],dp\\[x~1~]\\[y~1~-1][x~2~]\\[y~2~-1]) + MAP\\[x~1~]\\[y~1~]\n\n当x~1~ != x~2~ 或 y~1~ != y~2~ 时dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] += MAP\\[x~2~]\\[y~2~]\n\n分析下时间复杂度为O(n^4^)，空间复杂度为O(n^4^)。如何优化呢？\n\n有这么一个事实，当明确一个终点的距离原点的距离后，如果知道该终点的横左边，那么由距离可知唯一的纵左边，并且两个不同的重点有唯一相同属性**到原点的距离** ，即x~1~ + y~1~ = x~2~ + y~2~。\n\n那么我们可以设一个变量L，用来存坐标与原点的距离。dp\\[l]\\[x~1~][x~2~] 则可以简单的表示出原来的dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] ，但是空间与时间复杂度变为O(n^3^).\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <cstring>\nusing namespace std;\n\nint max(int a,int b,int c,int d){\n    int tmp1 = max(a,b);\n    int tmp2 = max(c,d);\n    return max(tmp1,tmp2);\n}\n\nint main()\n{\n    int n;\n    int MAP[40][40],dp[80][40][40];\n\n    while (scanf(\"%d\",&n) != EOF ){\n        memset(MAP,0,sizeof(MAP));\n        memset(dp,0,sizeof(dp));\n        for (int i = 1; i <= n; ++i){\n            for (int j = 1; j <= n; ++j){\n                scanf(\"%d\",&MAP[i][j]);\n            }\n        }\n\n        for (int l = 1; l <= (2 * n - 1); ++l)\n            for (int x1 = 1; x1 <= n; ++x1)\n                for (int x2 = 1; x2 <=n; ++x2){\n                    int tmp_y1 = l - x1 + 1,tmp_y2 = l - x2 + 1;\n                    dp[l][x1][x2] = max(dp[l-1][x1-1][x2-1],dp[l-1][x1][x2],\n                                        dp[l-1][x1-1][x2],dp[l-1][x1][x2-1]) + MAP[x1][tmp_y1];\n                    if (x1 != x2 || tmp_y1 != tmp_y2)\n                        dp[l][x1][x2] += MAP[x2][tmp_y2];\n                }\n                \n        cout << dp[2*n-1][n][n]<<endl;\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Hdu-2686 Matrix.md","raw":"---\ntitle: Hdu-2686 Matrix\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - Muti-treaded \n    - DP\ncategories: Algorithm\n---\n\n*类型：多线程DP*\n\n### 描述：\n\nYifenfei very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.\nEvery time yifenfei should to do is that choose a detour which frome the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix yifenfei choose. But from the top to the bottom can only choose right and down, from the bottom to the top can only choose left and up. And yifenfei can not pass the same area of the Matrix except the start and end. \n\n### Input\n\nThe input contains multiple test cases.\nEach case first line given the integer n (2<n<30) \nThan n lines,each line include n positive integers.(<100)\n\n### output\n\nFor each test case output the maximal values yifenfei can get.\n\n### sample Input\n\n2\n10 3\n5 10\n3\n10 3 3\n2 5 3\n6 7 10\n5\n1 2 3 4 5\n2 3 4 5 6\n3 4 5 6 7\n4 5 6 7 8\n5 6 7 8 9\n\n### Samput Output\n\n28\n46\n80\n\n### 题解：\n\n这个题目是一道 **多线程DP** ，题目简单的可理解为，在矩阵中选择两条不相交的最优路径，最优理解为使路径上数字的和最大。简单分析之后，可以发现此题由原来方向为==左上 -> 右下 -> 左上== 的路径可转换为两条方向为==左上 -> 右下== 的路径同时出发，且不相交，**多线程 ** 得到体现。\n\n规定dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~]表示为两条路径的终点分别为（x~1~ ，y~1~）,（x~2~ ,y~2~），原矩阵数据存在MAP\\[]\\[]中。对于当前时刻的状态，因为一个点的位置的前一个状态有两种可能性，所以一共有四种可能性，状态转移方程具体为：\n\ndp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] = max(dp\\[x~1~-1]\\[y~1~][x~2~-1]\\[y~2~],dp\\[x~1~-1]\\[y~1~][x~2~]\\[y~2~-1],dp\\[x~1~]\\[y~1~-1][x~2~-1]\\[y~2~],dp\\[x~1~]\\[y~1~-1][x~2~]\\[y~2~-1]) + MAP\\[x~1~]\\[y~1~]\n\n当x~1~ != x~2~ 或 y~1~ != y~2~ 时dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] += MAP\\[x~2~]\\[y~2~]\n\n分析下时间复杂度为O(n^4^)，空间复杂度为O(n^4^)。如何优化呢？\n\n有这么一个事实，当明确一个终点的距离原点的距离后，如果知道该终点的横左边，那么由距离可知唯一的纵左边，并且两个不同的重点有唯一相同属性**到原点的距离** ，即x~1~ + y~1~ = x~2~ + y~2~。\n\n那么我们可以设一个变量L，用来存坐标与原点的距离。dp\\[l]\\[x~1~][x~2~] 则可以简单的表示出原来的dp\\[x~1~]\\[y~1~][x~2~]\\[y~2~] ，但是空间与时间复杂度变为O(n^3^).\n\n### 代码：\n\n```c++\ninclude <iostream>\ninclude <cstdio>\ninclude <cstring>\nusing namespace std;\n\nint max(int a,int b,int c,int d){\n    int tmp1 = max(a,b);\n    int tmp2 = max(c,d);\n    return max(tmp1,tmp2);\n}\n\nint main()\n{\n    int n;\n    int MAP[40][40],dp[80][40][40];\n\n    while (scanf(\"%d\",&n) != EOF ){\n        memset(MAP,0,sizeof(MAP));\n        memset(dp,0,sizeof(dp));\n        for (int i = 1; i <= n; ++i){\n            for (int j = 1; j <= n; ++j){\n                scanf(\"%d\",&MAP[i][j]);\n            }\n        }\n\n        for (int l = 1; l <= (2 * n - 1); ++l)\n            for (int x1 = 1; x1 <= n; ++x1)\n                for (int x2 = 1; x2 <=n; ++x2){\n                    int tmp_y1 = l - x1 + 1,tmp_y2 = l - x2 + 1;\n                    dp[l][x1][x2] = max(dp[l-1][x1-1][x2-1],dp[l-1][x1][x2],\n                                        dp[l-1][x1-1][x2],dp[l-1][x1][x2-1]) + MAP[x1][tmp_y1];\n                    if (x1 != x2 || tmp_y1 != tmp_y2)\n                        dp[l][x1][x2] += MAP[x2][tmp_y2];\n                }\n                \n        cout << dp[2*n-1][n][n]<<endl;\n    }\n    return 0;\n}\n```\n\n","slug":"Hdu-2686 Matrix","published":1,"updated":"2018-07-03T06:29:52.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tv9000oplxpaql8i42l","content":"<p><em>类型：多线程DP</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>Yifenfei very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.<br>Every time yifenfei should to do is that choose a detour which frome the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix yifenfei choose. But from the top to the bottom can only choose right and down, from the bottom to the top can only choose left and up. And yifenfei can not pass the same area of the Matrix except the start and end. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input contains multiple test cases.<br>Each case first line given the integer n (2&lt;n&lt;30)<br>Than n lines,each line include n positive integers.(&lt;100)</p>\n<h3 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h3><p>For each test case output the maximal values yifenfei can get.</p>\n<h3 id=\"sample-Input\"><a href=\"#sample-Input\" class=\"headerlink\" title=\"sample Input\"></a>sample Input</h3><p>2<br>10 3<br>5 10<br>3<br>10 3 3<br>2 5 3<br>6 7 10<br>5<br>1 2 3 4 5<br>2 3 4 5 6<br>3 4 5 6 7<br>4 5 6 7 8<br>5 6 7 8 9</p>\n<h3 id=\"Samput-Output\"><a href=\"#Samput-Output\" class=\"headerlink\" title=\"Samput Output\"></a>Samput Output</h3><p>28<br>46<br>80</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>这个题目是一道 <strong>多线程DP</strong> ，题目简单的可理解为，在矩阵中选择两条不相交的最优路径，最优理解为使路径上数字的和最大。简单分析之后，可以发现此题由原来方向为==左上 -&gt; 右下 -&gt; 左上== 的路径可转换为两条方向为==左上 -&gt; 右下== 的路径同时出发，且不相交，<strong>多线程 </strong> 得到体现。</p>\n<p>规定dp[x~1~][y~1~][x~2~][y~2~]表示为两条路径的终点分别为（x~1~ ，y~1~）,（x~2~ ,y~2~），原矩阵数据存在MAP[][]中。对于当前时刻的状态，因为一个点的位置的前一个状态有两种可能性，所以一共有四种可能性，状态转移方程具体为：</p>\n<p>dp[x~1~][y~1~][x~2~][y~2~] = max(dp[x~1~-1][y~1~][x~2~-1][y~2~],dp[x~1~-1][y~1~][x~2~][y~2~-1],dp[x~1~][y~1~-1][x~2~-1][y~2~],dp[x~1~][y~1~-1][x~2~][y~2~-1]) + MAP[x~1~][y~1~]</p>\n<p>当x~1~ != x~2~ 或 y~1~ != y~2~ 时dp[x~1~][y~1~][x~2~][y~2~] += MAP[x~2~][y~2~]</p>\n<p>分析下时间复杂度为O(n^4^)，空间复杂度为O(n^4^)。如何优化呢？</p>\n<p>有这么一个事实，当明确一个终点的距离原点的距离后，如果知道该终点的横左边，那么由距离可知唯一的纵左边，并且两个不同的重点有唯一相同属性<strong>到原点的距离</strong> ，即x~1~ + y~1~ = x~2~ + y~2~。</p>\n<p>那么我们可以设一个变量L，用来存坐标与原点的距离。dp[l][x~1~][x~2~] 则可以简单的表示出原来的dp[x~1~][y~1~][x~2~][y~2~] ，但是空间与时间复杂度变为O(n^3^).</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp1 = max(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp2 = max(c,d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(tmp1,tmp2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> MAP[<span class=\"number\">40</span>][<span class=\"number\">40</span>],dp[<span class=\"number\">80</span>][<span class=\"number\">40</span>][<span class=\"number\">40</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n) != EOF )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(MAP,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(MAP));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;MAP[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>; l &lt;= (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>); ++l)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x1 = <span class=\"number\">1</span>; x1 &lt;= n; ++x1)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x2 = <span class=\"number\">1</span>; x2 &lt;=n; ++x2)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp_y1 = l - x1 + <span class=\"number\">1</span>,tmp_y2 = l - x2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    dp[l][x1][x2] = max(dp[l<span class=\"number\">-1</span>][x1<span class=\"number\">-1</span>][x2<span class=\"number\">-1</span>],dp[l<span class=\"number\">-1</span>][x1][x2],</span><br><span class=\"line\">                                        dp[l<span class=\"number\">-1</span>][x1<span class=\"number\">-1</span>][x2],dp[l<span class=\"number\">-1</span>][x1][x2<span class=\"number\">-1</span>]) + MAP[x1][tmp_y1];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x1 != x2 || tmp_y1 != tmp_y2)</span><br><span class=\"line\">                        dp[l][x1][x2] += MAP[x2][tmp_y2];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; dp[<span class=\"number\">2</span>*n<span class=\"number\">-1</span>][n][n]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型：多线程DP</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>Yifenfei very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.<br>Every time yifenfei should to do is that choose a detour which frome the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix yifenfei choose. But from the top to the bottom can only choose right and down, from the bottom to the top can only choose left and up. And yifenfei can not pass the same area of the Matrix except the start and end. </p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input contains multiple test cases.<br>Each case first line given the integer n (2&lt;n&lt;30)<br>Than n lines,each line include n positive integers.(&lt;100)</p>\n<h3 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h3><p>For each test case output the maximal values yifenfei can get.</p>\n<h3 id=\"sample-Input\"><a href=\"#sample-Input\" class=\"headerlink\" title=\"sample Input\"></a>sample Input</h3><p>2<br>10 3<br>5 10<br>3<br>10 3 3<br>2 5 3<br>6 7 10<br>5<br>1 2 3 4 5<br>2 3 4 5 6<br>3 4 5 6 7<br>4 5 6 7 8<br>5 6 7 8 9</p>\n<h3 id=\"Samput-Output\"><a href=\"#Samput-Output\" class=\"headerlink\" title=\"Samput Output\"></a>Samput Output</h3><p>28<br>46<br>80</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>这个题目是一道 <strong>多线程DP</strong> ，题目简单的可理解为，在矩阵中选择两条不相交的最优路径，最优理解为使路径上数字的和最大。简单分析之后，可以发现此题由原来方向为==左上 -&gt; 右下 -&gt; 左上== 的路径可转换为两条方向为==左上 -&gt; 右下== 的路径同时出发，且不相交，<strong>多线程 </strong> 得到体现。</p>\n<p>规定dp[x~1~][y~1~][x~2~][y~2~]表示为两条路径的终点分别为（x~1~ ，y~1~）,（x~2~ ,y~2~），原矩阵数据存在MAP[][]中。对于当前时刻的状态，因为一个点的位置的前一个状态有两种可能性，所以一共有四种可能性，状态转移方程具体为：</p>\n<p>dp[x~1~][y~1~][x~2~][y~2~] = max(dp[x~1~-1][y~1~][x~2~-1][y~2~],dp[x~1~-1][y~1~][x~2~][y~2~-1],dp[x~1~][y~1~-1][x~2~-1][y~2~],dp[x~1~][y~1~-1][x~2~][y~2~-1]) + MAP[x~1~][y~1~]</p>\n<p>当x~1~ != x~2~ 或 y~1~ != y~2~ 时dp[x~1~][y~1~][x~2~][y~2~] += MAP[x~2~][y~2~]</p>\n<p>分析下时间复杂度为O(n^4^)，空间复杂度为O(n^4^)。如何优化呢？</p>\n<p>有这么一个事实，当明确一个终点的距离原点的距离后，如果知道该终点的横左边，那么由距离可知唯一的纵左边，并且两个不同的重点有唯一相同属性<strong>到原点的距离</strong> ，即x~1~ + y~1~ = x~2~ + y~2~。</p>\n<p>那么我们可以设一个变量L，用来存坐标与原点的距离。dp[l][x~1~][x~2~] 则可以简单的表示出原来的dp[x~1~][y~1~][x~2~][y~2~] ，但是空间与时间复杂度变为O(n^3^).</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp1 = max(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp2 = max(c,d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(tmp1,tmp2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> MAP[<span class=\"number\">40</span>][<span class=\"number\">40</span>],dp[<span class=\"number\">80</span>][<span class=\"number\">40</span>][<span class=\"number\">40</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n) != EOF )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(MAP,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(MAP));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;MAP[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>; l &lt;= (<span class=\"number\">2</span> * n - <span class=\"number\">1</span>); ++l)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x1 = <span class=\"number\">1</span>; x1 &lt;= n; ++x1)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x2 = <span class=\"number\">1</span>; x2 &lt;=n; ++x2)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp_y1 = l - x1 + <span class=\"number\">1</span>,tmp_y2 = l - x2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    dp[l][x1][x2] = max(dp[l<span class=\"number\">-1</span>][x1<span class=\"number\">-1</span>][x2<span class=\"number\">-1</span>],dp[l<span class=\"number\">-1</span>][x1][x2],</span><br><span class=\"line\">                                        dp[l<span class=\"number\">-1</span>][x1<span class=\"number\">-1</span>][x2],dp[l<span class=\"number\">-1</span>][x1][x2<span class=\"number\">-1</span>]) + MAP[x1][tmp_y1];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x1 != x2 || tmp_y1 != tmp_y2)</span><br><span class=\"line\">                        dp[l][x1][x2] += MAP[x2][tmp_y2];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; dp[<span class=\"number\">2</span>*n<span class=\"number\">-1</span>][n][n]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"51nod Nim游戏","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型：Nim游戏*\n\n### 描述：\n\n有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。\n\n#### 例如：\n\n3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。\n\n### 题解：\n\n定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。\n\n**更严谨的定义**是:\n\n> 1.无法进行任何移动的局面（也就是terminal position）是P-position；\n>\n> 2.可以移动到P-position的局面是N-position；\n>\n> 3.所有移动都导致N-position的局面是P-position。\n\n按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。\n\n**结论**：对于一个Nim游戏的局面(a1,a2,...,an)，它是P-position当且仅当a1 ^ a2 ^ ... ^ an=0，其中^表示异或([xor](http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=64448407))运算。\n\n**简单证明**\n\n根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题：\n\n1. 这个判断将所有terminal position判为P-position；\n2. 根据这个判断被判为N-position的局面一定可以移动到某个P-position；\n3. 根据这个判断被判为P-position的局面无法移动到某个P-position。\n\n第一个命题，显然terminal position只有一个，就是全0，异或仍然是0。\n\n第二个命题，对于某个局面(a1,a2,...,an)，若a1 ^ a2 ^ ... ^ an != 0，一定存在某个合法的移动，将ai改变成ai'后满足a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = 0。不妨设a1 ^ a2 ^ ... ^ an = k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai ^ k < ai一定成立。则我们可以将ai改变成ai' = ai ^ k，此时a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = a1 ^ a2 ^ ... ^ an ^ k=0。\n\n第三个命题，对于某个局面(a1,a2,...,an)，若a1 ^ a2 ^ ... ^ an = 0，一定不存在某个合法的移动，将ai改变成ai'后满足a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = 0。因为异或运算满足消去率，由a1 ^ a2 ^ ... ^ an = a1 ^ a2 ^ ... ^ ai' ^ ... ^ an可以得到ai = ai'。所以将ai改变成ai'不是一个合法的移动。证毕。\n\n根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。\n\n#### 附加：\n\n当题目条件增加‘最多取k个’时，对每一堆石子mod(k+1)。\n\n### 代码：\n\n``` c++\ninclude <stdio.h>\nint main() {\n  int n, x, r = 0;\n  scanf( \"%d\", &n );\n  while( n-- ) {\n    scanf( \"%d\", &x );\n    r ^= x;\n  }\n  printf( \"%c\\n\", r == 0 ? 'B' : 'A' );\n  return 0;\n}\n```\n\n","source":"_posts/Nim游戏.md","raw":"---\ntitle: 51nod Nim游戏\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 博弈\n    - Nim游戏\ncategories: Algorithm\n---\n\n*类型：Nim游戏*\n\n### 描述：\n\n有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。\n\n#### 例如：\n\n3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。\n\n### 题解：\n\n定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。\n\n**更严谨的定义**是:\n\n> 1.无法进行任何移动的局面（也就是terminal position）是P-position；\n>\n> 2.可以移动到P-position的局面是N-position；\n>\n> 3.所有移动都导致N-position的局面是P-position。\n\n按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。\n\n**结论**：对于一个Nim游戏的局面(a1,a2,...,an)，它是P-position当且仅当a1 ^ a2 ^ ... ^ an=0，其中^表示异或([xor](http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=64448407))运算。\n\n**简单证明**\n\n根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题：\n\n1. 这个判断将所有terminal position判为P-position；\n2. 根据这个判断被判为N-position的局面一定可以移动到某个P-position；\n3. 根据这个判断被判为P-position的局面无法移动到某个P-position。\n\n第一个命题，显然terminal position只有一个，就是全0，异或仍然是0。\n\n第二个命题，对于某个局面(a1,a2,...,an)，若a1 ^ a2 ^ ... ^ an != 0，一定存在某个合法的移动，将ai改变成ai'后满足a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = 0。不妨设a1 ^ a2 ^ ... ^ an = k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai ^ k < ai一定成立。则我们可以将ai改变成ai' = ai ^ k，此时a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = a1 ^ a2 ^ ... ^ an ^ k=0。\n\n第三个命题，对于某个局面(a1,a2,...,an)，若a1 ^ a2 ^ ... ^ an = 0，一定不存在某个合法的移动，将ai改变成ai'后满足a1 ^ a2 ^ ... ^ ai' ^ ... ^ an = 0。因为异或运算满足消去率，由a1 ^ a2 ^ ... ^ an = a1 ^ a2 ^ ... ^ ai' ^ ... ^ an可以得到ai = ai'。所以将ai改变成ai'不是一个合法的移动。证毕。\n\n根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。\n\n#### 附加：\n\n当题目条件增加‘最多取k个’时，对每一堆石子mod(k+1)。\n\n### 代码：\n\n``` c++\ninclude <stdio.h>\nint main() {\n  int n, x, r = 0;\n  scanf( \"%d\", &n );\n  while( n-- ) {\n    scanf( \"%d\", &x );\n    r ^= x;\n  }\n  printf( \"%c\\n\", r == 0 ? 'B' : 'A' );\n  return 0;\n}\n```\n\n","slug":"Nim游戏","published":1,"updated":"2018-07-03T06:29:51.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvc000rplxph5eohk3e","content":"<p><em>类型：Nim游戏</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。</p>\n<p><strong>更严谨的定义</strong>是:</p>\n<blockquote>\n<p>1.无法进行任何移动的局面（也就是terminal position）是P-position；</p>\n<p>2.可以移动到P-position的局面是N-position；</p>\n<p>3.所有移动都导致N-position的局面是P-position。</p>\n</blockquote>\n<p>按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p>\n<p><strong>结论</strong>：对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1 ^ a2 ^ … ^ an=0，其中^表示异或(<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=64448407\" target=\"_blank\" rel=\"noopener\">xor</a>)运算。</p>\n<p><strong>简单证明</strong></p>\n<p>根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题：</p>\n<ol>\n<li>这个判断将所有terminal position判为P-position；</li>\n<li>根据这个判断被判为N-position的局面一定可以移动到某个P-position；</li>\n<li>根据这个判断被判为P-position的局面无法移动到某个P-position。</li>\n</ol>\n<p>第一个命题，显然terminal position只有一个，就是全0，异或仍然是0。</p>\n<p>第二个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an != 0，一定存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。不妨设a1 ^ a2 ^ … ^ an = k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai ^ k &lt; ai一定成立。则我们可以将ai改变成ai’ = ai ^ k，此时a1 ^ a2 ^ … ^ ai’ ^ … ^ an = a1 ^ a2 ^ … ^ an ^ k=0。</p>\n<p>第三个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an = 0，一定不存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。因为异或运算满足消去率，由a1 ^ a2 ^ … ^ an = a1 ^ a2 ^ … ^ ai’ ^ … ^ an可以得到ai = ai’。所以将ai改变成ai’不是一个合法的移动。证毕。</p>\n<p>根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p>\n<h4 id=\"附加：\"><a href=\"#附加：\" class=\"headerlink\" title=\"附加：\"></a>附加：</h4><p>当题目条件增加‘最多取k个’时，对每一堆石子mod(k+1)。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, x, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>( <span class=\"string\">\"%d\"</span>, &amp;n );</span><br><span class=\"line\">  <span class=\"keyword\">while</span>( n-- ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>( <span class=\"string\">\"%d\"</span>, &amp;x );</span><br><span class=\"line\">    r ^= x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"%c\\n\"</span>, r == <span class=\"number\">0</span> ? <span class=\"string\">'B'</span> : <span class=\"string\">'A'</span> );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型：Nim游戏</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。</p>\n<p><strong>更严谨的定义</strong>是:</p>\n<blockquote>\n<p>1.无法进行任何移动的局面（也就是terminal position）是P-position；</p>\n<p>2.可以移动到P-position的局面是N-position；</p>\n<p>3.所有移动都导致N-position的局面是P-position。</p>\n</blockquote>\n<p>按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。</p>\n<p><strong>结论</strong>：对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1 ^ a2 ^ … ^ an=0，其中^表示异或(<a href=\"http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=64448407\" target=\"_blank\" rel=\"noopener\">xor</a>)运算。</p>\n<p><strong>简单证明</strong></p>\n<p>根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题：</p>\n<ol>\n<li>这个判断将所有terminal position判为P-position；</li>\n<li>根据这个判断被判为N-position的局面一定可以移动到某个P-position；</li>\n<li>根据这个判断被判为P-position的局面无法移动到某个P-position。</li>\n</ol>\n<p>第一个命题，显然terminal position只有一个，就是全0，异或仍然是0。</p>\n<p>第二个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an != 0，一定存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。不妨设a1 ^ a2 ^ … ^ an = k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai ^ k &lt; ai一定成立。则我们可以将ai改变成ai’ = ai ^ k，此时a1 ^ a2 ^ … ^ ai’ ^ … ^ an = a1 ^ a2 ^ … ^ an ^ k=0。</p>\n<p>第三个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an = 0，一定不存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。因为异或运算满足消去率，由a1 ^ a2 ^ … ^ an = a1 ^ a2 ^ … ^ ai’ ^ … ^ an可以得到ai = ai’。所以将ai改变成ai’不是一个合法的移动。证毕。</p>\n<p>根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。</p>\n<h4 id=\"附加：\"><a href=\"#附加：\" class=\"headerlink\" title=\"附加：\"></a>附加：</h4><p>当题目条件增加‘最多取k个’时，对每一堆石子mod(k+1)。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, x, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>( <span class=\"string\">\"%d\"</span>, &amp;n );</span><br><span class=\"line\">  <span class=\"keyword\">while</span>( n-- ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>( <span class=\"string\">\"%d\"</span>, &amp;x );</span><br><span class=\"line\">    r ^= x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"%c\\n\"</span>, r == <span class=\"number\">0</span> ? <span class=\"string\">'B'</span> : <span class=\"string\">'A'</span> );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Normalization and Regularization","date":"2018-07-03T06:51:09.000Z","mathjax":true,"_content":"\n## 简述\n\nNormalization 就是把数据进行前处理，从而使数值都落入到统一的数值范围，从而在建模过程中，各个特征量没差别对待。normalization 一般是把数据限定在需要的范围，比如一般都是 $\\{0,1\\}$ ，从而消除了数据量纲对建模的影响。并且对基于 gradient descent 的算法友好，能加快训练速度，促进算法的收敛。\n\n注：Standardization 是 Normalization 的一种特殊情况，它对数据进行正态化处理，使数据的平均值为1，方差为0。\n\nRegularization 是在 cost function 里面加惩罚项，增加建模的模糊性，从而把捕捉到的趋势从局部细微趋势，调整到整体大概趋势。虽然一定程度上的放宽了建模要求，但是能有效防止过拟合（over-fitting）的问题。  \n\n## Normalization \n\nNormalization 的手段很多，主要有：\n\n1.  min-max normalization:  $x'=\\frac{x-min}{max-min}$ .\n2.  logarithmic transformations：$x' = \\frac{\\log{(x)}} {\\log{(x_{max})}}$ .\n3.  arctan function：$x'= arctan(x)$ .\n4.  zero mean normalization：$x'=\\frac{x-\\mu}{\\sigma}$\n\n## Regularization\n\nRegularization 主要是处理过拟合的情况，它对某些特征值进行处罚，简单来说就是降低重要性。\n\n以 Liner Regression 为例，在算法中，我们的步骤为：\n\ncost function：\n$$\nJ(\\theta)=\\frac{1}{2m}\\left[ \\sum^m_{i=1}(h_\\theta(x^{(i)})-y^{(i)} )+\\lambda\\sum^n_{j=1}\\theta^2_j \\right]\n$$\n求导完后有梯度下降迭代式，其中 $x_0$ 始终为 1 ，不参与迭代：\n\n$$\n\\begin{align}\n&\\large{重复直到收敛}\\\\{\\\\\\\\\n& \\quad \\quad \\theta_0 := \\theta_0-\\alpha \\cdot \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_0 \\\\\\\\\n& \\quad \\quad \\theta_j := \\theta_j -\\alpha \\cdot \\left[ \\left( \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_j \\right) +\\frac{\\lambda}{m}\\theta_j\\right]\\\\\\\\\n&\\\\}\n\\end{align}\n$$\n\n","source":"_posts/Normalization-and-Regularization.md","raw":"---\ntitle: Normalization and Regularization\ndate: 2018-07-03 14:51:09\nmathjax: true\ntags: \n    - Machine Learning\ncategories: Machine Learning\n---\n\n## 简述\n\nNormalization 就是把数据进行前处理，从而使数值都落入到统一的数值范围，从而在建模过程中，各个特征量没差别对待。normalization 一般是把数据限定在需要的范围，比如一般都是 $\\{0,1\\}$ ，从而消除了数据量纲对建模的影响。并且对基于 gradient descent 的算法友好，能加快训练速度，促进算法的收敛。\n\n注：Standardization 是 Normalization 的一种特殊情况，它对数据进行正态化处理，使数据的平均值为1，方差为0。\n\nRegularization 是在 cost function 里面加惩罚项，增加建模的模糊性，从而把捕捉到的趋势从局部细微趋势，调整到整体大概趋势。虽然一定程度上的放宽了建模要求，但是能有效防止过拟合（over-fitting）的问题。  \n\n## Normalization \n\nNormalization 的手段很多，主要有：\n\n1.  min-max normalization:  $x'=\\frac{x-min}{max-min}$ .\n2.  logarithmic transformations：$x' = \\frac{\\log{(x)}} {\\log{(x_{max})}}$ .\n3.  arctan function：$x'= arctan(x)$ .\n4.  zero mean normalization：$x'=\\frac{x-\\mu}{\\sigma}$\n\n## Regularization\n\nRegularization 主要是处理过拟合的情况，它对某些特征值进行处罚，简单来说就是降低重要性。\n\n以 Liner Regression 为例，在算法中，我们的步骤为：\n\ncost function：\n$$\nJ(\\theta)=\\frac{1}{2m}\\left[ \\sum^m_{i=1}(h_\\theta(x^{(i)})-y^{(i)} )+\\lambda\\sum^n_{j=1}\\theta^2_j \\right]\n$$\n求导完后有梯度下降迭代式，其中 $x_0$ 始终为 1 ，不参与迭代：\n\n$$\n\\begin{align}\n&\\large{重复直到收敛}\\\\{\\\\\\\\\n& \\quad \\quad \\theta_0 := \\theta_0-\\alpha \\cdot \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_0 \\\\\\\\\n& \\quad \\quad \\theta_j := \\theta_j -\\alpha \\cdot \\left[ \\left( \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_j \\right) +\\frac{\\lambda}{m}\\theta_j\\right]\\\\\\\\\n&\\\\}\n\\end{align}\n$$\n\n","slug":"Normalization-and-Regularization","published":1,"updated":"2018-07-03T07:51:18.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvd000uplxp948a8v9q","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>Normalization 就是把数据进行前处理，从而使数值都落入到统一的数值范围，从而在建模过程中，各个特征量没差别对待。normalization 一般是把数据限定在需要的范围，比如一般都是 ${0,1}$ ，从而消除了数据量纲对建模的影响。并且对基于 gradient descent 的算法友好，能加快训练速度，促进算法的收敛。</p>\n<p>注：Standardization 是 Normalization 的一种特殊情况，它对数据进行正态化处理，使数据的平均值为1，方差为0。</p>\n<p>Regularization 是在 cost function 里面加惩罚项，增加建模的模糊性，从而把捕捉到的趋势从局部细微趋势，调整到整体大概趋势。虽然一定程度上的放宽了建模要求，但是能有效防止过拟合（over-fitting）的问题。  </p>\n<h2 id=\"Normalization\"><a href=\"#Normalization\" class=\"headerlink\" title=\"Normalization\"></a>Normalization</h2><p>Normalization 的手段很多，主要有：</p>\n<ol>\n<li>min-max normalization:  $x’=\\frac{x-min}{max-min}$ .</li>\n<li>logarithmic transformations：$x’ = \\frac{\\log{(x)}} {\\log{(x_{max})}}$ .</li>\n<li>arctan function：$x’= arctan(x)$ .</li>\n<li>zero mean normalization：$x’=\\frac{x-\\mu}{\\sigma}$</li>\n</ol>\n<h2 id=\"Regularization\"><a href=\"#Regularization\" class=\"headerlink\" title=\"Regularization\"></a>Regularization</h2><p>Regularization 主要是处理过拟合的情况，它对某些特征值进行处罚，简单来说就是降低重要性。</p>\n<p>以 Liner Regression 为例，在算法中，我们的步骤为：</p>\n<p>cost function：<br>$$<br>J(\\theta)=\\frac{1}{2m}\\left[ \\sum^m_{i=1}(h_\\theta(x^{(i)})-y^{(i)} )+\\lambda\\sum^n_{j=1}\\theta^2_j \\right]<br>$$<br>求导完后有梯度下降迭代式，其中 $x_0$ 始终为 1 ，不参与迭代：</p>\n<p>$$<br>\\begin{align}<br>&amp;\\large{重复直到收敛}\\{\\\\<br>&amp; \\quad \\quad \\theta_0 := \\theta_0-\\alpha \\cdot \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_0 \\\\<br>&amp; \\quad \\quad \\theta_j := \\theta_j -\\alpha \\cdot \\left[ \\left( \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_j \\right) +\\frac{\\lambda}{m}\\theta_j\\right]\\\\<br>&amp;\\}<br>\\end{align}<br>$$</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>Normalization 就是把数据进行前处理，从而使数值都落入到统一的数值范围，从而在建模过程中，各个特征量没差别对待。normalization 一般是把数据限定在需要的范围，比如一般都是 ${0,1}$ ，从而消除了数据量纲对建模的影响。并且对基于 gradient descent 的算法友好，能加快训练速度，促进算法的收敛。</p>\n<p>注：Standardization 是 Normalization 的一种特殊情况，它对数据进行正态化处理，使数据的平均值为1，方差为0。</p>\n<p>Regularization 是在 cost function 里面加惩罚项，增加建模的模糊性，从而把捕捉到的趋势从局部细微趋势，调整到整体大概趋势。虽然一定程度上的放宽了建模要求，但是能有效防止过拟合（over-fitting）的问题。  </p>\n<h2 id=\"Normalization\"><a href=\"#Normalization\" class=\"headerlink\" title=\"Normalization\"></a>Normalization</h2><p>Normalization 的手段很多，主要有：</p>\n<ol>\n<li>min-max normalization:  $x’=\\frac{x-min}{max-min}$ .</li>\n<li>logarithmic transformations：$x’ = \\frac{\\log{(x)}} {\\log{(x_{max})}}$ .</li>\n<li>arctan function：$x’= arctan(x)$ .</li>\n<li>zero mean normalization：$x’=\\frac{x-\\mu}{\\sigma}$</li>\n</ol>\n<h2 id=\"Regularization\"><a href=\"#Regularization\" class=\"headerlink\" title=\"Regularization\"></a>Regularization</h2><p>Regularization 主要是处理过拟合的情况，它对某些特征值进行处罚，简单来说就是降低重要性。</p>\n<p>以 Liner Regression 为例，在算法中，我们的步骤为：</p>\n<p>cost function：<br>$$<br>J(\\theta)=\\frac{1}{2m}\\left[ \\sum^m_{i=1}(h_\\theta(x^{(i)})-y^{(i)} )+\\lambda\\sum^n_{j=1}\\theta^2_j \\right]<br>$$<br>求导完后有梯度下降迭代式，其中 $x_0$ 始终为 1 ，不参与迭代：</p>\n<p>$$<br>\\begin{align}<br>&amp;\\large{重复直到收敛}\\{\\\\<br>&amp; \\quad \\quad \\theta_0 := \\theta_0-\\alpha \\cdot \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_0 \\\\<br>&amp; \\quad \\quad \\theta_j := \\theta_j -\\alpha \\cdot \\left[ \\left( \\frac{1}{m}\\sum^{m}{i=1}(h{\\theta}(x^{(i)})-(y^{(i)})x^{(i)}_j \\right) +\\frac{\\lambda}{m}\\theta_j\\right]\\\\<br>&amp;\\}<br>\\end{align}<br>$$</p>\n"},{"title":"第k短路的故事","date":"2017-08-18T11:43:57.000Z","mathjax":true,"_content":"\n# 第k短路的故事\n\n*A\\*、第 k 短路*\n\n## description\n\n\"Good man never makes girls wait or breaks an appointment!\" said the mandarin duck father. Softly touching his little ducks' head, he told them a story. \n\n\"Prince Remmarguts lives in his kingdom UDF – United Delta of Freedom. One day their neighboring country sent them Princess Uyuw on a diplomatic mission.\" \n\n\"Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)\" \n\nBeing interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister's help! \n\nDETAILS: UDF's capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince' current place. M muddy directed sideways connect some of the stations. Remmarguts' path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. \n\n## Input\n\nThe first line contains two integer numbers N and M (1 <= N <= 1000, 0 <= M <= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 <= A, B <= N, 1 <= T <= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. \n\nThe last line consists of three integer numbers S, T and K (1 <= S, T <= N, 1 <= K <= 1000).\n\n## Output\n\nA single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output \"-1\" (without quotes) instead.\n\n## Sample Input\n\n```\n2 2\n1 2 5\n2 1 4\n1 2 2\n```\n\n## Sample Output\n\n```\n14\n```\n\n## 题解\n\n### A*算法：\n\n为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。而A*算法最为核心的部分，就在于它的一个估值函数的设计上： \n**$f(n)=g(n)+h(n)$** \n其中$f(n)$是每个可能试探点的估值，它有两部分组成：一部分为$g(n)$，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。另一部分，即$h(n)$，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，$h(n)$设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A*算法。\n\n**一种具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法的充分条件是：**\n\n1. 搜索树上存在着从起始点到终了点的最优路径。\n2. 问题域是有限的。\n3. 所有结点的子结点的搜索代价值>0。\n4. h(n) <= h * (n) （h*(n)为实际问题的代价值）。\n\n一般的搜索前三条都可以满足，而第四点就要视情况而定了。 \n\n### 第K路\n\n**K短路的定义：**假设从1出发，有M条长度不同的路径可以到达点N，则K短路就是这M条路径中第K小的路径长度。 \n以上所述，设f[n]为最终所求，则f(n)=g(n)+h(n)；h(n)就是我们所说的‘启发式函数’，表示为**重点t到其余一点p的路径长度**，g（n）表示**g当前从s到p所走的路径的长度。** \n即\n\n**估价函数=当前值+当前位置到终点的距离**\n\n**解决思路：**\n\n1. 将有向图的所有边反向,以原终点t为源点,求解t到所有点的最短距离;  \n2. 新建一个优先队列,将源点s加入到队列中;  \n3. 从优先级队列中弹出f(p)最小的点p,如果点p就是t,则计算t出队的次数;  \n\n如果当前为t的第k次出队,则当前路径的长度就是s到t的第k短路的长度,算法结束;  \n否则遍历与p相连的所有的边,将扩展出的到p的邻接点信息加入到优先级队列;\n\n## 代码\n\n```c++\n#include<string.h>\n#include<algorithm>\n#include<queue> \nusing namespace std;\n#define INF 0xffffff\n#define MAXN 100010\nstruct node\n{\n    int to;\n    int val;\n    int next;\n};\nstruct node2\n{\n    int to;\n    int g,f;\n    bool operator<(const node2 &r ) const  \n    {  \n        if(r.f==f)  \n            return r.g<g;  \n        return r.f<f;  \n    }   \n};\nnode edge[MAXN],edge2[MAXN];\nint n,m,s,t,k,cnt,cnt2,ans;\nint dis[1010],visit[1010],head[1010],head2[1010];\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    memset(head2,-1,sizeof(head2));\n    cnt=cnt2=1;\n}\nvoid addedge(int from,int to,int val)\n{\n    edge[cnt].to=to;\n    edge[cnt].val=val;\n    edge[cnt].next=head[from];\n    head[from]=cnt++;\n}\nvoid addedge2(int from,int to,int val)\n{\n    edge2[cnt2].to=to;\n    edge2[cnt2].val=val;\n    edge2[cnt2].next=head2[from];\n    head2[from]=cnt2++;\n}\nbool spfa(int s,int n,int head[],node edge[],int dist[])  \n{  \n    queue<int>Q1;  \n    int inq[1010];  \n    for(int i=0;i<=n;i++)  \n    {  \n        dis[i]=INF;  \n        inq[i]=0;  \n    }  \n    dis[s]=0;  \n    Q1.push(s);  \n    inq[s]++;  \n    while(!Q1.empty())  \n    {  \n        int q=Q1.front();  \n        Q1.pop();  \n        inq[q]--;  \n        if(inq[q]>n)\n            return false;  \n        int k=head[q];  \n        while(k>=0)  \n        {  \n            if(dist[edge[k].to]>dist[q]+edge[k].val)  \n            {  \n                dist[edge[k].to]=edge[k].val+dist[q];  \n                if(!inq[edge[k].to])  \n                {  \n                    inq[edge[k].to]++;  \n                    Q1.push(edge[k].to);  \n                }  \n            }  \n            k=edge[k].next;  \n        }  \n    }  \n    return true;  \n}\nint A_star(int s,int t,int n,int k,int head[],node edge[],int dist[]) \n{  \n    node2 e,ne;  \n    int cnt=0;  \n    priority_queue<node2>Q;  \n    if(s==t)\n        k++;  \n    if(dis[s]==INF)  \n        return -1;  \n    e.to=s;  \n    e.g=0;  \n    e.f=e.g+dis[e.to];  \n    Q.push(e);  \n\n    while(!Q.empty())  \n    {  \n        e=Q.top();  \n        Q.pop();  \n        if(e.to==t)//找到一条最短路径  \n        {  \n            cnt++;  \n        }  \n        if(cnt==k)//找到k短路  \n        {  \n            return e.g;  \n        }  \n        for(int i=head[e.to]; i!=-1; i=edge[i].next)  \n        {  \n            ne.to=edge[i].to;  \n            ne.g=e.g+edge[i].val;  \n            ne.f=ne.g+dis[ne.to];  \n            Q.push(ne);  \n        }  \n    }  \n    return -1;  \n}  \nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        for(int i=1;i<=m;i++)\n        {\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            addedge(a,b,c);\n            addedge2(b,a,c);\n        }\n        scanf(\"%d%d%d\",&s,&t,&k);\n        spfa(t,n,head2,edge2,dis);\n        ans=A_star(s,t,n,k,head,edge,dis);\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n} \n```\n\n\n\n\n\n","source":"_posts/POJ-2449.md","raw":"---\ntitle: 第k短路的故事\ndate: 2017-08-18 19:43:57\nmathjax: true\ntags: \n    - A\\*\n    - 图论\ncategories: Algorithm\n---\n\n# 第k短路的故事\n\n*A\\*、第 k 短路*\n\n## description\n\n\"Good man never makes girls wait or breaks an appointment!\" said the mandarin duck father. Softly touching his little ducks' head, he told them a story. \n\n\"Prince Remmarguts lives in his kingdom UDF – United Delta of Freedom. One day their neighboring country sent them Princess Uyuw on a diplomatic mission.\" \n\n\"Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)\" \n\nBeing interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister's help! \n\nDETAILS: UDF's capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince' current place. M muddy directed sideways connect some of the stations. Remmarguts' path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. \n\n## Input\n\nThe first line contains two integer numbers N and M (1 <= N <= 1000, 0 <= M <= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 <= A, B <= N, 1 <= T <= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. \n\nThe last line consists of three integer numbers S, T and K (1 <= S, T <= N, 1 <= K <= 1000).\n\n## Output\n\nA single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output \"-1\" (without quotes) instead.\n\n## Sample Input\n\n```\n2 2\n1 2 5\n2 1 4\n1 2 2\n```\n\n## Sample Output\n\n```\n14\n```\n\n## 题解\n\n### A*算法：\n\n为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。而A*算法最为核心的部分，就在于它的一个估值函数的设计上： \n**$f(n)=g(n)+h(n)$** \n其中$f(n)$是每个可能试探点的估值，它有两部分组成：一部分为$g(n)$，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。另一部分，即$h(n)$，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，$h(n)$设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A*算法。\n\n**一种具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法的充分条件是：**\n\n1. 搜索树上存在着从起始点到终了点的最优路径。\n2. 问题域是有限的。\n3. 所有结点的子结点的搜索代价值>0。\n4. h(n) <= h * (n) （h*(n)为实际问题的代价值）。\n\n一般的搜索前三条都可以满足，而第四点就要视情况而定了。 \n\n### 第K路\n\n**K短路的定义：**假设从1出发，有M条长度不同的路径可以到达点N，则K短路就是这M条路径中第K小的路径长度。 \n以上所述，设f[n]为最终所求，则f(n)=g(n)+h(n)；h(n)就是我们所说的‘启发式函数’，表示为**重点t到其余一点p的路径长度**，g（n）表示**g当前从s到p所走的路径的长度。** \n即\n\n**估价函数=当前值+当前位置到终点的距离**\n\n**解决思路：**\n\n1. 将有向图的所有边反向,以原终点t为源点,求解t到所有点的最短距离;  \n2. 新建一个优先队列,将源点s加入到队列中;  \n3. 从优先级队列中弹出f(p)最小的点p,如果点p就是t,则计算t出队的次数;  \n\n如果当前为t的第k次出队,则当前路径的长度就是s到t的第k短路的长度,算法结束;  \n否则遍历与p相连的所有的边,将扩展出的到p的邻接点信息加入到优先级队列;\n\n## 代码\n\n```c++\n#include<string.h>\n#include<algorithm>\n#include<queue> \nusing namespace std;\n#define INF 0xffffff\n#define MAXN 100010\nstruct node\n{\n    int to;\n    int val;\n    int next;\n};\nstruct node2\n{\n    int to;\n    int g,f;\n    bool operator<(const node2 &r ) const  \n    {  \n        if(r.f==f)  \n            return r.g<g;  \n        return r.f<f;  \n    }   \n};\nnode edge[MAXN],edge2[MAXN];\nint n,m,s,t,k,cnt,cnt2,ans;\nint dis[1010],visit[1010],head[1010],head2[1010];\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    memset(head2,-1,sizeof(head2));\n    cnt=cnt2=1;\n}\nvoid addedge(int from,int to,int val)\n{\n    edge[cnt].to=to;\n    edge[cnt].val=val;\n    edge[cnt].next=head[from];\n    head[from]=cnt++;\n}\nvoid addedge2(int from,int to,int val)\n{\n    edge2[cnt2].to=to;\n    edge2[cnt2].val=val;\n    edge2[cnt2].next=head2[from];\n    head2[from]=cnt2++;\n}\nbool spfa(int s,int n,int head[],node edge[],int dist[])  \n{  \n    queue<int>Q1;  \n    int inq[1010];  \n    for(int i=0;i<=n;i++)  \n    {  \n        dis[i]=INF;  \n        inq[i]=0;  \n    }  \n    dis[s]=0;  \n    Q1.push(s);  \n    inq[s]++;  \n    while(!Q1.empty())  \n    {  \n        int q=Q1.front();  \n        Q1.pop();  \n        inq[q]--;  \n        if(inq[q]>n)\n            return false;  \n        int k=head[q];  \n        while(k>=0)  \n        {  \n            if(dist[edge[k].to]>dist[q]+edge[k].val)  \n            {  \n                dist[edge[k].to]=edge[k].val+dist[q];  \n                if(!inq[edge[k].to])  \n                {  \n                    inq[edge[k].to]++;  \n                    Q1.push(edge[k].to);  \n                }  \n            }  \n            k=edge[k].next;  \n        }  \n    }  \n    return true;  \n}\nint A_star(int s,int t,int n,int k,int head[],node edge[],int dist[]) \n{  \n    node2 e,ne;  \n    int cnt=0;  \n    priority_queue<node2>Q;  \n    if(s==t)\n        k++;  \n    if(dis[s]==INF)  \n        return -1;  \n    e.to=s;  \n    e.g=0;  \n    e.f=e.g+dis[e.to];  \n    Q.push(e);  \n\n    while(!Q.empty())  \n    {  \n        e=Q.top();  \n        Q.pop();  \n        if(e.to==t)//找到一条最短路径  \n        {  \n            cnt++;  \n        }  \n        if(cnt==k)//找到k短路  \n        {  \n            return e.g;  \n        }  \n        for(int i=head[e.to]; i!=-1; i=edge[i].next)  \n        {  \n            ne.to=edge[i].to;  \n            ne.g=e.g+edge[i].val;  \n            ne.f=ne.g+dis[ne.to];  \n            Q.push(ne);  \n        }  \n    }  \n    return -1;  \n}  \nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        for(int i=1;i<=m;i++)\n        {\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            addedge(a,b,c);\n            addedge2(b,a,c);\n        }\n        scanf(\"%d%d%d\",&s,&t,&k);\n        spfa(t,n,head2,edge2,dis);\n        ans=A_star(s,t,n,k,head,edge,dis);\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n} \n```\n\n\n\n\n\n","slug":"POJ-2449","published":1,"updated":"2018-07-03T06:29:51.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvf000wplxpcpykxq1w","content":"<h1 id=\"第k短路的故事\"><a href=\"#第k短路的故事\" class=\"headerlink\" title=\"第k短路的故事\"></a>第k短路的故事</h1><p><em>A\\</em>、第 k 短路*</p>\n<h2 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h2><p>“Good man never makes girls wait or breaks an appointment!” said the mandarin duck father. Softly touching his little ducks’ head, he told them a story. </p>\n<p>“Prince Remmarguts lives in his kingdom UDF – United Delta of Freedom. One day their neighboring country sent them Princess Uyuw on a diplomatic mission.” </p>\n<p>“Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)” </p>\n<p>Being interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister’s help! </p>\n<p>DETAILS: UDF’s capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince’ current place. M muddy directed sideways connect some of the stations. Remmarguts’ path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. </p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>The first line contains two integer numbers N and M (1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 &lt;= A, B &lt;= N, 1 &lt;= T &lt;= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. </p>\n<p>The last line consists of three integer numbers S, T and K (1 &lt;= S, T &lt;= N, 1 &lt;= K &lt;= 1000).</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>A single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output “-1” (without quotes) instead.</p>\n<h2 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 2</span><br><span class=\"line\">1 2 5</span><br><span class=\"line\">2 1 4</span><br><span class=\"line\">1 2 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14</span><br></pre></td></tr></table></figure>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"A-算法：\"><a href=\"#A-算法：\" class=\"headerlink\" title=\"A*算法：\"></a>A*算法：</h3><p>为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。而A<em>算法最为核心的部分，就在于它的一个估值函数的设计上：<br><strong>$f(n)=g(n)+h(n)$</strong><br>其中$f(n)$是每个可能试探点的估值，它有两部分组成：一部分为$g(n)$，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。另一部分，即$h(n)$，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，$h(n)$设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A</em>算法。</p>\n<p><strong>一种具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法的充分条件是：</strong></p>\n<ol>\n<li>搜索树上存在着从起始点到终了点的最优路径。</li>\n<li>问题域是有限的。</li>\n<li>所有结点的子结点的搜索代价值&gt;0。</li>\n<li>h(n) &lt;= h <em> (n) （h</em>(n)为实际问题的代价值）。</li>\n</ol>\n<p>一般的搜索前三条都可以满足，而第四点就要视情况而定了。 </p>\n<h3 id=\"第K路\"><a href=\"#第K路\" class=\"headerlink\" title=\"第K路\"></a>第K路</h3><p><strong>K短路的定义：</strong>假设从1出发，有M条长度不同的路径可以到达点N，则K短路就是这M条路径中第K小的路径长度。<br>以上所述，设f[n]为最终所求，则f(n)=g(n)+h(n)；h(n)就是我们所说的‘启发式函数’，表示为<strong>重点t到其余一点p的路径长度</strong>，g（n）表示<strong>g当前从s到p所走的路径的长度。</strong><br>即</p>\n<p><strong>估价函数=当前值+当前位置到终点的距离</strong></p>\n<p><strong>解决思路：</strong></p>\n<ol>\n<li>将有向图的所有边反向,以原终点t为源点,求解t到所有点的最短距离;  </li>\n<li>新建一个优先队列,将源点s加入到队列中;  </li>\n<li>从优先级队列中弹出f(p)最小的点p,如果点p就是t,则计算t出队的次数;  </li>\n</ol>\n<p>如果当前为t的第k次出队,则当前路径的长度就是s到t的第k短路的长度,算法结束;<br>否则遍历与p相连的所有的边,将扩展出的到p的邻接点信息加入到优先级队列;</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt; </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0xffffff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100010</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node2</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> g,f;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> node2 &amp;r ) <span class=\"keyword\">const</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r.f==f)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> r.g&lt;g;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.f&lt;f;  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node edge[MAXN],edge2[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,k,cnt,cnt2,ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[<span class=\"number\">1010</span>],visit[<span class=\"number\">1010</span>],head[<span class=\"number\">1010</span>],head2[<span class=\"number\">1010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head2,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head2));</span><br><span class=\"line\">    cnt=cnt2=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> from,<span class=\"keyword\">int</span> to,<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edge[cnt].to=to;</span><br><span class=\"line\">    edge[cnt].val=val;</span><br><span class=\"line\">    edge[cnt].next=head[from];</span><br><span class=\"line\">    head[from]=cnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge2</span><span class=\"params\">(<span class=\"keyword\">int</span> from,<span class=\"keyword\">int</span> to,<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edge2[cnt2].to=to;</span><br><span class=\"line\">    edge2[cnt2].val=val;</span><br><span class=\"line\">    edge2[cnt2].next=head2[from];</span><br><span class=\"line\">    head2[from]=cnt2++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> head[],node edge[],<span class=\"keyword\">int</span> dist[])</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;Q1;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> inq[<span class=\"number\">1010</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        dis[i]=INF;  </span><br><span class=\"line\">        inq[i]=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    Q1.push(s);  </span><br><span class=\"line\">    inq[s]++;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.empty())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> q=Q1.front();  </span><br><span class=\"line\">        Q1.pop();  </span><br><span class=\"line\">        inq[q]--;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inq[q]&gt;n)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=head[q];  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k&gt;=<span class=\"number\">0</span>)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[edge[k].to]&gt;dist[q]+edge[k].val)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                dist[edge[k].to]=edge[k].val+dist[q];  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!inq[edge[k].to])  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    inq[edge[k].to]++;  </span><br><span class=\"line\">                    Q1.push(edge[k].to);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            k=edge[k].next;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">A_star</span><span class=\"params\">(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> head[],node edge[],<span class=\"keyword\">int</span> dist[])</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    node2 e,ne;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    priority_queue&lt;node2&gt;Q;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==t)</span><br><span class=\"line\">        k++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis[s]==INF)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  </span><br><span class=\"line\">    e.to=s;  </span><br><span class=\"line\">    e.g=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    e.f=e.g+dis[e.to];  </span><br><span class=\"line\">    Q.push(e);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q.empty())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e=Q.top();  </span><br><span class=\"line\">        Q.pop();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.to==t)<span class=\"comment\">//找到一条最短路径  </span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            cnt++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt==k)<span class=\"comment\">//找到k短路  </span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.g;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[e.to]; i!=<span class=\"number\">-1</span>; i=edge[i].next)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            ne.to=edge[i].to;  </span><br><span class=\"line\">            ne.g=e.g+edge[i].val;  </span><br><span class=\"line\">            ne.f=ne.g+dis[ne.to];  </span><br><span class=\"line\">            Q.push(ne);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">            addedge(a,b,c);</span><br><span class=\"line\">            addedge2(b,a,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;s,&amp;t,&amp;k);</span><br><span class=\"line\">        spfa(t,n,head2,edge2,dis);</span><br><span class=\"line\">        ans=A_star(s,t,n,k,head,edge,dis);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第k短路的故事\"><a href=\"#第k短路的故事\" class=\"headerlink\" title=\"第k短路的故事\"></a>第k短路的故事</h1><p><em>A\\</em>、第 k 短路*</p>\n<h2 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h2><p>“Good man never makes girls wait or breaks an appointment!” said the mandarin duck father. Softly touching his little ducks’ head, he told them a story. </p>\n<p>“Prince Remmarguts lives in his kingdom UDF – United Delta of Freedom. One day their neighboring country sent them Princess Uyuw on a diplomatic mission.” </p>\n<p>“Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)” </p>\n<p>Being interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister’s help! </p>\n<p>DETAILS: UDF’s capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince’ current place. M muddy directed sideways connect some of the stations. Remmarguts’ path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. </p>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><p>The first line contains two integer numbers N and M (1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 &lt;= A, B &lt;= N, 1 &lt;= T &lt;= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. </p>\n<p>The last line consists of three integer numbers S, T and K (1 &lt;= S, T &lt;= N, 1 &lt;= K &lt;= 1000).</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>A single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output “-1” (without quotes) instead.</p>\n<h2 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 2</span><br><span class=\"line\">1 2 5</span><br><span class=\"line\">2 1 4</span><br><span class=\"line\">1 2 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14</span><br></pre></td></tr></table></figure>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"A-算法：\"><a href=\"#A-算法：\" class=\"headerlink\" title=\"A*算法：\"></a>A*算法：</h3><p>为启发式算法中很重要的一种，被广泛应用在最优路径求解和一些策略设计的问题中。而A<em>算法最为核心的部分，就在于它的一个估值函数的设计上：<br><strong>$f(n)=g(n)+h(n)$</strong><br>其中$f(n)$是每个可能试探点的估值，它有两部分组成：一部分为$g(n)$，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。另一部分，即$h(n)$，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，$h(n)$设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A</em>算法。</p>\n<p><strong>一种具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法的充分条件是：</strong></p>\n<ol>\n<li>搜索树上存在着从起始点到终了点的最优路径。</li>\n<li>问题域是有限的。</li>\n<li>所有结点的子结点的搜索代价值&gt;0。</li>\n<li>h(n) &lt;= h <em> (n) （h</em>(n)为实际问题的代价值）。</li>\n</ol>\n<p>一般的搜索前三条都可以满足，而第四点就要视情况而定了。 </p>\n<h3 id=\"第K路\"><a href=\"#第K路\" class=\"headerlink\" title=\"第K路\"></a>第K路</h3><p><strong>K短路的定义：</strong>假设从1出发，有M条长度不同的路径可以到达点N，则K短路就是这M条路径中第K小的路径长度。<br>以上所述，设f[n]为最终所求，则f(n)=g(n)+h(n)；h(n)就是我们所说的‘启发式函数’，表示为<strong>重点t到其余一点p的路径长度</strong>，g（n）表示<strong>g当前从s到p所走的路径的长度。</strong><br>即</p>\n<p><strong>估价函数=当前值+当前位置到终点的距离</strong></p>\n<p><strong>解决思路：</strong></p>\n<ol>\n<li>将有向图的所有边反向,以原终点t为源点,求解t到所有点的最短距离;  </li>\n<li>新建一个优先队列,将源点s加入到队列中;  </li>\n<li>从优先级队列中弹出f(p)最小的点p,如果点p就是t,则计算t出队的次数;  </li>\n</ol>\n<p>如果当前为t的第k次出队,则当前路径的长度就是s到t的第k短路的长度,算法结束;<br>否则遍历与p相连的所有的边,将扩展出的到p的邻接点信息加入到优先级队列;</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt; </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0xffffff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100010</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node2</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> g,f;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> node2 &amp;r ) <span class=\"keyword\">const</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r.f==f)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> r.g&lt;g;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.f&lt;f;  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node edge[MAXN],edge2[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,k,cnt,cnt2,ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[<span class=\"number\">1010</span>],visit[<span class=\"number\">1010</span>],head[<span class=\"number\">1010</span>],head2[<span class=\"number\">1010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head2,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head2));</span><br><span class=\"line\">    cnt=cnt2=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> from,<span class=\"keyword\">int</span> to,<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edge[cnt].to=to;</span><br><span class=\"line\">    edge[cnt].val=val;</span><br><span class=\"line\">    edge[cnt].next=head[from];</span><br><span class=\"line\">    head[from]=cnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge2</span><span class=\"params\">(<span class=\"keyword\">int</span> from,<span class=\"keyword\">int</span> to,<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edge2[cnt2].to=to;</span><br><span class=\"line\">    edge2[cnt2].val=val;</span><br><span class=\"line\">    edge2[cnt2].next=head2[from];</span><br><span class=\"line\">    head2[from]=cnt2++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> head[],node edge[],<span class=\"keyword\">int</span> dist[])</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;Q1;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> inq[<span class=\"number\">1010</span>];  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        dis[i]=INF;  </span><br><span class=\"line\">        inq[i]=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    dis[s]=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    Q1.push(s);  </span><br><span class=\"line\">    inq[s]++;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.empty())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> q=Q1.front();  </span><br><span class=\"line\">        Q1.pop();  </span><br><span class=\"line\">        inq[q]--;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inq[q]&gt;n)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> k=head[q];  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k&gt;=<span class=\"number\">0</span>)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[edge[k].to]&gt;dist[q]+edge[k].val)  </span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                dist[edge[k].to]=edge[k].val+dist[q];  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!inq[edge[k].to])  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    inq[edge[k].to]++;  </span><br><span class=\"line\">                    Q1.push(edge[k].to);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            k=edge[k].next;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">A_star</span><span class=\"params\">(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> head[],node edge[],<span class=\"keyword\">int</span> dist[])</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    node2 e,ne;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    priority_queue&lt;node2&gt;Q;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==t)</span><br><span class=\"line\">        k++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis[s]==INF)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  </span><br><span class=\"line\">    e.to=s;  </span><br><span class=\"line\">    e.g=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    e.f=e.g+dis[e.to];  </span><br><span class=\"line\">    Q.push(e);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q.empty())  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e=Q.top();  </span><br><span class=\"line\">        Q.pop();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.to==t)<span class=\"comment\">//找到一条最短路径  </span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            cnt++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt==k)<span class=\"comment\">//找到k短路  </span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.g;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[e.to]; i!=<span class=\"number\">-1</span>; i=edge[i].next)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            ne.to=edge[i].to;  </span><br><span class=\"line\">            ne.g=e.g+edge[i].val;  </span><br><span class=\"line\">            ne.f=ne.g+dis[ne.to];  </span><br><span class=\"line\">            Q.push(ne);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">            addedge(a,b,c);</span><br><span class=\"line\">            addedge2(b,a,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;s,&amp;t,&amp;k);</span><br><span class=\"line\">        spfa(t,n,head2,edge2,dis);</span><br><span class=\"line\">        ans=A_star(s,t,n,k,head,edge,dis);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"伸展树——Splay Tree","date":"2017-08-18T11:43:57.000Z","mathjax":true,"_content":"\n# 伸展树——Splay Tree \n## 简单介绍\n**伸展树**（英语：Splay Tree）是一种二叉查找树，它能在$O(log(n))$内完成插入、查找和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和羅伯特·塔揚在1985年发明的。\n在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行調整，把被查找的条目搬移到离树根近一些的地方。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。\n它的优势在于不需要记录用于平衡树的冗余信息。\n\n## 目的\n\n把重要的树节点转移树根。使在最坏的情况下,查询时间复杂度仍然为$O(log(n))$。\n\n## 时间复杂度证明\n\n具体证明请看维基百科的。 [Splay tree - Wikipedia](https://en.wikipedia.org/wiki/Splay_tree)\n\n## 操作\n\n### 基本操作：旋转\n\n![](http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png)\n\n首先讲基本旋转之一右旋（zig）：\n\n解释下上面这个图，对于右旋，P为目标节点，Q为P的父节点，A、B、C则是相关子节点。右旋操作可以将P节点变为Q的父节点，且保持原有的二叉查询树的特性，即对于某一节点，其左子树的所有节点的值都小于该节点而右子树的所有节点的值都大于该节点。\n\n整个过程分为三步：\n\n1. 将P的右子树B(如果有的话)作Q的左子树，即让B认Q作爹\n2. 设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Q是Z的左儿子还是右儿子决定，要左右一致)\n3. 将Q作为P的右子树，即让Q认P作爹。\n\n####右旋代码：\n\n```c++\nvoid right_rotate(long P)\n{\n\tlong Q = father[P];\n\tlong Z = father[Q];//这里的z与上文的Q相关，表示y的父节点。\n    leftson[Q] = rightson[P];//第一步，将P的右子树B(如果有的话)作Q的左子树。\n    if(rightson[P] != 0)\n    \tfather[rightson[P]] = Q;//第一步，B认Q为父。\n    father[P] = Z;//第二步，P认Z做爹。\n    if(z != 0){\n\t\tif(leftson[Z] == y)//判断原来的Q是Z的左节点还是有节点。\n        \tleftson[Z] = P;//第二步,P做Z儿子。\n     \telse \n          \trightson[Z] = P;\n    }\n    rightson[P] = y;//第三步，Q作为P的右子树\n  \tfather[Q] = P;//第三步，Q认P作爹\n}\n```\n\n\n\n接着另一个旋转——左旋（zag）：\n\n有了上面右旋的基础，就直接说明步骤了：\n\n1. 将P的左子树B(如果有的话)作Q的右子树，即让B认Q作爹\n2. 设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Y是Z的左儿子还是右儿子决定，要左右一致)\n3. 将Q作为P的左子树，即让P认P作爹。\n\n#### 左旋代码：\n\n```c++\nvoid left_rotate(long P)\n{\n\tlong Q = father[P];\n\tlong Z = father[Q];\n\trightson[Q] = leftson[P];\n\tif(leftson[P] != 0)\n      \tfather[leftson[P]] = Q;\n\tfather[P]=Z;\n\tif(Z != 0){\n    \tif(leftson[Z] == Q)\n          \tleftson[Z] = P;\n      \telse \n          \trightson[Z] = P;\n\t}\n  \tleftson[P] = Q;\n  \tfather[Q] = P;\n}\n```\n\n\n\n### 核心操作：spaly\n\n把重要节点通过旋转操作转移为目标节点的父节点。一般为转移到根节点。\n\n####Splay代码\n\n```c++\nvoid splaQ(long P,long Ancestry){\n    while(father[P] != Ancestry){\n        long Q = father[P];\n        long Z = father[Q];\n        if(Z == Ancestry){ //父节点为目标节点\n            if(rightson[Q] == P)\n                left_rotate(P);\n            else\n                right_rotate(P);\n        }\n        else{//由左旋和右旋组合产生四种情况\n            if(rightson[Z] == Q && rightson[Q] == P){\n                left_rotate(Q);\n                left_rotate(P);\n            }\n            else if(rightson[Z] == Q && leftson[Q] == P){\n                right_rotate(P);\n                left_rotate(P);\n            }\n            else if(leftson[Z] == Q && leftson[Q] == P){\n                right_rotate(Q);\n                right_rotate(P);\n            }\n            else{\n                left_rotate(P);\n                right_rotate(P);\n            }\n        }\n    }\n    if(Ancestry == 0)\n        root = P;\n} \n```\n\n\n\n### 插入操作 insert\n\n1. 首先判断是否为空树。如果为空树，则初始化树。\n2. 判断节点值与插入值是否相等，相等则对此节点做相关操作，如数量加一；不相等，执行第3步。\n3. 比较节点值与插入值的大小，找的子节点。如果当前点节点不为空，执行第2步；为空则执行第4步。\n4. 新建节点，树总节点数量（全局变量）加一，初始化父亲节点和子节点，进行splay操作。\n\n#### insert代码\n\n```c++\nvoid insert(int x)\n{  \n    if (root==0){ //若当前为空树则直接加\n        tree[++sz].num=x;  \n        childsz[sz]=cnt[sz]=1; //size为该子树的节点数目，cnt为同一数值数字数目  \n        root = sz; //sz为整棵树的节点数目\n        return;    \n    }   \n    int now = root,fa = 0; //now,root等都为节点编号。\n    while (1){  \n        if (val[now] == x){ //相等，找到位置\n            tree[now].cnt++;  \n            splay(now);\n            return;  \n        }  \n        fa = now;  \n        now = (x>val[now]?rightson[now]:leftson[now]); //按大小找子节点\n        if (now == 0){ //该点未被添加过，新建节点\n            sz++; //节点新建了一个，作为节点编号\n            val[sz] = x;\n            cnt[sz] = childsize[sz] = 1;  \n            father[sz] = fa;  \n            (x > val[fa] ? rightson[fa] : leftson[fa]) = sz; //设置父亲                    \n            splay(sz);\n            return;\n        }  \n    }  \n}\n```\n\n\n\n###查找操作\n\n#### 查询某一值的排名\n\n和其它二叉搜索树的操作基本一样。但是区别是：\n\n1. 如果x比当前结点小，即应该向左子树寻找，ans不用改变（设想一下，走到整棵树的最左端最底端排名不就是1吗）。\n2. 如果x比当前结点大，即应该向右子树寻找，ans需要加上左子树的大小以及根的大小（这里的大小指的是权值）。\n\n不要忘记了再splay一下\n\n##### find 代码\n\n```c++\nint find(int v){\n    int ans = 0,now = root;\n    while (1){\n        if (v < val[now])\n            now = leftch[now];\n        else{\n            ans += (leftch[now] ? size[leftch[now]] : 0); \n            //左子树存在的话就为左子树大小，否则为0。\n            if (v == val[now]) {\n                splay(now);\n                return ans+1;\n            }\n            ans += cnt[now];//根的大小\n            now = rightch[now];\n        }\n    }\n    return ans;\n}\n```\n\n\n\n#### 查询排名为x的点\n\n如果当前点有左子树，并且x比左子树的大小小的话，即向左子树寻找；\n\n否则，向右子树寻找：先判断是否有右子树，然后记录右子树的大小以及当前点的大小（都为权值），用于判断是否需要继续向右子树寻找。\n\n##### findx 代码\n\n```c++\nint findx(int x){  \n    int now = root;  \n    while (1){  \n        if (leftch[now] && x <= size[leftch[now]])  \n            now = ch[now][0];  \n        else{  \n            int temp = (leftchch[now] ? size[leftch[now]] : 0) + cnt[now];  \n            if (x <= temp)  \n                return key[now];  \n            x -= temp;\n            now = rightch[now];  \n        }  \n    }  \n} \n```\n\n\n\n##感谢\n\nhttp://blog.csdn.net/clove_unique/article/details/50630280\n\nhttp://blog.csdn.net/skydec/article/details/20151805","source":"_posts/伸展树——Splay Tree .md","raw":"---\ntitle: 伸展树——Splay Tree\ndate: 2017-08-18 19:43:57\nmathjax: true\ntags: \n    - Splay\ncategories: Algorithm\n---\n\n# 伸展树——Splay Tree \n## 简单介绍\n**伸展树**（英语：Splay Tree）是一种二叉查找树，它能在$O(log(n))$内完成插入、查找和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和羅伯特·塔揚在1985年发明的。\n在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行調整，把被查找的条目搬移到离树根近一些的地方。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。\n它的优势在于不需要记录用于平衡树的冗余信息。\n\n## 目的\n\n把重要的树节点转移树根。使在最坏的情况下,查询时间复杂度仍然为$O(log(n))$。\n\n## 时间复杂度证明\n\n具体证明请看维基百科的。 [Splay tree - Wikipedia](https://en.wikipedia.org/wiki/Splay_tree)\n\n## 操作\n\n### 基本操作：旋转\n\n![](http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png)\n\n首先讲基本旋转之一右旋（zig）：\n\n解释下上面这个图，对于右旋，P为目标节点，Q为P的父节点，A、B、C则是相关子节点。右旋操作可以将P节点变为Q的父节点，且保持原有的二叉查询树的特性，即对于某一节点，其左子树的所有节点的值都小于该节点而右子树的所有节点的值都大于该节点。\n\n整个过程分为三步：\n\n1. 将P的右子树B(如果有的话)作Q的左子树，即让B认Q作爹\n2. 设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Q是Z的左儿子还是右儿子决定，要左右一致)\n3. 将Q作为P的右子树，即让Q认P作爹。\n\n####右旋代码：\n\n```c++\nvoid right_rotate(long P)\n{\n\tlong Q = father[P];\n\tlong Z = father[Q];//这里的z与上文的Q相关，表示y的父节点。\n    leftson[Q] = rightson[P];//第一步，将P的右子树B(如果有的话)作Q的左子树。\n    if(rightson[P] != 0)\n    \tfather[rightson[P]] = Q;//第一步，B认Q为父。\n    father[P] = Z;//第二步，P认Z做爹。\n    if(z != 0){\n\t\tif(leftson[Z] == y)//判断原来的Q是Z的左节点还是有节点。\n        \tleftson[Z] = P;//第二步,P做Z儿子。\n     \telse \n          \trightson[Z] = P;\n    }\n    rightson[P] = y;//第三步，Q作为P的右子树\n  \tfather[Q] = P;//第三步，Q认P作爹\n}\n```\n\n\n\n接着另一个旋转——左旋（zag）：\n\n有了上面右旋的基础，就直接说明步骤了：\n\n1. 将P的左子树B(如果有的话)作Q的右子树，即让B认Q作爹\n2. 设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Y是Z的左儿子还是右儿子决定，要左右一致)\n3. 将Q作为P的左子树，即让P认P作爹。\n\n#### 左旋代码：\n\n```c++\nvoid left_rotate(long P)\n{\n\tlong Q = father[P];\n\tlong Z = father[Q];\n\trightson[Q] = leftson[P];\n\tif(leftson[P] != 0)\n      \tfather[leftson[P]] = Q;\n\tfather[P]=Z;\n\tif(Z != 0){\n    \tif(leftson[Z] == Q)\n          \tleftson[Z] = P;\n      \telse \n          \trightson[Z] = P;\n\t}\n  \tleftson[P] = Q;\n  \tfather[Q] = P;\n}\n```\n\n\n\n### 核心操作：spaly\n\n把重要节点通过旋转操作转移为目标节点的父节点。一般为转移到根节点。\n\n####Splay代码\n\n```c++\nvoid splaQ(long P,long Ancestry){\n    while(father[P] != Ancestry){\n        long Q = father[P];\n        long Z = father[Q];\n        if(Z == Ancestry){ //父节点为目标节点\n            if(rightson[Q] == P)\n                left_rotate(P);\n            else\n                right_rotate(P);\n        }\n        else{//由左旋和右旋组合产生四种情况\n            if(rightson[Z] == Q && rightson[Q] == P){\n                left_rotate(Q);\n                left_rotate(P);\n            }\n            else if(rightson[Z] == Q && leftson[Q] == P){\n                right_rotate(P);\n                left_rotate(P);\n            }\n            else if(leftson[Z] == Q && leftson[Q] == P){\n                right_rotate(Q);\n                right_rotate(P);\n            }\n            else{\n                left_rotate(P);\n                right_rotate(P);\n            }\n        }\n    }\n    if(Ancestry == 0)\n        root = P;\n} \n```\n\n\n\n### 插入操作 insert\n\n1. 首先判断是否为空树。如果为空树，则初始化树。\n2. 判断节点值与插入值是否相等，相等则对此节点做相关操作，如数量加一；不相等，执行第3步。\n3. 比较节点值与插入值的大小，找的子节点。如果当前点节点不为空，执行第2步；为空则执行第4步。\n4. 新建节点，树总节点数量（全局变量）加一，初始化父亲节点和子节点，进行splay操作。\n\n#### insert代码\n\n```c++\nvoid insert(int x)\n{  \n    if (root==0){ //若当前为空树则直接加\n        tree[++sz].num=x;  \n        childsz[sz]=cnt[sz]=1; //size为该子树的节点数目，cnt为同一数值数字数目  \n        root = sz; //sz为整棵树的节点数目\n        return;    \n    }   \n    int now = root,fa = 0; //now,root等都为节点编号。\n    while (1){  \n        if (val[now] == x){ //相等，找到位置\n            tree[now].cnt++;  \n            splay(now);\n            return;  \n        }  \n        fa = now;  \n        now = (x>val[now]?rightson[now]:leftson[now]); //按大小找子节点\n        if (now == 0){ //该点未被添加过，新建节点\n            sz++; //节点新建了一个，作为节点编号\n            val[sz] = x;\n            cnt[sz] = childsize[sz] = 1;  \n            father[sz] = fa;  \n            (x > val[fa] ? rightson[fa] : leftson[fa]) = sz; //设置父亲                    \n            splay(sz);\n            return;\n        }  \n    }  \n}\n```\n\n\n\n###查找操作\n\n#### 查询某一值的排名\n\n和其它二叉搜索树的操作基本一样。但是区别是：\n\n1. 如果x比当前结点小，即应该向左子树寻找，ans不用改变（设想一下，走到整棵树的最左端最底端排名不就是1吗）。\n2. 如果x比当前结点大，即应该向右子树寻找，ans需要加上左子树的大小以及根的大小（这里的大小指的是权值）。\n\n不要忘记了再splay一下\n\n##### find 代码\n\n```c++\nint find(int v){\n    int ans = 0,now = root;\n    while (1){\n        if (v < val[now])\n            now = leftch[now];\n        else{\n            ans += (leftch[now] ? size[leftch[now]] : 0); \n            //左子树存在的话就为左子树大小，否则为0。\n            if (v == val[now]) {\n                splay(now);\n                return ans+1;\n            }\n            ans += cnt[now];//根的大小\n            now = rightch[now];\n        }\n    }\n    return ans;\n}\n```\n\n\n\n#### 查询排名为x的点\n\n如果当前点有左子树，并且x比左子树的大小小的话，即向左子树寻找；\n\n否则，向右子树寻找：先判断是否有右子树，然后记录右子树的大小以及当前点的大小（都为权值），用于判断是否需要继续向右子树寻找。\n\n##### findx 代码\n\n```c++\nint findx(int x){  \n    int now = root;  \n    while (1){  \n        if (leftch[now] && x <= size[leftch[now]])  \n            now = ch[now][0];  \n        else{  \n            int temp = (leftchch[now] ? size[leftch[now]] : 0) + cnt[now];  \n            if (x <= temp)  \n                return key[now];  \n            x -= temp;\n            now = rightch[now];  \n        }  \n    }  \n} \n```\n\n\n\n##感谢\n\nhttp://blog.csdn.net/clove_unique/article/details/50630280\n\nhttp://blog.csdn.net/skydec/article/details/20151805","slug":"伸展树——Splay Tree ","published":1,"updated":"2018-07-03T04:02:25.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvg0010plxpp5a9wr3r","content":"<h1 id=\"伸展树——Splay-Tree\"><a href=\"#伸展树——Splay-Tree\" class=\"headerlink\" title=\"伸展树——Splay Tree\"></a>伸展树——Splay Tree</h1><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p><strong>伸展树</strong>（英语：Splay Tree）是一种二叉查找树，它能在$O(log(n))$内完成插入、查找和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和羅伯特·塔揚在1985年发明的。<br>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行調整，把被查找的条目搬移到离树根近一些的地方。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。<br>它的优势在于不需要记录用于平衡树的冗余信息。</p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>把重要的树节点转移树根。使在最坏的情况下,查询时间复杂度仍然为$O(log(n))$。</p>\n<h2 id=\"时间复杂度证明\"><a href=\"#时间复杂度证明\" class=\"headerlink\" title=\"时间复杂度证明\"></a>时间复杂度证明</h2><p>具体证明请看维基百科的。 <a href=\"https://en.wikipedia.org/wiki/Splay_tree\" target=\"_blank\" rel=\"noopener\">Splay tree - Wikipedia</a></p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"基本操作：旋转\"><a href=\"#基本操作：旋转\" class=\"headerlink\" title=\"基本操作：旋转\"></a>基本操作：旋转</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png\" alt=\"\"></p>\n<p>首先讲基本旋转之一右旋（zig）：</p>\n<p>解释下上面这个图，对于右旋，P为目标节点，Q为P的父节点，A、B、C则是相关子节点。右旋操作可以将P节点变为Q的父节点，且保持原有的二叉查询树的特性，即对于某一节点，其左子树的所有节点的值都小于该节点而右子树的所有节点的值都大于该节点。</p>\n<p>整个过程分为三步：</p>\n<ol>\n<li>将P的右子树B(如果有的话)作Q的左子树，即让B认Q作爹</li>\n<li>设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Q是Z的左儿子还是右儿子决定，要左右一致)</li>\n<li>将Q作为P的右子树，即让Q认P作爹。</li>\n</ol>\n<p>####右旋代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">right_rotate</span><span class=\"params\">(<span class=\"keyword\">long</span> P)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Z = father[Q];<span class=\"comment\">//这里的z与上文的Q相关，表示y的父节点。</span></span><br><span class=\"line\">    leftson[Q] = rightson[P];<span class=\"comment\">//第一步，将P的右子树B(如果有的话)作Q的左子树。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rightson[P] != <span class=\"number\">0</span>)</span><br><span class=\"line\">    \tfather[rightson[P]] = Q;<span class=\"comment\">//第一步，B认Q为父。</span></span><br><span class=\"line\">    father[P] = Z;<span class=\"comment\">//第二步，P认Z做爹。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(z != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(leftson[Z] == y)<span class=\"comment\">//判断原来的Q是Z的左节点还是有节点。</span></span><br><span class=\"line\">        \tleftson[Z] = P;<span class=\"comment\">//第二步,P做Z儿子。</span></span><br><span class=\"line\">     \t<span class=\"keyword\">else</span> </span><br><span class=\"line\">          \trightson[Z] = P;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rightson[P] = y;<span class=\"comment\">//第三步，Q作为P的右子树</span></span><br><span class=\"line\">  \tfather[Q] = P;<span class=\"comment\">//第三步，Q认P作爹</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着另一个旋转——左旋（zag）：</p>\n<p>有了上面右旋的基础，就直接说明步骤了：</p>\n<ol>\n<li>将P的左子树B(如果有的话)作Q的右子树，即让B认Q作爹</li>\n<li>设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Y是Z的左儿子还是右儿子决定，要左右一致)</li>\n<li>将Q作为P的左子树，即让P认P作爹。</li>\n</ol>\n<h4 id=\"左旋代码：\"><a href=\"#左旋代码：\" class=\"headerlink\" title=\"左旋代码：\"></a>左旋代码：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">left_rotate</span><span class=\"params\">(<span class=\"keyword\">long</span> P)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Z = father[Q];</span><br><span class=\"line\">\trightson[Q] = leftson[P];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(leftson[P] != <span class=\"number\">0</span>)</span><br><span class=\"line\">      \tfather[leftson[P]] = Q;</span><br><span class=\"line\">\tfather[P]=Z;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Z != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(leftson[Z] == Q)</span><br><span class=\"line\">          \tleftson[Z] = P;</span><br><span class=\"line\">      \t<span class=\"keyword\">else</span> </span><br><span class=\"line\">          \trightson[Z] = P;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  \tleftson[P] = Q;</span><br><span class=\"line\">  \tfather[Q] = P;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"核心操作：spaly\"><a href=\"#核心操作：spaly\" class=\"headerlink\" title=\"核心操作：spaly\"></a>核心操作：spaly</h3><p>把重要节点通过旋转操作转移为目标节点的父节点。一般为转移到根节点。</p>\n<p>####Splay代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splaQ</span><span class=\"params\">(<span class=\"keyword\">long</span> P,<span class=\"keyword\">long</span> Ancestry)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(father[P] != Ancestry)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">        <span class=\"keyword\">long</span> Z = father[Q];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Z == Ancestry)&#123; <span class=\"comment\">//父节点为目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightson[Q] == P)</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//由左旋和右旋组合产生四种情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightson[Z] == Q &amp;&amp; rightson[Q] == P)&#123;</span><br><span class=\"line\">                left_rotate(Q);</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rightson[Z] == Q &amp;&amp; leftson[Q] == P)&#123;</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(leftson[Z] == Q &amp;&amp; leftson[Q] == P)&#123;</span><br><span class=\"line\">                right_rotate(Q);</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Ancestry == <span class=\"number\">0</span>)</span><br><span class=\"line\">        root = P;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作-insert\"><a href=\"#插入操作-insert\" class=\"headerlink\" title=\"插入操作 insert\"></a>插入操作 insert</h3><ol>\n<li>首先判断是否为空树。如果为空树，则初始化树。</li>\n<li>判断节点值与插入值是否相等，相等则对此节点做相关操作，如数量加一；不相等，执行第3步。</li>\n<li>比较节点值与插入值的大小，找的子节点。如果当前点节点不为空，执行第2步；为空则执行第4步。</li>\n<li>新建节点，树总节点数量（全局变量）加一，初始化父亲节点和子节点，进行splay操作。</li>\n</ol>\n<h4 id=\"insert代码\"><a href=\"#insert代码\" class=\"headerlink\" title=\"insert代码\"></a>insert代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"number\">0</span>)&#123; <span class=\"comment\">//若当前为空树则直接加</span></span><br><span class=\"line\">        tree[++sz].num=x;  </span><br><span class=\"line\">        childsz[sz]=cnt[sz]=<span class=\"number\">1</span>; <span class=\"comment\">//size为该子树的节点数目，cnt为同一数值数字数目  </span></span><br><span class=\"line\">        root = sz; <span class=\"comment\">//sz为整棵树的节点数目</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;    </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = root,fa = <span class=\"number\">0</span>; <span class=\"comment\">//now,root等都为节点编号。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val[now] == x)&#123; <span class=\"comment\">//相等，找到位置</span></span><br><span class=\"line\">            tree[now].cnt++;  </span><br><span class=\"line\">            splay(now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        fa = now;  </span><br><span class=\"line\">        now = (x&gt;val[now]?rightson[now]:leftson[now]); <span class=\"comment\">//按大小找子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//该点未被添加过，新建节点</span></span><br><span class=\"line\">            sz++; <span class=\"comment\">//节点新建了一个，作为节点编号</span></span><br><span class=\"line\">            val[sz] = x;</span><br><span class=\"line\">            cnt[sz] = childsize[sz] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">            father[sz] = fa;  </span><br><span class=\"line\">            (x &gt; val[fa] ? rightson[fa] : leftson[fa]) = sz; <span class=\"comment\">//设置父亲                    </span></span><br><span class=\"line\">            splay(sz);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###查找操作</p>\n<h4 id=\"查询某一值的排名\"><a href=\"#查询某一值的排名\" class=\"headerlink\" title=\"查询某一值的排名\"></a>查询某一值的排名</h4><p>和其它二叉搜索树的操作基本一样。但是区别是：</p>\n<ol>\n<li>如果x比当前结点小，即应该向左子树寻找，ans不用改变（设想一下，走到整棵树的最左端最底端排名不就是1吗）。</li>\n<li>如果x比当前结点大，即应该向右子树寻找，ans需要加上左子树的大小以及根的大小（这里的大小指的是权值）。</li>\n</ol>\n<p>不要忘记了再splay一下</p>\n<h5 id=\"find-代码\"><a href=\"#find-代码\" class=\"headerlink\" title=\"find 代码\"></a>find 代码</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>,now = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v &lt; val[now])</span><br><span class=\"line\">            now = leftch[now];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans += (leftch[now] ? size[leftch[now]] : <span class=\"number\">0</span>); </span><br><span class=\"line\">            <span class=\"comment\">//左子树存在的话就为左子树大小，否则为0。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == val[now]) &#123;</span><br><span class=\"line\">                splay(now);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ans+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += cnt[now];<span class=\"comment\">//根的大小</span></span><br><span class=\"line\">            now = rightch[now];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询排名为x的点\"><a href=\"#查询排名为x的点\" class=\"headerlink\" title=\"查询排名为x的点\"></a>查询排名为x的点</h4><p>如果当前点有左子树，并且x比左子树的大小小的话，即向左子树寻找；</p>\n<p>否则，向右子树寻找：先判断是否有右子树，然后记录右子树的大小以及当前点的大小（都为权值），用于判断是否需要继续向右子树寻找。</p>\n<h5 id=\"findx-代码\"><a href=\"#findx-代码\" class=\"headerlink\" title=\"findx 代码\"></a>findx 代码</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findx</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = root;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftch[now] &amp;&amp; x &lt;= size[leftch[now]])  </span><br><span class=\"line\">            now = ch[now][<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = (leftchch[now] ? size[leftch[now]] : <span class=\"number\">0</span>) + cnt[now];  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt;= temp)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> key[now];  </span><br><span class=\"line\">            x -= temp;</span><br><span class=\"line\">            now = rightch[now];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##感谢</p>\n<p><a href=\"http://blog.csdn.net/clove_unique/article/details/50630280\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/clove_unique/article/details/50630280</a></p>\n<p><a href=\"http://blog.csdn.net/skydec/article/details/20151805\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/skydec/article/details/20151805</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"伸展树——Splay-Tree\"><a href=\"#伸展树——Splay-Tree\" class=\"headerlink\" title=\"伸展树——Splay Tree\"></a>伸展树——Splay Tree</h1><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p><strong>伸展树</strong>（英语：Splay Tree）是一种二叉查找树，它能在$O(log(n))$内完成插入、查找和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和羅伯特·塔揚在1985年发明的。<br>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行調整，把被查找的条目搬移到离树根近一些的地方。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。<br>它的优势在于不需要记录用于平衡树的冗余信息。</p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>把重要的树节点转移树根。使在最坏的情况下,查询时间复杂度仍然为$O(log(n))$。</p>\n<h2 id=\"时间复杂度证明\"><a href=\"#时间复杂度证明\" class=\"headerlink\" title=\"时间复杂度证明\"></a>时间复杂度证明</h2><p>具体证明请看维基百科的。 <a href=\"https://en.wikipedia.org/wiki/Splay_tree\" target=\"_blank\" rel=\"noopener\">Splay tree - Wikipedia</a></p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"基本操作：旋转\"><a href=\"#基本操作：旋转\" class=\"headerlink\" title=\"基本操作：旋转\"></a>基本操作：旋转</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png\" alt=\"\"></p>\n<p>首先讲基本旋转之一右旋（zig）：</p>\n<p>解释下上面这个图，对于右旋，P为目标节点，Q为P的父节点，A、B、C则是相关子节点。右旋操作可以将P节点变为Q的父节点，且保持原有的二叉查询树的特性，即对于某一节点，其左子树的所有节点的值都小于该节点而右子树的所有节点的值都大于该节点。</p>\n<p>整个过程分为三步：</p>\n<ol>\n<li>将P的右子树B(如果有的话)作Q的左子树，即让B认Q作爹</li>\n<li>设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Q是Z的左儿子还是右儿子决定，要左右一致)</li>\n<li>将Q作为P的右子树，即让Q认P作爹。</li>\n</ol>\n<p>####右旋代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">right_rotate</span><span class=\"params\">(<span class=\"keyword\">long</span> P)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Z = father[Q];<span class=\"comment\">//这里的z与上文的Q相关，表示y的父节点。</span></span><br><span class=\"line\">    leftson[Q] = rightson[P];<span class=\"comment\">//第一步，将P的右子树B(如果有的话)作Q的左子树。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rightson[P] != <span class=\"number\">0</span>)</span><br><span class=\"line\">    \tfather[rightson[P]] = Q;<span class=\"comment\">//第一步，B认Q为父。</span></span><br><span class=\"line\">    father[P] = Z;<span class=\"comment\">//第二步，P认Z做爹。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(z != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(leftson[Z] == y)<span class=\"comment\">//判断原来的Q是Z的左节点还是有节点。</span></span><br><span class=\"line\">        \tleftson[Z] = P;<span class=\"comment\">//第二步,P做Z儿子。</span></span><br><span class=\"line\">     \t<span class=\"keyword\">else</span> </span><br><span class=\"line\">          \trightson[Z] = P;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rightson[P] = y;<span class=\"comment\">//第三步，Q作为P的右子树</span></span><br><span class=\"line\">  \tfather[Q] = P;<span class=\"comment\">//第三步，Q认P作爹</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着另一个旋转——左旋（zag）：</p>\n<p>有了上面右旋的基础，就直接说明步骤了：</p>\n<ol>\n<li>将P的左子树B(如果有的话)作Q的右子树，即让B认Q作爹</li>\n<li>设Z为原本Q结点的父亲，让P认Z做爹(如果Z存在的话)，即将P作为Z的儿子(是左是右得由Y是Z的左儿子还是右儿子决定，要左右一致)</li>\n<li>将Q作为P的左子树，即让P认P作爹。</li>\n</ol>\n<h4 id=\"左旋代码：\"><a href=\"#左旋代码：\" class=\"headerlink\" title=\"左旋代码：\"></a>左旋代码：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">left_rotate</span><span class=\"params\">(<span class=\"keyword\">long</span> P)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> Z = father[Q];</span><br><span class=\"line\">\trightson[Q] = leftson[P];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(leftson[P] != <span class=\"number\">0</span>)</span><br><span class=\"line\">      \tfather[leftson[P]] = Q;</span><br><span class=\"line\">\tfather[P]=Z;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Z != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(leftson[Z] == Q)</span><br><span class=\"line\">          \tleftson[Z] = P;</span><br><span class=\"line\">      \t<span class=\"keyword\">else</span> </span><br><span class=\"line\">          \trightson[Z] = P;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  \tleftson[P] = Q;</span><br><span class=\"line\">  \tfather[Q] = P;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"核心操作：spaly\"><a href=\"#核心操作：spaly\" class=\"headerlink\" title=\"核心操作：spaly\"></a>核心操作：spaly</h3><p>把重要节点通过旋转操作转移为目标节点的父节点。一般为转移到根节点。</p>\n<p>####Splay代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splaQ</span><span class=\"params\">(<span class=\"keyword\">long</span> P,<span class=\"keyword\">long</span> Ancestry)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(father[P] != Ancestry)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> Q = father[P];</span><br><span class=\"line\">        <span class=\"keyword\">long</span> Z = father[Q];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Z == Ancestry)&#123; <span class=\"comment\">//父节点为目标节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightson[Q] == P)</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//由左旋和右旋组合产生四种情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightson[Z] == Q &amp;&amp; rightson[Q] == P)&#123;</span><br><span class=\"line\">                left_rotate(Q);</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rightson[Z] == Q &amp;&amp; leftson[Q] == P)&#123;</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(leftson[Z] == Q &amp;&amp; leftson[Q] == P)&#123;</span><br><span class=\"line\">                right_rotate(Q);</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left_rotate(P);</span><br><span class=\"line\">                right_rotate(P);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Ancestry == <span class=\"number\">0</span>)</span><br><span class=\"line\">        root = P;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作-insert\"><a href=\"#插入操作-insert\" class=\"headerlink\" title=\"插入操作 insert\"></a>插入操作 insert</h3><ol>\n<li>首先判断是否为空树。如果为空树，则初始化树。</li>\n<li>判断节点值与插入值是否相等，相等则对此节点做相关操作，如数量加一；不相等，执行第3步。</li>\n<li>比较节点值与插入值的大小，找的子节点。如果当前点节点不为空，执行第2步；为空则执行第4步。</li>\n<li>新建节点，树总节点数量（全局变量）加一，初始化父亲节点和子节点，进行splay操作。</li>\n</ol>\n<h4 id=\"insert代码\"><a href=\"#insert代码\" class=\"headerlink\" title=\"insert代码\"></a>insert代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root==<span class=\"number\">0</span>)&#123; <span class=\"comment\">//若当前为空树则直接加</span></span><br><span class=\"line\">        tree[++sz].num=x;  </span><br><span class=\"line\">        childsz[sz]=cnt[sz]=<span class=\"number\">1</span>; <span class=\"comment\">//size为该子树的节点数目，cnt为同一数值数字数目  </span></span><br><span class=\"line\">        root = sz; <span class=\"comment\">//sz为整棵树的节点数目</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;    </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = root,fa = <span class=\"number\">0</span>; <span class=\"comment\">//now,root等都为节点编号。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val[now] == x)&#123; <span class=\"comment\">//相等，找到位置</span></span><br><span class=\"line\">            tree[now].cnt++;  </span><br><span class=\"line\">            splay(now);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        fa = now;  </span><br><span class=\"line\">        now = (x&gt;val[now]?rightson[now]:leftson[now]); <span class=\"comment\">//按大小找子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//该点未被添加过，新建节点</span></span><br><span class=\"line\">            sz++; <span class=\"comment\">//节点新建了一个，作为节点编号</span></span><br><span class=\"line\">            val[sz] = x;</span><br><span class=\"line\">            cnt[sz] = childsize[sz] = <span class=\"number\">1</span>;  </span><br><span class=\"line\">            father[sz] = fa;  </span><br><span class=\"line\">            (x &gt; val[fa] ? rightson[fa] : leftson[fa]) = sz; <span class=\"comment\">//设置父亲                    </span></span><br><span class=\"line\">            splay(sz);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###查找操作</p>\n<h4 id=\"查询某一值的排名\"><a href=\"#查询某一值的排名\" class=\"headerlink\" title=\"查询某一值的排名\"></a>查询某一值的排名</h4><p>和其它二叉搜索树的操作基本一样。但是区别是：</p>\n<ol>\n<li>如果x比当前结点小，即应该向左子树寻找，ans不用改变（设想一下，走到整棵树的最左端最底端排名不就是1吗）。</li>\n<li>如果x比当前结点大，即应该向右子树寻找，ans需要加上左子树的大小以及根的大小（这里的大小指的是权值）。</li>\n</ol>\n<p>不要忘记了再splay一下</p>\n<h5 id=\"find-代码\"><a href=\"#find-代码\" class=\"headerlink\" title=\"find 代码\"></a>find 代码</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>,now = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v &lt; val[now])</span><br><span class=\"line\">            now = leftch[now];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans += (leftch[now] ? size[leftch[now]] : <span class=\"number\">0</span>); </span><br><span class=\"line\">            <span class=\"comment\">//左子树存在的话就为左子树大小，否则为0。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v == val[now]) &#123;</span><br><span class=\"line\">                splay(now);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ans+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += cnt[now];<span class=\"comment\">//根的大小</span></span><br><span class=\"line\">            now = rightch[now];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询排名为x的点\"><a href=\"#查询排名为x的点\" class=\"headerlink\" title=\"查询排名为x的点\"></a>查询排名为x的点</h4><p>如果当前点有左子树，并且x比左子树的大小小的话，即向左子树寻找；</p>\n<p>否则，向右子树寻找：先判断是否有右子树，然后记录右子树的大小以及当前点的大小（都为权值），用于判断是否需要继续向右子树寻找。</p>\n<h5 id=\"findx-代码\"><a href=\"#findx-代码\" class=\"headerlink\" title=\"findx 代码\"></a>findx 代码</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findx</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> now = root;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftch[now] &amp;&amp; x &lt;= size[leftch[now]])  </span><br><span class=\"line\">            now = ch[now][<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = (leftchch[now] ? size[leftch[now]] : <span class=\"number\">0</span>) + cnt[now];  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt;= temp)  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> key[now];  </span><br><span class=\"line\">            x -= temp;</span><br><span class=\"line\">            now = rightch[now];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##感谢</p>\n<p><a href=\"http://blog.csdn.net/clove_unique/article/details/50630280\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/clove_unique/article/details/50630280</a></p>\n<p><a href=\"http://blog.csdn.net/skydec/article/details/20151805\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/skydec/article/details/20151805</a></p>\n"},{"title":"51nod 威佐夫博奕（Wythoff Game）","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n*类型：Wythoff Game*\n\n### 描述：\n\n​\t有2堆石子。A，B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。\n\n#### 例如：\n\n​\t2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。\n\n### 题解：\n\n我们用，，，，表示两堆物品的数量并称其为**局势**，如果甲面对(0,0)，那么甲已经输了，这种局势我们称为**奇异局势**。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。\n\n可以看出，`$a_0=b_0=0$ 、 $ a_k$是未在前面出现过的最小自然数,而 $b_k= a_k + k$`，奇异局势有如下三条性质:\n\n> 1.任何自然数都包含在一个且仅有一个奇异局势中。\n\n由于是未在前面出现过的最小自然数，所以有，而  。所以性质1成立。\n\n> 2.任意操作都可将奇异局势变为非奇异局势。\n\n事实上，若只改变奇异局势（，）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（，）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。\n\n> 3.采用适当的方法，可以将非奇异局势变为奇异局势。\n\n假设面对的局势是（），若，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果，，那么，取走个物体，即变为奇异局势；如果 ， ,则同时从两堆中拿走个物体,变为奇异局势；如果，则从第一堆中拿走多余的数量即可；如果， ，分两种情况，第一种，,从第二里面拿走  即可；第二种，,从第二堆里面拿走 即可。\n\n从如上性质可知，两个人如果都采用正确操作，那么**面对非奇异局势，先拿者必胜**；反之，则后拿者取胜。\n\n那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：\n\n，，方括号表示取整函数奇妙的是其中出现了黄金分割数,因此发现对于任意的局势(a,b)，a<b, 根据上述公式，其中k明显为a与b的差值，也正是根据这个差值来确认（a，b）是否为奇异局势。具体过程为，如果则为奇异局势。\n\n### 代码：\n\n```c++\ninclude <stdio.h>\ninclude <math.h>\ninclude <iostream>\nusing namespace std;\nint main() {\n    int t, a, b, m;\n    cin >> t;\n    while (t--) {\n        cin >> a >> b;\n        if (a > b)\n            swap(a,b);\n        m = (int)((b-a) * (1 + sqrt(5)) / 2.0);\n        printf(\"%s\\n\", a == m ? \"B\" : \"A\");\n    }\n    return 0;\n}\n```\n\n","source":"_posts/威佐夫博奕（Wythoff Game）.md","raw":"---\ntitle: 51nod 威佐夫博奕（Wythoff Game）\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 博弈\n    - 威佐夫博奕（Wythoff Game）\ncategories: Algorithm\n---\n\n*类型：Wythoff Game*\n\n### 描述：\n\n​\t有2堆石子。A，B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。\n\n#### 例如：\n\n​\t2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。\n\n### 题解：\n\n我们用，，，，表示两堆物品的数量并称其为**局势**，如果甲面对(0,0)，那么甲已经输了，这种局势我们称为**奇异局势**。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。\n\n可以看出，`$a_0=b_0=0$ 、 $ a_k$是未在前面出现过的最小自然数,而 $b_k= a_k + k$`，奇异局势有如下三条性质:\n\n> 1.任何自然数都包含在一个且仅有一个奇异局势中。\n\n由于是未在前面出现过的最小自然数，所以有，而  。所以性质1成立。\n\n> 2.任意操作都可将奇异局势变为非奇异局势。\n\n事实上，若只改变奇异局势（，）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（，）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。\n\n> 3.采用适当的方法，可以将非奇异局势变为奇异局势。\n\n假设面对的局势是（），若，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果，，那么，取走个物体，即变为奇异局势；如果 ， ,则同时从两堆中拿走个物体,变为奇异局势；如果，则从第一堆中拿走多余的数量即可；如果， ，分两种情况，第一种，,从第二里面拿走  即可；第二种，,从第二堆里面拿走 即可。\n\n从如上性质可知，两个人如果都采用正确操作，那么**面对非奇异局势，先拿者必胜**；反之，则后拿者取胜。\n\n那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：\n\n，，方括号表示取整函数奇妙的是其中出现了黄金分割数,因此发现对于任意的局势(a,b)，a<b, 根据上述公式，其中k明显为a与b的差值，也正是根据这个差值来确认（a，b）是否为奇异局势。具体过程为，如果则为奇异局势。\n\n### 代码：\n\n```c++\ninclude <stdio.h>\ninclude <math.h>\ninclude <iostream>\nusing namespace std;\nint main() {\n    int t, a, b, m;\n    cin >> t;\n    while (t--) {\n        cin >> a >> b;\n        if (a > b)\n            swap(a,b);\n        m = (int)((b-a) * (1 + sqrt(5)) / 2.0);\n        printf(\"%s\\n\", a == m ? \"B\" : \"A\");\n    }\n    return 0;\n}\n```\n\n","slug":"威佐夫博奕（Wythoff Game）","published":1,"updated":"2018-07-03T06:29:49.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvi0012plxpjdq93aku","content":"<p><em>类型：Wythoff Game</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>​    有2堆石子。A，B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>​    2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>我们用，，，，表示两堆物品的数量并称其为<strong>局势</strong>，如果甲面对(0,0)，那么甲已经输了，这种局势我们称为<strong>奇异局势</strong>。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。</p>\n<p>可以看出，<code>$a_0=b_0=0$ 、 $ a_k$是未在前面出现过的最小自然数,而 $b_k= a_k + k$</code>，奇异局势有如下三条性质:</p>\n<blockquote>\n<p>1.任何自然数都包含在一个且仅有一个奇异局势中。</p>\n</blockquote>\n<p>由于是未在前面出现过的最小自然数，所以有，而  。所以性质1成立。</p>\n<blockquote>\n<p>2.任意操作都可将奇异局势变为非奇异局势。</p>\n</blockquote>\n<p>事实上，若只改变奇异局势（，）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（，）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。</p>\n<blockquote>\n<p>3.采用适当的方法，可以将非奇异局势变为奇异局势。</p>\n</blockquote>\n<p>假设面对的局势是（），若，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果，，那么，取走个物体，即变为奇异局势；如果 ， ,则同时从两堆中拿走个物体,变为奇异局势；如果，则从第一堆中拿走多余的数量即可；如果， ，分两种情况，第一种，,从第二里面拿走  即可；第二种，,从第二堆里面拿走 即可。</p>\n<p>从如上性质可知，两个人如果都采用正确操作，那么<strong>面对非奇异局势，先拿者必胜</strong>；反之，则后拿者取胜。</p>\n<p>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</p>\n<p>，，方括号表示取整函数奇妙的是其中出现了黄金分割数,因此发现对于任意的局势(a,b)，a&lt;b, 根据上述公式，其中k明显为a与b的差值，也正是根据这个差值来确认（a，b）是否为奇异局势。具体过程为，如果则为奇异局势。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\">include &lt;math.h&gt;</span><br><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, a, b, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b)</span><br><span class=\"line\">            swap(a,b);</span><br><span class=\"line\">        m = (<span class=\"keyword\">int</span>)((b-a) * (<span class=\"number\">1</span> + <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>)) / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, a == m ? <span class=\"string\">\"B\"</span> : <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>类型：Wythoff Game</em></p>\n<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>​    有2堆石子。A，B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>​    2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>我们用，，，，表示两堆物品的数量并称其为<strong>局势</strong>，如果甲面对(0,0)，那么甲已经输了，这种局势我们称为<strong>奇异局势</strong>。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。</p>\n<p>可以看出，<code>$a_0=b_0=0$ 、 $ a_k$是未在前面出现过的最小自然数,而 $b_k= a_k + k$</code>，奇异局势有如下三条性质:</p>\n<blockquote>\n<p>1.任何自然数都包含在一个且仅有一个奇异局势中。</p>\n</blockquote>\n<p>由于是未在前面出现过的最小自然数，所以有，而  。所以性质1成立。</p>\n<blockquote>\n<p>2.任意操作都可将奇异局势变为非奇异局势。</p>\n</blockquote>\n<p>事实上，若只改变奇异局势（，）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（，）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。</p>\n<blockquote>\n<p>3.采用适当的方法，可以将非奇异局势变为奇异局势。</p>\n</blockquote>\n<p>假设面对的局势是（），若，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果，，那么，取走个物体，即变为奇异局势；如果 ， ,则同时从两堆中拿走个物体,变为奇异局势；如果，则从第一堆中拿走多余的数量即可；如果， ，分两种情况，第一种，,从第二里面拿走  即可；第二种，,从第二堆里面拿走 即可。</p>\n<p>从如上性质可知，两个人如果都采用正确操作，那么<strong>面对非奇异局势，先拿者必胜</strong>；反之，则后拿者取胜。</p>\n<p>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</p>\n<p>，，方括号表示取整函数奇妙的是其中出现了黄金分割数,因此发现对于任意的局势(a,b)，a&lt;b, 根据上述公式，其中k明显为a与b的差值，也正是根据这个差值来确认（a，b）是否为奇异局势。具体过程为，如果则为奇异局势。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\">include &lt;math.h&gt;</span><br><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, a, b, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b)</span><br><span class=\"line\">            swap(a,b);</span><br><span class=\"line\">        m = (<span class=\"keyword\">int</span>)((b-a) * (<span class=\"number\">1</span> + <span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>)) / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, a == m ? <span class=\"string\">\"B\"</span> : <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"容斥原理","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n### 描述\n\n**容斥原理的简单描述如下：**\n\n要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。简单的说，就是对所有单个集合求和后减去单数个集合相交部分，加上双数集合相交部分。\n\n**原理公式:**\n\n$$ |\\bigcup A_i|=\\sum_{1\\leq i \\leq m} |A_i|-\\sum_{1\\leq i \\leq j \\leq m} |A_i \\cap A_j|+\\sum_{1\\leq i \\leq j \\leq k \\leq m} |A_i \\cap A_j \\cap A_k|- \\cdots +(-1)^{m+1} \\sum |A_1 \\cap A_2 \\cap A_3 \\cap A_4\\cdots\\cap A_m| $$\n\n## 例题\n\n给定$a_1,a_2,a_3,\\cdots ,a_m$ ，求1到n的整数中至少能整除a中一个元素有几个？\n\n### 代码：\n\n```c++\ninclude <iostream>\n\nusing namespace std;\n\nint a[4] = {2,3,5,7};\nint n = 100,m = 4;\n\ntypedef long long ll;\nll gcd(ll a,ll b){\n    ll t;\n    if (!a || !b)return 0;\n    if (a < b){t = b; b = a; a = t;}\n    while (b != 0 ){ t = a % b; a = b; b = t;}\n    return a;\n}\nvoid solve(){\n    ll res = 0;\n    for (int i = 1; i < (1 << m); i++){\n        int num = 0;\n        for(int j = i;j != 0; j >>= 1)\n            num += j & 1;\n        ll lcm = 1;\n        for (int j = 0; j < m; j++){\n            if (i >> j & 1){\n                lcm = lcm /gcd(lcm,a[j]) * a[j];\n                if (lcm > n) break;\n            }\n        }\n        if (num % 2 == 0) res -= n /lcm;\n        else res += n / lcm;\n        cout << res <<endl;\n    }\n    cout << res <<endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n```\n\n","source":"_posts/容斥原理.md","raw":"---\ntitle: 容斥原理\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 组合数学\n    - 容斥原理\ncategories: Algorithm\n---\n\n### 描述\n\n**容斥原理的简单描述如下：**\n\n要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。简单的说，就是对所有单个集合求和后减去单数个集合相交部分，加上双数集合相交部分。\n\n**原理公式:**\n\n$$ |\\bigcup A_i|=\\sum_{1\\leq i \\leq m} |A_i|-\\sum_{1\\leq i \\leq j \\leq m} |A_i \\cap A_j|+\\sum_{1\\leq i \\leq j \\leq k \\leq m} |A_i \\cap A_j \\cap A_k|- \\cdots +(-1)^{m+1} \\sum |A_1 \\cap A_2 \\cap A_3 \\cap A_4\\cdots\\cap A_m| $$\n\n## 例题\n\n给定$a_1,a_2,a_3,\\cdots ,a_m$ ，求1到n的整数中至少能整除a中一个元素有几个？\n\n### 代码：\n\n```c++\ninclude <iostream>\n\nusing namespace std;\n\nint a[4] = {2,3,5,7};\nint n = 100,m = 4;\n\ntypedef long long ll;\nll gcd(ll a,ll b){\n    ll t;\n    if (!a || !b)return 0;\n    if (a < b){t = b; b = a; a = t;}\n    while (b != 0 ){ t = a % b; a = b; b = t;}\n    return a;\n}\nvoid solve(){\n    ll res = 0;\n    for (int i = 1; i < (1 << m); i++){\n        int num = 0;\n        for(int j = i;j != 0; j >>= 1)\n            num += j & 1;\n        ll lcm = 1;\n        for (int j = 0; j < m; j++){\n            if (i >> j & 1){\n                lcm = lcm /gcd(lcm,a[j]) * a[j];\n                if (lcm > n) break;\n            }\n        }\n        if (num % 2 == 0) res -= n /lcm;\n        else res += n / lcm;\n        cout << res <<endl;\n    }\n    cout << res <<endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n```\n\n","slug":"容斥原理","published":1,"updated":"2018-07-03T06:29:48.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvk0015plxphf73vnej","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p><strong>容斥原理的简单描述如下：</strong></p>\n<p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。简单的说，就是对所有单个集合求和后减去单数个集合相交部分，加上双数集合相交部分。</p>\n<p><strong>原理公式:</strong></p>\n<p>$$ |\\bigcup A_i|=\\sum_{1\\leq i \\leq m} |A_i|-\\sum_{1\\leq i \\leq j \\leq m} |A_i \\cap A_j|+\\sum_{1\\leq i \\leq j \\leq k \\leq m} |A_i \\cap A_j \\cap A_k|- \\cdots +(-1)^{m+1} \\sum |A_1 \\cap A_2 \\cap A_3 \\cap A_4\\cdots\\cap A_m| $$</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>给定$a_1,a_2,a_3,\\cdots ,a_m$ ，求1到n的整数中至少能整除a中一个元素有几个？</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">100</span>,m = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">gcd</span><span class=\"params\">(ll a,ll b)</span></span>&#123;</span><br><span class=\"line\">    ll t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!a || !b)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a &lt; b)&#123;t = b; b = a; a = t;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b != <span class=\"number\">0</span> )&#123; t = a % b; a = b; b = t;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; m); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j != <span class=\"number\">0</span>; j &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            num += j &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        ll lcm = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;&gt; j &amp; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                lcm = lcm /gcd(lcm,a[j]) * a[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lcm &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num % <span class=\"number\">2</span> == <span class=\"number\">0</span>) res -= n /lcm;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> res += n / lcm;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p><strong>容斥原理的简单描述如下：</strong></p>\n<p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。简单的说，就是对所有单个集合求和后减去单数个集合相交部分，加上双数集合相交部分。</p>\n<p><strong>原理公式:</strong></p>\n<p>$$ |\\bigcup A_i|=\\sum_{1\\leq i \\leq m} |A_i|-\\sum_{1\\leq i \\leq j \\leq m} |A_i \\cap A_j|+\\sum_{1\\leq i \\leq j \\leq k \\leq m} |A_i \\cap A_j \\cap A_k|- \\cdots +(-1)^{m+1} \\sum |A_1 \\cap A_2 \\cap A_3 \\cap A_4\\cdots\\cap A_m| $$</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>给定$a_1,a_2,a_3,\\cdots ,a_m$ ，求1到n的整数中至少能整除a中一个元素有几个？</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">100</span>,m = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">gcd</span><span class=\"params\">(ll a,ll b)</span></span>&#123;</span><br><span class=\"line\">    ll t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!a || !b)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a &lt; b)&#123;t = b; b = a; a = t;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b != <span class=\"number\">0</span> )&#123; t = a % b; a = b; b = t;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; m); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j != <span class=\"number\">0</span>; j &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            num += j &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        ll lcm = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;&gt; j &amp; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                lcm = lcm /gcd(lcm,a[j]) * a[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lcm &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num % <span class=\"number\">2</span> == <span class=\"number\">0</span>) res -= n /lcm;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> res += n / lcm;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"51nod 巴什博奕（Bash Game）","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n### 描述：\n\n有一堆石子共有N个。A，B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。\n\n#### 例如：\n\nN = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。\n\n### 题解：\n\n显然，如果N=K+1，那么由于一次最多只能取K个，所以，无论A拿走多少个，B都能够一次拿走剩余的物品，B取胜。因此我们发现了如何取胜的法则：如果，（X为任意自然数，Y≤K)，那么A要拿走Y个物品，如果B拿走T（T≤K)个，那么A再拿走个，结果剩下个，以后保持这样的取法，那么A肯定获胜。总之，要保持给对手留下的倍数，就能最后获胜。\n\n#### 扩展：\n\n这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。\n\n### 代码：\n\n```c++\ninclude<stdio.h>\nint main()\n{\n    long long N,K;\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%lld%lld\",&N,&K);\n        if(N % (K + 1))\n            printf(\"A\\n\");\n        else\n            printf(\"B\\n\");\n    }\n}\n```\n\n","source":"_posts/巴什博奕（Bash Game）.md","raw":"---\ntitle: 51nod 巴什博奕（Bash Game）\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 博弈\n    - 巴什博奕（Bash Game）\ncategories: Algorithm\n---\n\n### 描述：\n\n有一堆石子共有N个。A，B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。\n\n#### 例如：\n\nN = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。\n\n### 题解：\n\n显然，如果N=K+1，那么由于一次最多只能取K个，所以，无论A拿走多少个，B都能够一次拿走剩余的物品，B取胜。因此我们发现了如何取胜的法则：如果，（X为任意自然数，Y≤K)，那么A要拿走Y个物品，如果B拿走T（T≤K)个，那么A再拿走个，结果剩下个，以后保持这样的取法，那么A肯定获胜。总之，要保持给对手留下的倍数，就能最后获胜。\n\n#### 扩展：\n\n这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。\n\n### 代码：\n\n```c++\ninclude<stdio.h>\nint main()\n{\n    long long N,K;\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%lld%lld\",&N,&K);\n        if(N % (K + 1))\n            printf(\"A\\n\");\n        else\n            printf(\"B\\n\");\n    }\n}\n```\n\n","slug":"巴什博奕（Bash Game）","published":1,"updated":"2018-07-03T06:29:47.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvm0018plxpskv7pv3g","content":"<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有一堆石子共有N个。A，B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>显然，如果N=K+1，那么由于一次最多只能取K个，所以，无论A拿走多少个，B都能够一次拿走剩余的物品，B取胜。因此我们发现了如何取胜的法则：如果，（X为任意自然数，Y≤K)，那么A要拿走Y个物品，如果B拿走T（T≤K)个，那么A再拿走个，结果剩下个，以后保持这样的取法，那么A肯定获胜。总之，要保持给对手留下的倍数，就能最后获胜。</p>\n<h4 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h4><p>这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N,K;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld\"</span>,&amp;N,&amp;K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(N % (K + <span class=\"number\">1</span>))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"A\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"描述：\"><a href=\"#描述：\" class=\"headerlink\" title=\"描述：\"></a>描述：</h3><p>有一堆石子共有N个。A，B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。</p>\n<h4 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h4><p>N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>显然，如果N=K+1，那么由于一次最多只能取K个，所以，无论A拿走多少个，B都能够一次拿走剩余的物品，B取胜。因此我们发现了如何取胜的法则：如果，（X为任意自然数，Y≤K)，那么A要拿走Y个物品，如果B拿走T（T≤K)个，那么A再拿走个，结果剩下个，以后保持这样的取法，那么A肯定获胜。总之，要保持给对手留下的倍数，就能最后获胜。</p>\n<h4 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h4><p>这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include&lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N,K;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld\"</span>,&amp;N,&amp;K);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(N % (K + <span class=\"number\">1</span>))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"A\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"康托展开","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n## 定义：\n\n康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。\n\n## 公式：\n\n$$X=a_n(n-1)!+a_{n-1}(n-2)!+\\ldots+a_1\\cdot0! + 1$$\n\n其中，$a_i$为整数，并且$0\\le a_i \\le i,1\\le i \\le n.$\n\n## 用途：\n\nn位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出唯一的一个排列。\n\n## 举例：\n\n对于一个有n个不同元素的集合${1,2,3,4,\\dots,n}$的从小到大排序（从大到小 同理）的全排列 显然它有$n！$项。如n=4，那么就有$4！=4×3×2×1=24$项。\n\n与自然数$1，2，3，4，\\dots n！$与之一一对应。比如  $1～4$四个数的全排列按字典序如下：\n\n| 1234：第一个 | 2134：第七个  | 3124：第13个 | 4123：第19个 |\n| :------: | :-------: | :-------: | :-------: |\n| 1243：第二个 | 2143：第八个  | 3142：第14个 | 4132：第20个 |\n| 1324：第三个 | 2314：第九个  | 3214：第15个 | 4213：第21个 |\n| 1342：第四个 | 2341：第十个  | 3241：第16个 | 4231：第22个 |\n| 1423：第五个 | 2413：第11个 | 3412：第17个 | 4312：第23个 |\n| 1432：第六个 | 2431：第12个 | 3421：第18个 | 4321：第24个 |\n\n**问：求4132是第几个排列？**\n\n解：总共4个数，所以n=4.ans:=0;\n\n1. 第一个数是4，研究比4小的并且还没有出现过的数有3个：1，2，3。\n\n   其中，a4 = 3 ，那么ans:=ans+3\\*(n-1)!所以  ans:= ans+ 3\\*(4-1)!  =18\n\n2. 第二个数是1，研究比1小的并且还没有出现过的数为 0个。\n\n   其中，a3 = 0 ，那么ans:=ans+0 * (n-2)!，那么ans不变。\n\n3. 第三个数是3，研究比3小的并且还没有出现过的数为1个：1，2。\n\n   其中，a2 = 2 ，那么ans:=ans+ 1* (n-3)!,那么ans:=18+1* (4-3)!=19\n\n4. 第四个数是2，研究比2小的并且还没有出现过的数为0个。\n\n   其中，a1 = 0 ，那么ans不变。\n\n最后ans怎么等于19啊？？代表它前面有19个排列嘛，那么4132自己就是第20个罗（ 最后ans:=ans+1）\n\n## 逆展开：\n\n**例：**1～5从小到大全排列中，找出第96个排列？\n\n1. 首先用96-1得到95，说明X之前有95个排列.(将此数本身减去！)\n2. 用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.\n3. 用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.\n4. 用5去除2!得到2余1，类似地，这一位是3.\n5. 用1去除1!得到1余0，这一位是2.\n6. 最后一位只能是1.\n7. 所以这个数是45321.\n\n\n\n## 总结 + 代码：\n\n```c++\nint fac[] = {1,1,2,6,24,120,720,5040,40320}; //阶乘\n\n//康托展开\nint kt(int n,int s[]){ \n    int sum = 0,smallNum;\n    for(int i=0; i < n; i++){\n        smallNum = 0; //比当前数小的数\n        for(int j=i+1; j<n; j++)\n            if(s[i] > s[j]) smallNum++;\n        sum += smallNum * fac[n-i-1];\n    }\n    return sum;\n}\n//康托逆展开\nvoid invKT(int n, int k, int s[]){\n    int t,j;\n    bool visit[10] = {false}; //需要记录该数是否已在前面出现过\n    for(int i=0; i<n; i++){\n        t = k/fac[n-i-1];\n        for(j=1; j<=n; j++){\n            if(!visit[j]){\n                if(t == 0) break;\n                t--;\n            }\n        }\n        s[i] = j;\n        visit[j] = true;\n        k %= fac[n-i-1];\n    }\n}\n```\n\n","source":"_posts/康托展开.md","raw":"---\ntitle: 康托展开\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 组合数学\n    - 康托展开\ncategories: Algorithm\n---\n\n## 定义：\n\n康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。\n\n## 公式：\n\n$$X=a_n(n-1)!+a_{n-1}(n-2)!+\\ldots+a_1\\cdot0! + 1$$\n\n其中，$a_i$为整数，并且$0\\le a_i \\le i,1\\le i \\le n.$\n\n## 用途：\n\nn位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出唯一的一个排列。\n\n## 举例：\n\n对于一个有n个不同元素的集合${1,2,3,4,\\dots,n}$的从小到大排序（从大到小 同理）的全排列 显然它有$n！$项。如n=4，那么就有$4！=4×3×2×1=24$项。\n\n与自然数$1，2，3，4，\\dots n！$与之一一对应。比如  $1～4$四个数的全排列按字典序如下：\n\n| 1234：第一个 | 2134：第七个  | 3124：第13个 | 4123：第19个 |\n| :------: | :-------: | :-------: | :-------: |\n| 1243：第二个 | 2143：第八个  | 3142：第14个 | 4132：第20个 |\n| 1324：第三个 | 2314：第九个  | 3214：第15个 | 4213：第21个 |\n| 1342：第四个 | 2341：第十个  | 3241：第16个 | 4231：第22个 |\n| 1423：第五个 | 2413：第11个 | 3412：第17个 | 4312：第23个 |\n| 1432：第六个 | 2431：第12个 | 3421：第18个 | 4321：第24个 |\n\n**问：求4132是第几个排列？**\n\n解：总共4个数，所以n=4.ans:=0;\n\n1. 第一个数是4，研究比4小的并且还没有出现过的数有3个：1，2，3。\n\n   其中，a4 = 3 ，那么ans:=ans+3\\*(n-1)!所以  ans:= ans+ 3\\*(4-1)!  =18\n\n2. 第二个数是1，研究比1小的并且还没有出现过的数为 0个。\n\n   其中，a3 = 0 ，那么ans:=ans+0 * (n-2)!，那么ans不变。\n\n3. 第三个数是3，研究比3小的并且还没有出现过的数为1个：1，2。\n\n   其中，a2 = 2 ，那么ans:=ans+ 1* (n-3)!,那么ans:=18+1* (4-3)!=19\n\n4. 第四个数是2，研究比2小的并且还没有出现过的数为0个。\n\n   其中，a1 = 0 ，那么ans不变。\n\n最后ans怎么等于19啊？？代表它前面有19个排列嘛，那么4132自己就是第20个罗（ 最后ans:=ans+1）\n\n## 逆展开：\n\n**例：**1～5从小到大全排列中，找出第96个排列？\n\n1. 首先用96-1得到95，说明X之前有95个排列.(将此数本身减去！)\n2. 用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.\n3. 用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.\n4. 用5去除2!得到2余1，类似地，这一位是3.\n5. 用1去除1!得到1余0，这一位是2.\n6. 最后一位只能是1.\n7. 所以这个数是45321.\n\n\n\n## 总结 + 代码：\n\n```c++\nint fac[] = {1,1,2,6,24,120,720,5040,40320}; //阶乘\n\n//康托展开\nint kt(int n,int s[]){ \n    int sum = 0,smallNum;\n    for(int i=0; i < n; i++){\n        smallNum = 0; //比当前数小的数\n        for(int j=i+1; j<n; j++)\n            if(s[i] > s[j]) smallNum++;\n        sum += smallNum * fac[n-i-1];\n    }\n    return sum;\n}\n//康托逆展开\nvoid invKT(int n, int k, int s[]){\n    int t,j;\n    bool visit[10] = {false}; //需要记录该数是否已在前面出现过\n    for(int i=0; i<n; i++){\n        t = k/fac[n-i-1];\n        for(j=1; j<=n; j++){\n            if(!visit[j]){\n                if(t == 0) break;\n                t--;\n            }\n        }\n        s[i] = j;\n        visit[j] = true;\n        k %= fac[n-i-1];\n    }\n}\n```\n\n","slug":"康托展开","published":1,"updated":"2018-07-03T06:29:46.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvo001cplxp4q7vvnt8","content":"<h2 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>\n<h2 id=\"公式：\"><a href=\"#公式：\" class=\"headerlink\" title=\"公式：\"></a>公式：</h2><p>$$X=a_n(n-1)!+a_{n-1}(n-2)!+\\ldots+a_1\\cdot0! + 1$$</p>\n<p>其中，$a_i$为整数，并且$0\\le a_i \\le i,1\\le i \\le n.$</p>\n<h2 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h2><p>n位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出唯一的一个排列。</p>\n<h2 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a>举例：</h2><p>对于一个有n个不同元素的集合${1,2,3,4,\\dots,n}$的从小到大排序（从大到小 同理）的全排列 显然它有$n！$项。如n=4，那么就有$4！=4×3×2×1=24$项。</p>\n<p>与自然数$1，2，3，4，\\dots n！$与之一一对应。比如  $1～4$四个数的全排列按字典序如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1234：第一个</th>\n<th style=\"text-align:center\">2134：第七个</th>\n<th style=\"text-align:center\">3124：第13个</th>\n<th style=\"text-align:center\">4123：第19个</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1243：第二个</td>\n<td style=\"text-align:center\">2143：第八个</td>\n<td style=\"text-align:center\">3142：第14个</td>\n<td style=\"text-align:center\">4132：第20个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1324：第三个</td>\n<td style=\"text-align:center\">2314：第九个</td>\n<td style=\"text-align:center\">3214：第15个</td>\n<td style=\"text-align:center\">4213：第21个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1342：第四个</td>\n<td style=\"text-align:center\">2341：第十个</td>\n<td style=\"text-align:center\">3241：第16个</td>\n<td style=\"text-align:center\">4231：第22个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1423：第五个</td>\n<td style=\"text-align:center\">2413：第11个</td>\n<td style=\"text-align:center\">3412：第17个</td>\n<td style=\"text-align:center\">4312：第23个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1432：第六个</td>\n<td style=\"text-align:center\">2431：第12个</td>\n<td style=\"text-align:center\">3421：第18个</td>\n<td style=\"text-align:center\">4321：第24个</td>\n</tr>\n</tbody>\n</table>\n<p><strong>问：求4132是第几个排列？</strong></p>\n<p>解：总共4个数，所以n=4.ans:=0;</p>\n<ol>\n<li><p>第一个数是4，研究比4小的并且还没有出现过的数有3个：1，2，3。</p>\n<p>其中，a4 = 3 ，那么ans:=ans+3*(n-1)!所以  ans:= ans+ 3*(4-1)!  =18</p>\n</li>\n<li><p>第二个数是1，研究比1小的并且还没有出现过的数为 0个。</p>\n<p>其中，a3 = 0 ，那么ans:=ans+0 * (n-2)!，那么ans不变。</p>\n</li>\n<li><p>第三个数是3，研究比3小的并且还没有出现过的数为1个：1，2。</p>\n<p>其中，a2 = 2 ，那么ans:=ans+ 1<em> (n-3)!,那么ans:=18+1</em> (4-3)!=19</p>\n</li>\n<li><p>第四个数是2，研究比2小的并且还没有出现过的数为0个。</p>\n<p>其中，a1 = 0 ，那么ans不变。</p>\n</li>\n</ol>\n<p>最后ans怎么等于19啊？？代表它前面有19个排列嘛，那么4132自己就是第20个罗（ 最后ans:=ans+1）</p>\n<h2 id=\"逆展开：\"><a href=\"#逆展开：\" class=\"headerlink\" title=\"逆展开：\"></a>逆展开：</h2><p><strong>例：</strong>1～5从小到大全排列中，找出第96个排列？</p>\n<ol>\n<li>首先用96-1得到95，说明X之前有95个排列.(将此数本身减去！)</li>\n<li>用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.</li>\n<li>用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.</li>\n<li>用5去除2!得到2余1，类似地，这一位是3.</li>\n<li>用1去除1!得到1余0，这一位是2.</li>\n<li>最后一位只能是1.</li>\n<li>所以这个数是45321.</li>\n</ol>\n<h2 id=\"总结-代码：\"><a href=\"#总结-代码：\" class=\"headerlink\" title=\"总结 + 代码：\"></a>总结 + 代码：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fac[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">24</span>,<span class=\"number\">120</span>,<span class=\"number\">720</span>,<span class=\"number\">5040</span>,<span class=\"number\">40320</span>&#125;; <span class=\"comment\">//阶乘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//康托展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kt</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> s[])</span></span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>,smallNum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        smallNum = <span class=\"number\">0</span>; <span class=\"comment\">//比当前数小的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;n; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] &gt; s[j]) smallNum++;</span><br><span class=\"line\">        sum += smallNum * fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//康托逆展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invKT</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> s[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t,j;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visit[<span class=\"number\">10</span>] = &#123;<span class=\"literal\">false</span>&#125;; <span class=\"comment\">//需要记录该数是否已在前面出现过</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">        t = k/fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>; j&lt;=n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visit[j])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(t == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                t--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s[i] = j;</span><br><span class=\"line\">        visit[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        k %= fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>\n<h2 id=\"公式：\"><a href=\"#公式：\" class=\"headerlink\" title=\"公式：\"></a>公式：</h2><p>$$X=a_n(n-1)!+a_{n-1}(n-2)!+\\ldots+a_1\\cdot0! + 1$$</p>\n<p>其中，$a_i$为整数，并且$0\\le a_i \\le i,1\\le i \\le n.$</p>\n<h2 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h2><p>n位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出唯一的一个排列。</p>\n<h2 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a>举例：</h2><p>对于一个有n个不同元素的集合${1,2,3,4,\\dots,n}$的从小到大排序（从大到小 同理）的全排列 显然它有$n！$项。如n=4，那么就有$4！=4×3×2×1=24$项。</p>\n<p>与自然数$1，2，3，4，\\dots n！$与之一一对应。比如  $1～4$四个数的全排列按字典序如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">1234：第一个</th>\n<th style=\"text-align:center\">2134：第七个</th>\n<th style=\"text-align:center\">3124：第13个</th>\n<th style=\"text-align:center\">4123：第19个</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1243：第二个</td>\n<td style=\"text-align:center\">2143：第八个</td>\n<td style=\"text-align:center\">3142：第14个</td>\n<td style=\"text-align:center\">4132：第20个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1324：第三个</td>\n<td style=\"text-align:center\">2314：第九个</td>\n<td style=\"text-align:center\">3214：第15个</td>\n<td style=\"text-align:center\">4213：第21个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1342：第四个</td>\n<td style=\"text-align:center\">2341：第十个</td>\n<td style=\"text-align:center\">3241：第16个</td>\n<td style=\"text-align:center\">4231：第22个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1423：第五个</td>\n<td style=\"text-align:center\">2413：第11个</td>\n<td style=\"text-align:center\">3412：第17个</td>\n<td style=\"text-align:center\">4312：第23个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1432：第六个</td>\n<td style=\"text-align:center\">2431：第12个</td>\n<td style=\"text-align:center\">3421：第18个</td>\n<td style=\"text-align:center\">4321：第24个</td>\n</tr>\n</tbody>\n</table>\n<p><strong>问：求4132是第几个排列？</strong></p>\n<p>解：总共4个数，所以n=4.ans:=0;</p>\n<ol>\n<li><p>第一个数是4，研究比4小的并且还没有出现过的数有3个：1，2，3。</p>\n<p>其中，a4 = 3 ，那么ans:=ans+3*(n-1)!所以  ans:= ans+ 3*(4-1)!  =18</p>\n</li>\n<li><p>第二个数是1，研究比1小的并且还没有出现过的数为 0个。</p>\n<p>其中，a3 = 0 ，那么ans:=ans+0 * (n-2)!，那么ans不变。</p>\n</li>\n<li><p>第三个数是3，研究比3小的并且还没有出现过的数为1个：1，2。</p>\n<p>其中，a2 = 2 ，那么ans:=ans+ 1<em> (n-3)!,那么ans:=18+1</em> (4-3)!=19</p>\n</li>\n<li><p>第四个数是2，研究比2小的并且还没有出现过的数为0个。</p>\n<p>其中，a1 = 0 ，那么ans不变。</p>\n</li>\n</ol>\n<p>最后ans怎么等于19啊？？代表它前面有19个排列嘛，那么4132自己就是第20个罗（ 最后ans:=ans+1）</p>\n<h2 id=\"逆展开：\"><a href=\"#逆展开：\" class=\"headerlink\" title=\"逆展开：\"></a>逆展开：</h2><p><strong>例：</strong>1～5从小到大全排列中，找出第96个排列？</p>\n<ol>\n<li>首先用96-1得到95，说明X之前有95个排列.(将此数本身减去！)</li>\n<li>用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.</li>\n<li>用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.</li>\n<li>用5去除2!得到2余1，类似地，这一位是3.</li>\n<li>用1去除1!得到1余0，这一位是2.</li>\n<li>最后一位只能是1.</li>\n<li>所以这个数是45321.</li>\n</ol>\n<h2 id=\"总结-代码：\"><a href=\"#总结-代码：\" class=\"headerlink\" title=\"总结 + 代码：\"></a>总结 + 代码：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fac[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">24</span>,<span class=\"number\">120</span>,<span class=\"number\">720</span>,<span class=\"number\">5040</span>,<span class=\"number\">40320</span>&#125;; <span class=\"comment\">//阶乘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//康托展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kt</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> s[])</span></span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>,smallNum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        smallNum = <span class=\"number\">0</span>; <span class=\"comment\">//比当前数小的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;n; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] &gt; s[j]) smallNum++;</span><br><span class=\"line\">        sum += smallNum * fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//康托逆展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invKT</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> s[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t,j;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visit[<span class=\"number\">10</span>] = &#123;<span class=\"literal\">false</span>&#125;; <span class=\"comment\">//需要记录该数是否已在前面出现过</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">        t = k/fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>; j&lt;=n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visit[j])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(t == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                t--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s[i] = j;</span><br><span class=\"line\">        visit[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        k %= fac[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"抽屉原理","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n## 抽屉原理简述：\n\n### 第一抽屉原理：\n\n>1. 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。\n>2. 把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。\n>3. 把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。\n\n### 第二抽屉原理：\n\n>1. 把$（mn－1）$个物体放入n个抽屉中，其中必有一个抽屉中至多有$（m—1）$个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。\n\n## HDU_1205 吃糖果\n\n###  Problem Description\n\nHOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。\n\n### Input\n\n第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0<N<=1000000)，第二行是N个数，表示N种糖果的数目Mi(0<Mi<=1000000)。\n\n### Output\n\n对于每组数据，输出一行，包含一个\"Yes\"或者\"No\"。\n\n### Sample Input\n\n2\n3\n4 1 1\n5\n5 4 3 2 1\n\n### Sample Output\n\nNo\nYes\n\n### 题解：\n\n设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam>sum-max+1；则一定不能吃完，否则能吃完。\n\n### 代码：\n\n```c++\n#include <stdio.h>\nint main()\n{ \n  \t__int64  n,m,t,max,sum;\n    scanf(\"%I64d\",&t);\n    while(t--){\n        sum=0;\n        max=0;\n        scanf(\"%I64d\",&n);\n        for(int i=0;i<n;i++){\n            scanf(\"%I64d\",&m);\n            sum+=m;\n            if(max<m)\n            \tmax=m;        \n        }\n        sum-=max;\n        if(max>sum+1)\n        \tprintf(\"No\\n\");\n        else\n        \tprintf(\"Yes\\n\");\n    }\n        return 0;\n}\n```\n\n# HDU_1808 Halloween treats\n\n### Problem Description\n\nEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year's experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. \n\nYour job is to help the children and present a solution. \n\n### Input\n\nThe input contains several test cases. \nThe first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , ... , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. \n\nThe last test case is followed by two zeros. \n\n### Output\n\nFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print \"no sweets\" instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.\n\n### Sample Input\n\n4 5\n1 2 3 7 5\n3 6\n7 11 2 5 13 17\n0 0\n\n### Sample Output\n\n3 5\n2 3 4\n\n### 题解：\n\n有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。\n\n我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，...，a1+...+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c<=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。\n\n### 代码：\n\n```c++\ninclude <cstdio>\ninclude <cstring>\n\nconst int MAXN = 1e5+5;\nint a[MAXN], SumMod[MAXN], flag[MAXN];\n\nint main()\n{\n    int c, n;\n    while(~scanf(\"%d%d\", &c, &n) && (c+n))\n    {\n        SumMod[0] = 0;\n        memset(flag, 0, sizeof(flag));\n        for(int i=1; i<=n; ++i)\n            scanf(\"%d\", &a[i]);\n        for(int i=1; i<=n; ++i)\n        {\n            SumMod[i] = (SumMod[i-1] + a[i]) % c;  // 处理前缀和，并取模\n            if(flag[SumMod[i]] == 0)\n                flag[SumMod[i]] = i;\n            else                                   // 如果相同的余数在前面出现过\n            {\n                int j = flag[SumMod[i]] + 1;\n                int k = j;\n                for(; j<=i; ++j)                   // 公共项即为答案\n                    if(j == k) printf(\"%d\", j);\n                    else printf(\" %d\", j);\n                break;\n            }\n        }\n        puts(\"\");\n    }\n    return 0;\n}\n```\n\n","source":"_posts/抽屉原理.md","raw":"---\ntitle: 抽屉原理\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 组合数学\n    - 抽屉原理\ncategories: Algorithm\n---\n\n## 抽屉原理简述：\n\n### 第一抽屉原理：\n\n>1. 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。\n>2. 把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。\n>3. 把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。\n\n### 第二抽屉原理：\n\n>1. 把$（mn－1）$个物体放入n个抽屉中，其中必有一个抽屉中至多有$（m—1）$个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。\n\n## HDU_1205 吃糖果\n\n###  Problem Description\n\nHOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。\n\n### Input\n\n第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0<N<=1000000)，第二行是N个数，表示N种糖果的数目Mi(0<Mi<=1000000)。\n\n### Output\n\n对于每组数据，输出一行，包含一个\"Yes\"或者\"No\"。\n\n### Sample Input\n\n2\n3\n4 1 1\n5\n5 4 3 2 1\n\n### Sample Output\n\nNo\nYes\n\n### 题解：\n\n设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam>sum-max+1；则一定不能吃完，否则能吃完。\n\n### 代码：\n\n```c++\n#include <stdio.h>\nint main()\n{ \n  \t__int64  n,m,t,max,sum;\n    scanf(\"%I64d\",&t);\n    while(t--){\n        sum=0;\n        max=0;\n        scanf(\"%I64d\",&n);\n        for(int i=0;i<n;i++){\n            scanf(\"%I64d\",&m);\n            sum+=m;\n            if(max<m)\n            \tmax=m;        \n        }\n        sum-=max;\n        if(max>sum+1)\n        \tprintf(\"No\\n\");\n        else\n        \tprintf(\"Yes\\n\");\n    }\n        return 0;\n}\n```\n\n# HDU_1808 Halloween treats\n\n### Problem Description\n\nEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year's experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. \n\nYour job is to help the children and present a solution. \n\n### Input\n\nThe input contains several test cases. \nThe first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , ... , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. \n\nThe last test case is followed by two zeros. \n\n### Output\n\nFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print \"no sweets\" instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.\n\n### Sample Input\n\n4 5\n1 2 3 7 5\n3 6\n7 11 2 5 13 17\n0 0\n\n### Sample Output\n\n3 5\n2 3 4\n\n### 题解：\n\n有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。\n\n我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，...，a1+...+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c<=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。\n\n### 代码：\n\n```c++\ninclude <cstdio>\ninclude <cstring>\n\nconst int MAXN = 1e5+5;\nint a[MAXN], SumMod[MAXN], flag[MAXN];\n\nint main()\n{\n    int c, n;\n    while(~scanf(\"%d%d\", &c, &n) && (c+n))\n    {\n        SumMod[0] = 0;\n        memset(flag, 0, sizeof(flag));\n        for(int i=1; i<=n; ++i)\n            scanf(\"%d\", &a[i]);\n        for(int i=1; i<=n; ++i)\n        {\n            SumMod[i] = (SumMod[i-1] + a[i]) % c;  // 处理前缀和，并取模\n            if(flag[SumMod[i]] == 0)\n                flag[SumMod[i]] = i;\n            else                                   // 如果相同的余数在前面出现过\n            {\n                int j = flag[SumMod[i]] + 1;\n                int k = j;\n                for(; j<=i; ++j)                   // 公共项即为答案\n                    if(j == k) printf(\"%d\", j);\n                    else printf(\" %d\", j);\n                break;\n            }\n        }\n        puts(\"\");\n    }\n    return 0;\n}\n```\n\n","slug":"抽屉原理","published":1,"updated":"2018-07-03T06:29:46.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvp001eplxpb4ko6jxk","content":"<h2 id=\"抽屉原理简述：\"><a href=\"#抽屉原理简述：\" class=\"headerlink\" title=\"抽屉原理简述：\"></a>抽屉原理简述：</h2><h3 id=\"第一抽屉原理：\"><a href=\"#第一抽屉原理：\" class=\"headerlink\" title=\"第一抽屉原理：\"></a>第一抽屉原理：</h3><blockquote>\n<ol>\n<li>把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</li>\n<li>把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</li>\n<li>把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。</li>\n</ol>\n</blockquote>\n<h3 id=\"第二抽屉原理：\"><a href=\"#第二抽屉原理：\" class=\"headerlink\" title=\"第二抽屉原理：\"></a>第二抽屉原理：</h3><blockquote>\n<ol>\n<li>把$（mn－1）$个物体放入n个抽屉中，其中必有一个抽屉中至多有$（m—1）$个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</li>\n</ol>\n</blockquote>\n<h2 id=\"HDU-1205-吃糖果\"><a href=\"#HDU-1205-吃糖果\" class=\"headerlink\" title=\"HDU_1205 吃糖果\"></a>HDU_1205 吃糖果</h2><h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2<br>3<br>4 1 1<br>5<br>5 4 3 2 1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>No<br>Yes</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam&gt;sum-max+1；则一定不能吃完，否则能吃完。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">  \t__int64  n,m,t,max,sum;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;m);</span><br><span class=\"line\">            sum+=m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(max&lt;m)</span><br><span class=\"line\">            \tmax=m;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum-=max;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(max&gt;sum+<span class=\"number\">1</span>)</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"HDU-1808-Halloween-treats\"><a href=\"#HDU-1808-Halloween-treats\" class=\"headerlink\" title=\"HDU_1808 Halloween treats\"></a>HDU_1808 Halloween treats</h1><h3 id=\"Problem-Description-1\"><a href=\"#Problem-Description-1\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. </p>\n<p>Your job is to help the children and present a solution. </p>\n<h3 id=\"Input-1\"><a href=\"#Input-1\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input contains several test cases.<br>The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. </p>\n<p>The last test case is followed by two zeros. </p>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.</p>\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>4 5<br>1 2 3 7 5<br>3 6<br>7 11 2 5 13 17<br>0 0</p>\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3 5<br>2 3 4</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。</p>\n<p>我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，…，a1+…+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c&lt;=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1e5</span>+<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[MAXN], SumMod[MAXN], flag[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c, n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;c, &amp;n) &amp;&amp; (c+n))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SumMod[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(flag, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flag));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SumMod[i] = (SumMod[i<span class=\"number\">-1</span>] + a[i]) % c;  <span class=\"comment\">// 处理前缀和，并取模</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[SumMod[i]] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                flag[SumMod[i]] = i;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>                                   <span class=\"comment\">// 如果相同的余数在前面出现过</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = flag[SumMod[i]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = j;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(; j&lt;=i; ++j)                   <span class=\"comment\">// 公共项即为答案</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j == k) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, j);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, j);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"抽屉原理简述：\"><a href=\"#抽屉原理简述：\" class=\"headerlink\" title=\"抽屉原理简述：\"></a>抽屉原理简述：</h2><h3 id=\"第一抽屉原理：\"><a href=\"#第一抽屉原理：\" class=\"headerlink\" title=\"第一抽屉原理：\"></a>第一抽屉原理：</h3><blockquote>\n<ol>\n<li>把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</li>\n<li>把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</li>\n<li>把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。</li>\n</ol>\n</blockquote>\n<h3 id=\"第二抽屉原理：\"><a href=\"#第二抽屉原理：\" class=\"headerlink\" title=\"第二抽屉原理：\"></a>第二抽屉原理：</h3><blockquote>\n<ol>\n<li>把$（mn－1）$个物体放入n个抽屉中，其中必有一个抽屉中至多有$（m—1）$个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</li>\n</ol>\n</blockquote>\n<h2 id=\"HDU-1205-吃糖果\"><a href=\"#HDU-1205-吃糖果\" class=\"headerlink\" title=\"HDU_1205 吃糖果\"></a>HDU_1205 吃糖果</h2><h3 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>2<br>3<br>4 1 1<br>5<br>5 4 3 2 1</p>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>No<br>Yes</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam&gt;sum-max+1；则一定不能吃完，否则能吃完。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">  \t__int64  n,m,t,max,sum;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%I64d\"</span>,&amp;m);</span><br><span class=\"line\">            sum+=m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(max&lt;m)</span><br><span class=\"line\">            \tmax=m;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum-=max;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(max&gt;sum+<span class=\"number\">1</span>)</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Yes\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"HDU-1808-Halloween-treats\"><a href=\"#HDU-1808-Halloween-treats\" class=\"headerlink\" title=\"HDU_1808 Halloween treats\"></a>HDU_1808 Halloween treats</h1><h3 id=\"Problem-Description-1\"><a href=\"#Problem-Description-1\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h3><p>Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. </p>\n<p>Your job is to help the children and present a solution. </p>\n<h3 id=\"Input-1\"><a href=\"#Input-1\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input contains several test cases.<br>The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. </p>\n<p>The last test case is followed by two zeros. </p>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.</p>\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><p>4 5<br>1 2 3 7 5<br>3 6<br>7 11 2 5 13 17<br>0 0</p>\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><p>3 5<br>2 3 4</p>\n<h3 id=\"题解：-1\"><a href=\"#题解：-1\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。</p>\n<p>我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，…，a1+…+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c&lt;=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;cstdio&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1e5</span>+<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[MAXN], SumMod[MAXN], flag[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c, n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;c, &amp;n) &amp;&amp; (c+n))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SumMod[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(flag, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(flag));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SumMod[i] = (SumMod[i<span class=\"number\">-1</span>] + a[i]) % c;  <span class=\"comment\">// 处理前缀和，并取模</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[SumMod[i]] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                flag[SumMod[i]] = i;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>                                   <span class=\"comment\">// 如果相同的余数在前面出现过</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = flag[SumMod[i]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = j;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(; j&lt;=i; ++j)                   <span class=\"comment\">// 公共项即为答案</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j == k) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, j);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, j);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"51NOD DP-最大子矩阵和","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n### 描述\n\n一个M\\*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的    值。例如：3\\*3的矩阵：\n\n-1  3 -1\n 2 -1  3 \n-3  1  2\n\n和最大的子矩阵是：\n\n 3 -1\n-1  3\n 1  2\n\n### Input\n\n第1行：M和N，中间用空格隔开（2 <= M,N <= 500)。\n第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 <= M[i] <= 10^9)\n\n### Output\n\n输出和的最大值。如果所有数都是负数，就输出0。\n\n### Input 示例\n```\n 3  3\n-1  3 -1\n 2 -1  3\n-3  1  2\n```\n### Output示例\n\n7\n\n### 题解\n\n\n\n\n\n","source":"_posts/最大子矩阵和.md","raw":"---\ntitle: 51NOD DP-最大子矩阵和\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: 基本 DP\ncategories: Algorithm\n---\n\n### 描述\n\n一个M\\*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的    值。例如：3\\*3的矩阵：\n\n-1  3 -1\n 2 -1  3 \n-3  1  2\n\n和最大的子矩阵是：\n\n 3 -1\n-1  3\n 1  2\n\n### Input\n\n第1行：M和N，中间用空格隔开（2 <= M,N <= 500)。\n第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 <= M[i] <= 10^9)\n\n### Output\n\n输出和的最大值。如果所有数都是负数，就输出0。\n\n### Input 示例\n```\n 3  3\n-1  3 -1\n 2 -1  3\n-3  1  2\n```\n### Output示例\n\n7\n\n### 题解\n\n\n\n\n\n","slug":"最大子矩阵和","published":1,"updated":"2018-07-03T06:29:45.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvs001hplxpkfbngel4","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的    值。例如：3*3的矩阵：</p>\n<p>-1  3 -1<br> 2 -1  3<br>-3  1  2</p>\n<p>和最大的子矩阵是：</p>\n<p> 3 -1<br>-1  3<br> 1  2</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>输出和的最大值。如果所有数都是负数，就输出0。</p>\n<h3 id=\"Input-示例\"><a href=\"#Input-示例\" class=\"headerlink\" title=\"Input 示例\"></a>Input 示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 3  3</span><br><span class=\"line\">-1  3 -1</span><br><span class=\"line\"> 2 -1  3</span><br><span class=\"line\">-3  1  2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h3><p>7</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的    值。例如：3*3的矩阵：</p>\n<p>-1  3 -1<br> 2 -1  3<br>-3  1  2</p>\n<p>和最大的子矩阵是：</p>\n<p> 3 -1<br>-1  3<br> 1  2</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)</p>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>输出和的最大值。如果所有数都是负数，就输出0。</p>\n<h3 id=\"Input-示例\"><a href=\"#Input-示例\" class=\"headerlink\" title=\"Input 示例\"></a>Input 示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 3  3</span><br><span class=\"line\">-1  3 -1</span><br><span class=\"line\"> 2 -1  3</span><br><span class=\"line\">-3  1  2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output示例\"><a href=\"#Output示例\" class=\"headerlink\" title=\"Output示例\"></a>Output示例</h3><p>7</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3>"},{"title":"裴蜀等式","date":"2016-12-28T08:31:57.000Z","mathjax":true,"_content":"\n在数论中，**裴蜀等式（Bézout's identity）** 或 **裴蜀定理** 是一个关于最大公因数的定理：\n\n> 对于正整数 a, b，存在s,t∈Z 使 sa + t b = gcd (a,b) 成立。\n\n#### 根据互质的定义证明以下命题:\n\n​\t正整数a,b∈$Z^+$互质当且仅当存在整数s,t∈$Z $满足 sa+tb=1。\n\n#### 证明：\n\n​\t1. 已知整数 $a$ 和 $b$ 互质，那么$gcd{(a,b)}=1$，所以存在整数$s,t$ 使得 $1 = sa+tb$；\n​\t2. 假设存在一个整数 dd 是正整数 aa 和正整数 bb 的公共因子，则$ d\\mid a$且 $d\\mid b$；\n​\t3. 因为 $d$ 是 $a $的因数，且 $s$ 是整数，所以 $d$ 也一定是 $sa$ 的因数，也就是说 $d\\mid  sa,d∣sa$；\n​\t4. 因为 $d$ 是 $b$ 的因数,且 $t$ 是整数,所以 $d$ 也一定是 $tb$ 的因数，也就是说 $d\\mid tb,d∣tb$；\n​\t5. 存在整数 $m,n$ 使得我们可以将 $sa$ 表示为 $md$，将 $tb$ 表示为 $nd$；所以，我们可以得 $sa+tb = md+nd = (m+n)d$；由此我们可以知道 $d\\mid (sa+tb)$；\n​\t6. 因为我们已知 $sa+tb = 1$,所以 $d \\mid 1$。由此，我们只能是 $d = 1$ 或 $d = -1$。所以 $a$ 和 $b$的公共正整数因子只有 1，所以 $a,b\\in \\mathbb{Z^+}$  互质；\n​\t7. 综上可得“正整数 $a,b\\in \\mathbb{Z^+}$。","source":"_posts/裴蜀等式.md","raw":"---\ntitle: 裴蜀等式\ndate: 2016-12-28 16:31:57\nmathjax: true\ntags: \n    - 组合数学\n    - 裴蜀等式\ncategories: Algorithm\n---\n\n在数论中，**裴蜀等式（Bézout's identity）** 或 **裴蜀定理** 是一个关于最大公因数的定理：\n\n> 对于正整数 a, b，存在s,t∈Z 使 sa + t b = gcd (a,b) 成立。\n\n#### 根据互质的定义证明以下命题:\n\n​\t正整数a,b∈$Z^+$互质当且仅当存在整数s,t∈$Z $满足 sa+tb=1。\n\n#### 证明：\n\n​\t1. 已知整数 $a$ 和 $b$ 互质，那么$gcd{(a,b)}=1$，所以存在整数$s,t$ 使得 $1 = sa+tb$；\n​\t2. 假设存在一个整数 dd 是正整数 aa 和正整数 bb 的公共因子，则$ d\\mid a$且 $d\\mid b$；\n​\t3. 因为 $d$ 是 $a $的因数，且 $s$ 是整数，所以 $d$ 也一定是 $sa$ 的因数，也就是说 $d\\mid  sa,d∣sa$；\n​\t4. 因为 $d$ 是 $b$ 的因数,且 $t$ 是整数,所以 $d$ 也一定是 $tb$ 的因数，也就是说 $d\\mid tb,d∣tb$；\n​\t5. 存在整数 $m,n$ 使得我们可以将 $sa$ 表示为 $md$，将 $tb$ 表示为 $nd$；所以，我们可以得 $sa+tb = md+nd = (m+n)d$；由此我们可以知道 $d\\mid (sa+tb)$；\n​\t6. 因为我们已知 $sa+tb = 1$,所以 $d \\mid 1$。由此，我们只能是 $d = 1$ 或 $d = -1$。所以 $a$ 和 $b$的公共正整数因子只有 1，所以 $a,b\\in \\mathbb{Z^+}$  互质；\n​\t7. 综上可得“正整数 $a,b\\in \\mathbb{Z^+}$。","slug":"裴蜀等式","published":1,"updated":"2018-07-03T06:29:45.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvt001kplxpm6dcfb88","content":"<p>在数论中，<strong>裴蜀等式（Bézout’s identity）</strong> 或 <strong>裴蜀定理</strong> 是一个关于最大公因数的定理：</p>\n<blockquote>\n<p>对于正整数 a, b，存在s,t∈Z 使 sa + t b = gcd (a,b) 成立。</p>\n</blockquote>\n<h4 id=\"根据互质的定义证明以下命题\"><a href=\"#根据互质的定义证明以下命题\" class=\"headerlink\" title=\"根据互质的定义证明以下命题:\"></a>根据互质的定义证明以下命题:</h4><p>​    正整数a,b∈$Z^+$互质当且仅当存在整数s,t∈$Z $满足 sa+tb=1。</p>\n<h4 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h4><p>​    1. 已知整数 $a$ 和 $b$ 互质，那么$gcd{(a,b)}=1$，所以存在整数$s,t$ 使得 $1 = sa+tb$；<br>​    2. 假设存在一个整数 dd 是正整数 aa 和正整数 bb 的公共因子，则$ d\\mid a$且 $d\\mid b$；<br>​    3. 因为 $d$ 是 $a $的因数，且 $s$ 是整数，所以 $d$ 也一定是 $sa$ 的因数，也就是说 $d\\mid  sa,d∣sa$；<br>​    4. 因为 $d$ 是 $b$ 的因数,且 $t$ 是整数,所以 $d$ 也一定是 $tb$ 的因数，也就是说 $d\\mid tb,d∣tb$；<br>​    5. 存在整数 $m,n$ 使得我们可以将 $sa$ 表示为 $md$，将 $tb$ 表示为 $nd$；所以，我们可以得 $sa+tb = md+nd = (m+n)d$；由此我们可以知道 $d\\mid (sa+tb)$；<br>​    6. 因为我们已知 $sa+tb = 1$,所以 $d \\mid 1$。由此，我们只能是 $d = 1$ 或 $d = -1$。所以 $a$ 和 $b$的公共正整数因子只有 1，所以 $a,b\\in \\mathbb{Z^+}$  互质；<br>​    7. 综上可得“正整数 $a,b\\in \\mathbb{Z^+}$。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在数论中，<strong>裴蜀等式（Bézout’s identity）</strong> 或 <strong>裴蜀定理</strong> 是一个关于最大公因数的定理：</p>\n<blockquote>\n<p>对于正整数 a, b，存在s,t∈Z 使 sa + t b = gcd (a,b) 成立。</p>\n</blockquote>\n<h4 id=\"根据互质的定义证明以下命题\"><a href=\"#根据互质的定义证明以下命题\" class=\"headerlink\" title=\"根据互质的定义证明以下命题:\"></a>根据互质的定义证明以下命题:</h4><p>​    正整数a,b∈$Z^+$互质当且仅当存在整数s,t∈$Z $满足 sa+tb=1。</p>\n<h4 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h4><p>​    1. 已知整数 $a$ 和 $b$ 互质，那么$gcd{(a,b)}=1$，所以存在整数$s,t$ 使得 $1 = sa+tb$；<br>​    2. 假设存在一个整数 dd 是正整数 aa 和正整数 bb 的公共因子，则$ d\\mid a$且 $d\\mid b$；<br>​    3. 因为 $d$ 是 $a $的因数，且 $s$ 是整数，所以 $d$ 也一定是 $sa$ 的因数，也就是说 $d\\mid  sa,d∣sa$；<br>​    4. 因为 $d$ 是 $b$ 的因数,且 $t$ 是整数,所以 $d$ 也一定是 $tb$ 的因数，也就是说 $d\\mid tb,d∣tb$；<br>​    5. 存在整数 $m,n$ 使得我们可以将 $sa$ 表示为 $md$，将 $tb$ 表示为 $nd$；所以，我们可以得 $sa+tb = md+nd = (m+n)d$；由此我们可以知道 $d\\mid (sa+tb)$；<br>​    6. 因为我们已知 $sa+tb = 1$,所以 $d \\mid 1$。由此，我们只能是 $d = 1$ 或 $d = -1$。所以 $a$ 和 $b$的公共正整数因子只有 1，所以 $a,b\\in \\mathbb{Z^+}$  互质；<br>​    7. 综上可得“正整数 $a,b\\in \\mathbb{Z^+}$。</p>\n"},{"title":"求极限 题一","date":"2018-07-03T06:42:09.000Z","mathjax":true,"_content":"\n求 $$\\lim_{x \\to 0}\\frac{\\mit{e}^{(1+x)^{\\frac{1}{x}}}-(1+x)^{\\frac{\\mit{e}}{x}}}{x^2}$$\n\n解答：\n$$\n\\begin{align}\n记：&y =\\frac{ln{(1+x)}}{x}\\\\\\\\\n有：&\\lim_{x \\to 0} y = 1\\\\\\\\\n&y’ = -\\frac{ln(1+x)}{x^2}+\\frac{1}{x(1+x)}\\\\\\\\\n则：&\\lim_{x \\to 0}\\frac{dy}{dx}= \\lim_{x \\to 0} y’=-\\frac{1}{2}\\\\\\\\\n\\end{align}\n$$\n\n$$\n\\begin{align}\n所以：原式&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y}-\\mit{e}^{\\mit{e}y}}{x^2}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y+y}-\\mit{e}^{\\mit{e}y+1}}{2x} \\cdot \\frac{dy}{dx}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}-\\mit{e}^{\\mit{e}^y+y}}{4x}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\frac{dy}{dx}-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\frac{dy}{dx}+\\frac{dy}{dx})}{4}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\cdot (\\frac{-1}{2})+\\frac{-1}{2})}{4}\\\\\\\\\n& = \\lim_{y \\to 1}\\frac{\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot (\\frac{-1}{2})}{4}\\\\\\\\\n&= \\frac{\\mit{e}^{\\mit{e}+1}}{8}\n\\end{align}\n$$\n\n","source":"_posts/求极限-题一.md","raw":"---\ntitle: 求极限 题一\ndate: 2018-07-03 14:42:09\nmathjax: true\ntags: \n    - 高等数学\ncategories: 考研\n---\n\n求 $$\\lim_{x \\to 0}\\frac{\\mit{e}^{(1+x)^{\\frac{1}{x}}}-(1+x)^{\\frac{\\mit{e}}{x}}}{x^2}$$\n\n解答：\n$$\n\\begin{align}\n记：&y =\\frac{ln{(1+x)}}{x}\\\\\\\\\n有：&\\lim_{x \\to 0} y = 1\\\\\\\\\n&y’ = -\\frac{ln(1+x)}{x^2}+\\frac{1}{x(1+x)}\\\\\\\\\n则：&\\lim_{x \\to 0}\\frac{dy}{dx}= \\lim_{x \\to 0} y’=-\\frac{1}{2}\\\\\\\\\n\\end{align}\n$$\n\n$$\n\\begin{align}\n所以：原式&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y}-\\mit{e}^{\\mit{e}y}}{x^2}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y+y}-\\mit{e}^{\\mit{e}y+1}}{2x} \\cdot \\frac{dy}{dx}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}-\\mit{e}^{\\mit{e}^y+y}}{4x}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\frac{dy}{dx}-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\frac{dy}{dx}+\\frac{dy}{dx})}{4}\\\\\\\\\n&=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\cdot (\\frac{-1}{2})+\\frac{-1}{2})}{4}\\\\\\\\\n& = \\lim_{y \\to 1}\\frac{\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot (\\frac{-1}{2})}{4}\\\\\\\\\n&= \\frac{\\mit{e}^{\\mit{e}+1}}{8}\n\\end{align}\n$$\n\n","slug":"求极限-题一","published":1,"updated":"2018-07-03T07:34:54.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvv001nplxppead064h","content":"<p>求 $$\\lim_{x \\to 0}\\frac{\\mit{e}^{(1+x)^{\\frac{1}{x}}}-(1+x)^{\\frac{\\mit{e}}{x}}}{x^2}$$</p>\n<p>解答：<br>$$<br>\\begin{align}<br>记：&amp;y =\\frac{ln{(1+x)}}{x}\\\\<br>有：&amp;\\lim_{x \\to 0} y = 1\\\\<br>&amp;y’ = -\\frac{ln(1+x)}{x^2}+\\frac{1}{x(1+x)}\\\\<br>则：&amp;\\lim_{x \\to 0}\\frac{dy}{dx}= \\lim_{x \\to 0} y’=-\\frac{1}{2}\\\\<br>\\end{align}<br>$$</p>\n<p>$$<br>\\begin{align}<br>所以：原式&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y}-\\mit{e}^{\\mit{e}y}}{x^2}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y+y}-\\mit{e}^{\\mit{e}y+1}}{2x} \\cdot \\frac{dy}{dx}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}-\\mit{e}^{\\mit{e}^y+y}}{4x}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\frac{dy}{dx}-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\frac{dy}{dx}+\\frac{dy}{dx})}{4}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\cdot (\\frac{-1}{2})+\\frac{-1}{2})}{4}\\\\<br>&amp; = \\lim_{y \\to 1}\\frac{\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot (\\frac{-1}{2})}{4}\\\\<br>&amp;= \\frac{\\mit{e}^{\\mit{e}+1}}{8}<br>\\end{align}<br>$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>求 $$\\lim_{x \\to 0}\\frac{\\mit{e}^{(1+x)^{\\frac{1}{x}}}-(1+x)^{\\frac{\\mit{e}}{x}}}{x^2}$$</p>\n<p>解答：<br>$$<br>\\begin{align}<br>记：&amp;y =\\frac{ln{(1+x)}}{x}\\\\<br>有：&amp;\\lim_{x \\to 0} y = 1\\\\<br>&amp;y’ = -\\frac{ln(1+x)}{x^2}+\\frac{1}{x(1+x)}\\\\<br>则：&amp;\\lim_{x \\to 0}\\frac{dy}{dx}= \\lim_{x \\to 0} y’=-\\frac{1}{2}\\\\<br>\\end{align}<br>$$</p>\n<p>$$<br>\\begin{align}<br>所以：原式&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y}-\\mit{e}^{\\mit{e}y}}{x^2}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}^y+y}-\\mit{e}^{\\mit{e}y+1}}{2x} \\cdot \\frac{dy}{dx}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}-\\mit{e}^{\\mit{e}^y+y}}{4x}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\frac{dy}{dx}-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\frac{dy}{dx}+\\frac{dy}{dx})}{4}\\\\<br>&amp;=\\lim_{x \\to 0}\\frac{\\mit{e}^{\\mit{e}y+1}\\mit{e}\\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}^y+y}(\\mit{e}^{y}\\cdot (\\frac{-1}{2})+\\frac{-1}{2})}{4}\\\\<br>&amp; = \\lim_{y \\to 1}\\frac{\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot \\mit{e} \\cdot (\\frac{-1}{2})-\\mit{e}^{\\mit{e}+1} \\cdot (\\frac{-1}{2})}{4}\\\\<br>&amp;= \\frac{\\mit{e}^{\\mit{e}+1}}{8}<br>\\end{align}<br>$$</p>\n"},{"title":"隐函数存在定理","date":"2018-07-03T06:26:09.000Z","mathjax":true,"_content":"\n![-w371](/media/15305992039707.jpg)\n\n\n$F(x_0,y_0)=0$,\n$d_x$就是在沿x轴的斜率，$d_y$就是沿y轴的斜率。\n$F'_x$为沿x轴的增量，$F'_y$为沿y轴的增量，$d_z$为沿z轴的增量。\n则：\n$$\\frac{d_y}{d_x}=-\\frac{tan \\theta_1}{tan{\\theta_2}}=-\\frac{\\frac{d_z}{F’_y}}{\\frac{d_z}{F’_x}}=-\\frac{F’_x}{F’_y}$$\n","source":"_posts/隐函数存在定理.md","raw":"---\ntitle: 隐函数存在定理\ndate: 2018-07-03 14:26:09\nmathjax: true\ntags: \n    - 高等数学\ncategories: 考研\n---\n\n![-w371](/media/15305992039707.jpg)\n\n\n$F(x_0,y_0)=0$,\n$d_x$就是在沿x轴的斜率，$d_y$就是沿y轴的斜率。\n$F'_x$为沿x轴的增量，$F'_y$为沿y轴的增量，$d_z$为沿z轴的增量。\n则：\n$$\\frac{d_y}{d_x}=-\\frac{tan \\theta_1}{tan{\\theta_2}}=-\\frac{\\frac{d_z}{F’_y}}{\\frac{d_z}{F’_x}}=-\\frac{F’_x}{F’_y}$$\n","slug":"隐函数存在定理","published":1,"updated":"2018-07-03T06:29:43.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9tvx001rplxpw7581zs3","content":"<p><img src=\"/media/15305992039707.jpg\" alt=\"-w371\"></p>\n<p>$F(x_0,y_0)=0$,<br>$d_x$就是在沿x轴的斜率，$d_y$就是沿y轴的斜率。<br>$F’_x$为沿x轴的增量，$F’_y$为沿y轴的增量，$d_z$为沿z轴的增量。<br>则：<br>$$\\frac{d_y}{d_x}=-\\frac{tan \\theta_1}{tan{\\theta_2}}=-\\frac{\\frac{d_z}{F’_y}}{\\frac{d_z}{F’_x}}=-\\frac{F’_x}{F’_y}$$</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/media/15305992039707.jpg\" alt=\"-w371\"></p>\n<p>$F(x_0,y_0)=0$,<br>$d_x$就是在沿x轴的斜率，$d_y$就是沿y轴的斜率。<br>$F’_x$为沿x轴的增量，$F’_y$为沿y轴的增量，$d_z$为沿z轴的增量。<br>则：<br>$$\\frac{d_y}{d_x}=-\\frac{tan \\theta_1}{tan{\\theta_2}}=-\\frac{\\frac{d_z}{F’_y}}{\\frac{d_z}{F’_x}}=-\\frac{F’_x}{F’_y}$$</p>\n"},{"_content":"\n\n## 简述\n在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。\n机器学习中，我们通过线性回归得到的模型对其它的输入值预测出相对应的输出值。上述的模型我们称它为 假设，函数表达为 $h(x):\\mathcal{X}\\mapsto\\mathcal{Y}$\n\n## 基本过程\n现在，我们有 $m$ 个样本 $\\pmb{x}$,对于每一个样本 $\\pmb{x}^{(i)}$ ，一共有 $n$ 个特征值，为 $\\pmb{x}^{(i)}_{j}$ 。有 $n$ 个系数（模型参数）$\\theta_0\\quad\\theta_1\\dots\\theta_n$。\n则我们的预测函数为:\n\n$$\nh_{\\theta}(x) = \\theta_0 +\\theta_1 x_1+\\theta_2 x_2 +\\dots+\\theta_n x_n\n$$\n\n为了简单化函数的表示，我们规定 $x_0 = 1$，因此函数中的的参数 $\\theta_0$ 就是参数 $\\mathcal{bais}$ 。\n\n上面提到的$\\mathcal{bais}$，它的的作用会在以后的笔记中详细解释。\n在计算机中，为了简便计算，我们将数据向量化（vectorize）：\n$$\nh(\\pmb{x}) = \\sum^{n}_{i=0} \\theta_i x_i = \\pmb{\\theta}^{\\mathit{T}} \\pmb{x},\\quad \\pmb{\\theta} \\in \\mathbb{R}^{n+1}, \\pmb{x} \\in \\mathbb{R}^{n+1}\n$$\n在周志华的《机器学习》一书中，则将$h_{\\theta}(\\pmb{x})$，表示为：\n$$\nf(\\pmb{x})=\\pmb{w}^T\\pmb{x}+b,\\quad \\pmb{w}\\in \\mathbb{R}^n,\\pmb{x}\\in \\mathbb{R}^n,\n$$\n其实两个函数是一样的，因为有$\\theta_0 = b$。但是在计算机中，第一种向量表示比较方便储存数据，我的笔记也就这么记了。\n\n为了使估计值$\\hat{y}$接近于$y$，我们定义**cost function** :\n$$\n\\mathit{J}(\\theta) = \\frac{1}{2m}\\sum ^{m}_{i = 1}(h_{\\theta}(x^{(i)})-y^{(i)})^2\n$$\n有了cost function，我们的目标就是：\n\n$$\n\\DeclareMathOperator*{\\argmin}{arg\\,min} \n\\pmb{\\theta} = \\mathop{\\argmin}_{}{\\mathit{J}_{\\theta}(x)}\n$$\n\n## 求解 $\\theta$ 的方法\n\n> 基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。——周志华《机器学习》\n\n上述的 cost function 就是基于了均方误差。最小二乘法就是试图找到一条“线”，使所有样本到直线的欧式距离之和最小。\n\n求解 $\\pmb{\\theta}$ 的方法有两个，一个是梯度下降（gradient descent），一个是通过求导得出极值。\n\n### 梯度下降（gradient descent） \n\n首先，梯度下降是通过不断更新 $\\theta$ 的值，而找到最优的情况。对于一个凸函数来说，是让当前的 $\\theta $ 往函数下降最快的方向进行移动，以此更新 $\\theta $ ，而更新的量，就是函数的导数了。所以，对于某一特征系数有更新公式：\n$$\n\\theta_j := \\theta_j-\\alpha \\cdot \\frac{1}{m} \\cdot \\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta)\n$$\n我们从一个样本来看梯度下降，首先对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：\n$$\n\\begin{equation}\n\\begin{aligned}\n\\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta) &= \\frac{\\partial}{\\partial\\theta_j}\\frac{1}{2}(h_{\\theta}(x)-y)^2\\\\\n&=2\\cdot\\frac{1}{2}(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(h_{\\theta}(x)-y)\\\\\n&=(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(\\sum^n_{i=0}\\theta_ix_i-y)\\\\\n&=(h_{\\theta}(x)-y)x_j\n\\end{aligned} \n\\end{equation}\n$$\n于是，更新公式可写为：\n$$\n\\begin{aligned}\n\\theta_j &:= \\theta_j-\\alpha \\cdot(h_{\\theta}(x)-y)x_j\\\\\n&:=\\theta_j +\\alpha \\cdot(y-h_{\\theta}(x))x_j\n\\end{aligned}\n$$\n对于一个训练集，我们就得到：\n$$\n\\begin{eqnarray*}\n&&\\large{重复直到收敛}\\{\\\\\n&& \\quad \\quad \\theta_j := \\theta_j +\\alpha \\cdot \\frac{1}{m} \\cdot \\sum^{m}_{i=1}(y^{(i)}-h_{\\theta}(x^{(i)}))x^{(i)}_j\\\\\n &&\\}\n\\end{eqnarray*}\n$$\n\n### 求导\n\n>   The \"Normal Equation\" is a method of finding the optimum theta without iteration.\n\n首先，我们定义一下 $X$，$X$ 是一个 $m \\times n$ 的矩阵，事实上，考虑截距（$\\theta_0$），矩阵应该为  $m \\times (n+1)$ ，\n\n我们有：\n$$\nX = \\left[\n \\begin{matrix}\n-(x^{(1)})^T-\\\\\n-(x^{(2)})^T- \\\\\n\\vdots\\\\\n-(x^{(m)})^T- \n  \\end{matrix}\n  \\right]\n$$\n然后有 $\\pmb{y}$  ：\n$$\n\\pmb{y} = \\left[\n \\begin{matrix}\ny^{(1)}\\\\\ny^{(2)}\\\\\n\\vdots\\\\\ny^{(m})\n  \\end{matrix}\n  \\right],\\pmb{y} \\in \\mathbb{R}^m\n$$\n于是有：\n$$\nJ(\\pmb{\\theta}) = \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\n$$\n因此，对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：\n$$\n\\begin{aligned}\n\\nabla_{\\theta} J(\\pmb{\\theta}) &= \\nabla_{\\theta} \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\\\\\n& = \\frac{1}{2}\\nabla_{\\theta} (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\\\\n& =\\frac{1}{2}\\nabla_{\\theta} tr (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\\\\n& =  \\frac{1}{2}\\nabla_{\\theta}(tr \\pmb{\\theta}^TX^TX\\pmb{\\theta} - 2 tr \\pmb{y}^TX\\pmb{\\theta})\\\\\n&=\\frac{1}{2} (X^TX\\pmb{\\theta}+X^TX\\pmb{\\theta}-2X^T\\pmb{y})\\\\\n&=X^TX\\pmb{\\theta}-X^T\\pmb{y}\n\\end{aligned}\n$$\n当对 $\\theta$ 的偏导为 $0$ 时，可得极值，得：\n$$\nX^TX\\pmb{\\theta} = X^T\\pmb{y}\n$$\n得到最优 $\\theta$ 解 ：\n$$\n\\pmb{\\theta} = (X^TX)^{-1}X^T\\pmb{y}\n$$\n\n## 概率解释（Probabilistic Interpretation）\n\n### 简单说明\n\n在对数据进行概率假设的基础上，最小二乘回归得到的 $\\theta$ 和最大似然法估计的 $\\theta$ 是一致的。所以这是一系列的假设，其前提是认为最小二乘回归（least-squares regression）能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计（maximum likelihood estimation）。\n\n### 证明\n\n首先假设目标变量与输入变量存在以下等量关系：\n$$\n\\pmb{y}^{(i)}  = \\pmb{\\theta}^T\\pmb{x}+ \\pmb{\\varepsilon}^{(i)}\n$$\n上式的 $\\pmb{\\varepsilon}^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果 (比如可能某些特征对于房价的影响很明显，但我们做回归的时候忽略掉了)或者随机的噪音信息（random noise）。进一步假设 $\\pmb{\\varepsilon}^{(i)}$ 是独立同分布的 (IID ，independently and identically distributed) ，服从高斯分布（Gaussian distribution），其平均值为 $0$，方差（variance）为 $\\sigma^2$。这样就可以把这个假设写成 $\\pmb{\\varepsilon}^{(i)} \\sim \\mathcal{N}(0,\\sigma^2)$。然后 $\\pmb{\\varepsilon}^{(i)}$ 的密度函数就是：\n$$\np(  \\pmb{\\varepsilon}^{(i)} ) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})\n$$\n这意味着存在下面的等量关系：\n$$\np(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})\n$$\n上式为，在 $\\theta$ 取某个固定值的情况下，这个等式表达为，在 $\\pmb{x}^{(i)}$ 的情况下发生 $\\pmb{y}^{(i)}$ 的概率， 通常可以看做是一个 $\\pmb{y}^{(i)}$ 的函数。当我们要把它当做 $\\theta$ 的函数的时候，就称它为似然函数（likelihood function）在整个数据集下有：\n$$\nL(\\pmb{\\theta}) = L(\\pmb{\\theta};X,\\pmb{y}) = p(\\pmb{y}|X;\\pmb{\\theta })\n$$\n结合之前对 $ \\pmb{\\varepsilon}^{(i)}$ 的独立性假设（这里对 $\\pmb{y}^{(i)}$ 以及给定的 $\\pmb{x}^{(i)}$ 也都做同样假设），就可以把上面这个等式改写成下面的形式： \n$$\n\\begin{align}\nL(\\pmb{\\theta}) &= \\prod^m_{i=1}(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) \\\\\n&= \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})\n\\end{align}\n$$\n最大似然法（maximum likelihood）告诉我们要选择能让数据的似然函数尽可能大的 $\\theta$ 。也就是说，找到  $\\theta$ 能够让函数 $L(\\pmb{\\theta})$ 取到最大值。\n\n为了找到 $L(\\pmb{\\theta})$ 的最大值，我们不能直接使用 $L(\\pmb{\\theta})$ ，而要使用严格递增的 $L(\\pmb{\\theta})$ 的函数求最大值。使用对数函数来找对数函数 $L(\\pmb{\\theta})$ 的最大值是一种方法，而且求导来说就简单了一些：\n$$\n\\begin{align}\nv& = \\log{\\mit{L}(\\pmb{\\theta})}\\\\\n&=\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\\\\n&=\\sum^m_{i=1}\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\\\\n&=m\\log{ \\frac{1}{\\sqrt{2\\pi}\\sigma} -\\frac{1}{\\sigma^2} \\cdot \\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}\n\\end{align}\n$$\n对于上式 ，由于$m\\log{\\frac{1}{\\sqrt{2\\pi}\\sigma}}$ ，$\\frac{1}{\\sigma^2}$ 值不变，那么 $\\scr{L}(\\pmb{\\theta})$ 取最大，即求下面的式子最小：\n$$\n\\frac{1}{2}\\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2\n$$\n证毕。\n\n## 多项式回归（Polynomial Regession）\n\n多项式回归可以用来拟合二次、三次、高次模型，通过使用 $\\pmb{x}^2,\\sqrt{\\pmb{x}}$ 等进行拟合。 \n\n这样便将高阶方程模型转换成线性回归模型。这也算是 **特征缩放(Features Scaling)** 的一种。\n\n\n","source":"_posts/Liner-Regressionmd.md","raw":"\n\n## 简述\n在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。\n机器学习中，我们通过线性回归得到的模型对其它的输入值预测出相对应的输出值。上述的模型我们称它为 假设，函数表达为 $h(x):\\mathcal{X}\\mapsto\\mathcal{Y}$\n\n## 基本过程\n现在，我们有 $m$ 个样本 $\\pmb{x}$,对于每一个样本 $\\pmb{x}^{(i)}$ ，一共有 $n$ 个特征值，为 $\\pmb{x}^{(i)}_{j}$ 。有 $n$ 个系数（模型参数）$\\theta_0\\quad\\theta_1\\dots\\theta_n$。\n则我们的预测函数为:\n\n$$\nh_{\\theta}(x) = \\theta_0 +\\theta_1 x_1+\\theta_2 x_2 +\\dots+\\theta_n x_n\n$$\n\n为了简单化函数的表示，我们规定 $x_0 = 1$，因此函数中的的参数 $\\theta_0$ 就是参数 $\\mathcal{bais}$ 。\n\n上面提到的$\\mathcal{bais}$，它的的作用会在以后的笔记中详细解释。\n在计算机中，为了简便计算，我们将数据向量化（vectorize）：\n$$\nh(\\pmb{x}) = \\sum^{n}_{i=0} \\theta_i x_i = \\pmb{\\theta}^{\\mathit{T}} \\pmb{x},\\quad \\pmb{\\theta} \\in \\mathbb{R}^{n+1}, \\pmb{x} \\in \\mathbb{R}^{n+1}\n$$\n在周志华的《机器学习》一书中，则将$h_{\\theta}(\\pmb{x})$，表示为：\n$$\nf(\\pmb{x})=\\pmb{w}^T\\pmb{x}+b,\\quad \\pmb{w}\\in \\mathbb{R}^n,\\pmb{x}\\in \\mathbb{R}^n,\n$$\n其实两个函数是一样的，因为有$\\theta_0 = b$。但是在计算机中，第一种向量表示比较方便储存数据，我的笔记也就这么记了。\n\n为了使估计值$\\hat{y}$接近于$y$，我们定义**cost function** :\n$$\n\\mathit{J}(\\theta) = \\frac{1}{2m}\\sum ^{m}_{i = 1}(h_{\\theta}(x^{(i)})-y^{(i)})^2\n$$\n有了cost function，我们的目标就是：\n\n$$\n\\DeclareMathOperator*{\\argmin}{arg\\,min} \n\\pmb{\\theta} = \\mathop{\\argmin}_{}{\\mathit{J}_{\\theta}(x)}\n$$\n\n## 求解 $\\theta$ 的方法\n\n> 基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。——周志华《机器学习》\n\n上述的 cost function 就是基于了均方误差。最小二乘法就是试图找到一条“线”，使所有样本到直线的欧式距离之和最小。\n\n求解 $\\pmb{\\theta}$ 的方法有两个，一个是梯度下降（gradient descent），一个是通过求导得出极值。\n\n### 梯度下降（gradient descent） \n\n首先，梯度下降是通过不断更新 $\\theta$ 的值，而找到最优的情况。对于一个凸函数来说，是让当前的 $\\theta $ 往函数下降最快的方向进行移动，以此更新 $\\theta $ ，而更新的量，就是函数的导数了。所以，对于某一特征系数有更新公式：\n$$\n\\theta_j := \\theta_j-\\alpha \\cdot \\frac{1}{m} \\cdot \\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta)\n$$\n我们从一个样本来看梯度下降，首先对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：\n$$\n\\begin{equation}\n\\begin{aligned}\n\\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta) &= \\frac{\\partial}{\\partial\\theta_j}\\frac{1}{2}(h_{\\theta}(x)-y)^2\\\\\n&=2\\cdot\\frac{1}{2}(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(h_{\\theta}(x)-y)\\\\\n&=(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(\\sum^n_{i=0}\\theta_ix_i-y)\\\\\n&=(h_{\\theta}(x)-y)x_j\n\\end{aligned} \n\\end{equation}\n$$\n于是，更新公式可写为：\n$$\n\\begin{aligned}\n\\theta_j &:= \\theta_j-\\alpha \\cdot(h_{\\theta}(x)-y)x_j\\\\\n&:=\\theta_j +\\alpha \\cdot(y-h_{\\theta}(x))x_j\n\\end{aligned}\n$$\n对于一个训练集，我们就得到：\n$$\n\\begin{eqnarray*}\n&&\\large{重复直到收敛}\\{\\\\\n&& \\quad \\quad \\theta_j := \\theta_j +\\alpha \\cdot \\frac{1}{m} \\cdot \\sum^{m}_{i=1}(y^{(i)}-h_{\\theta}(x^{(i)}))x^{(i)}_j\\\\\n &&\\}\n\\end{eqnarray*}\n$$\n\n### 求导\n\n>   The \"Normal Equation\" is a method of finding the optimum theta without iteration.\n\n首先，我们定义一下 $X$，$X$ 是一个 $m \\times n$ 的矩阵，事实上，考虑截距（$\\theta_0$），矩阵应该为  $m \\times (n+1)$ ，\n\n我们有：\n$$\nX = \\left[\n \\begin{matrix}\n-(x^{(1)})^T-\\\\\n-(x^{(2)})^T- \\\\\n\\vdots\\\\\n-(x^{(m)})^T- \n  \\end{matrix}\n  \\right]\n$$\n然后有 $\\pmb{y}$  ：\n$$\n\\pmb{y} = \\left[\n \\begin{matrix}\ny^{(1)}\\\\\ny^{(2)}\\\\\n\\vdots\\\\\ny^{(m})\n  \\end{matrix}\n  \\right],\\pmb{y} \\in \\mathbb{R}^m\n$$\n于是有：\n$$\nJ(\\pmb{\\theta}) = \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\n$$\n因此，对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：\n$$\n\\begin{aligned}\n\\nabla_{\\theta} J(\\pmb{\\theta}) &= \\nabla_{\\theta} \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\\\\\n& = \\frac{1}{2}\\nabla_{\\theta} (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\\\\n& =\\frac{1}{2}\\nabla_{\\theta} tr (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\\\\n& =  \\frac{1}{2}\\nabla_{\\theta}(tr \\pmb{\\theta}^TX^TX\\pmb{\\theta} - 2 tr \\pmb{y}^TX\\pmb{\\theta})\\\\\n&=\\frac{1}{2} (X^TX\\pmb{\\theta}+X^TX\\pmb{\\theta}-2X^T\\pmb{y})\\\\\n&=X^TX\\pmb{\\theta}-X^T\\pmb{y}\n\\end{aligned}\n$$\n当对 $\\theta$ 的偏导为 $0$ 时，可得极值，得：\n$$\nX^TX\\pmb{\\theta} = X^T\\pmb{y}\n$$\n得到最优 $\\theta$ 解 ：\n$$\n\\pmb{\\theta} = (X^TX)^{-1}X^T\\pmb{y}\n$$\n\n## 概率解释（Probabilistic Interpretation）\n\n### 简单说明\n\n在对数据进行概率假设的基础上，最小二乘回归得到的 $\\theta$ 和最大似然法估计的 $\\theta$ 是一致的。所以这是一系列的假设，其前提是认为最小二乘回归（least-squares regression）能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计（maximum likelihood estimation）。\n\n### 证明\n\n首先假设目标变量与输入变量存在以下等量关系：\n$$\n\\pmb{y}^{(i)}  = \\pmb{\\theta}^T\\pmb{x}+ \\pmb{\\varepsilon}^{(i)}\n$$\n上式的 $\\pmb{\\varepsilon}^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果 (比如可能某些特征对于房价的影响很明显，但我们做回归的时候忽略掉了)或者随机的噪音信息（random noise）。进一步假设 $\\pmb{\\varepsilon}^{(i)}$ 是独立同分布的 (IID ，independently and identically distributed) ，服从高斯分布（Gaussian distribution），其平均值为 $0$，方差（variance）为 $\\sigma^2$。这样就可以把这个假设写成 $\\pmb{\\varepsilon}^{(i)} \\sim \\mathcal{N}(0,\\sigma^2)$。然后 $\\pmb{\\varepsilon}^{(i)}$ 的密度函数就是：\n$$\np(  \\pmb{\\varepsilon}^{(i)} ) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})\n$$\n这意味着存在下面的等量关系：\n$$\np(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})\n$$\n上式为，在 $\\theta$ 取某个固定值的情况下，这个等式表达为，在 $\\pmb{x}^{(i)}$ 的情况下发生 $\\pmb{y}^{(i)}$ 的概率， 通常可以看做是一个 $\\pmb{y}^{(i)}$ 的函数。当我们要把它当做 $\\theta$ 的函数的时候，就称它为似然函数（likelihood function）在整个数据集下有：\n$$\nL(\\pmb{\\theta}) = L(\\pmb{\\theta};X,\\pmb{y}) = p(\\pmb{y}|X;\\pmb{\\theta })\n$$\n结合之前对 $ \\pmb{\\varepsilon}^{(i)}$ 的独立性假设（这里对 $\\pmb{y}^{(i)}$ 以及给定的 $\\pmb{x}^{(i)}$ 也都做同样假设），就可以把上面这个等式改写成下面的形式： \n$$\n\\begin{align}\nL(\\pmb{\\theta}) &= \\prod^m_{i=1}(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) \\\\\n&= \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})\n\\end{align}\n$$\n最大似然法（maximum likelihood）告诉我们要选择能让数据的似然函数尽可能大的 $\\theta$ 。也就是说，找到  $\\theta$ 能够让函数 $L(\\pmb{\\theta})$ 取到最大值。\n\n为了找到 $L(\\pmb{\\theta})$ 的最大值，我们不能直接使用 $L(\\pmb{\\theta})$ ，而要使用严格递增的 $L(\\pmb{\\theta})$ 的函数求最大值。使用对数函数来找对数函数 $L(\\pmb{\\theta})$ 的最大值是一种方法，而且求导来说就简单了一些：\n$$\n\\begin{align}\nv& = \\log{\\mit{L}(\\pmb{\\theta})}\\\\\n&=\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\\\\n&=\\sum^m_{i=1}\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\\\\n&=m\\log{ \\frac{1}{\\sqrt{2\\pi}\\sigma} -\\frac{1}{\\sigma^2} \\cdot \\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}\n\\end{align}\n$$\n对于上式 ，由于$m\\log{\\frac{1}{\\sqrt{2\\pi}\\sigma}}$ ，$\\frac{1}{\\sigma^2}$ 值不变，那么 $\\scr{L}(\\pmb{\\theta})$ 取最大，即求下面的式子最小：\n$$\n\\frac{1}{2}\\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2\n$$\n证毕。\n\n## 多项式回归（Polynomial Regession）\n\n多项式回归可以用来拟合二次、三次、高次模型，通过使用 $\\pmb{x}^2,\\sqrt{\\pmb{x}}$ 等进行拟合。 \n\n这样便将高阶方程模型转换成线性回归模型。这也算是 **特征缩放(Features Scaling)** 的一种。\n\n\n","slug":"Liner-Regressionmd","published":1,"date":"2017-11-05T04:06:09.000Z","updated":"2018-07-03T07:05:19.200Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9u1h003oplxp4ozk1jx4","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。<br>机器学习中，我们通过线性回归得到的模型对其它的输入值预测出相对应的输出值。上述的模型我们称它为 假设，函数表达为 $h(x):\\mathcal{X}\\mapsto\\mathcal{Y}$</p>\n<h2 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h2><p>现在，我们有 $m$ 个样本 $\\pmb{x}$,对于每一个样本 $\\pmb{x}^{(i)}$ ，一共有 $n$ 个特征值，为 $\\pmb{x}^{(i)}_{j}$ 。有 $n$ 个系数（模型参数）$\\theta_0\\quad\\theta_1\\dots\\theta_n$。<br>则我们的预测函数为:</p>\n<p>$$<br>h_{\\theta}(x) = \\theta_0 +\\theta_1 x_1+\\theta_2 x_2 +\\dots+\\theta_n x_n<br>$$</p>\n<p>为了简单化函数的表示，我们规定 $x_0 = 1$，因此函数中的的参数 $\\theta_0$ 就是参数 $\\mathcal{bais}$ 。</p>\n<p>上面提到的$\\mathcal{bais}$，它的的作用会在以后的笔记中详细解释。<br>在计算机中，为了简便计算，我们将数据向量化（vectorize）：<br>$$<br>h(\\pmb{x}) = \\sum^{n}_{i=0} \\theta_i x_i = \\pmb{\\theta}^{\\mathit{T}} \\pmb{x},\\quad \\pmb{\\theta} \\in \\mathbb{R}^{n+1}, \\pmb{x} \\in \\mathbb{R}^{n+1}<br>$$<br>在周志华的《机器学习》一书中，则将$h_{\\theta}(\\pmb{x})$，表示为：<br>$$<br>f(\\pmb{x})=\\pmb{w}^T\\pmb{x}+b,\\quad \\pmb{w}\\in \\mathbb{R}^n,\\pmb{x}\\in \\mathbb{R}^n,<br>$$<br>其实两个函数是一样的，因为有$\\theta_0 = b$。但是在计算机中，第一种向量表示比较方便储存数据，我的笔记也就这么记了。</p>\n<p>为了使估计值$\\hat{y}$接近于$y$，我们定义<strong>cost function</strong> :<br>$$<br>\\mathit{J}(\\theta) = \\frac{1}{2m}\\sum ^{m}<em>{i = 1}(h</em>{\\theta}(x^{(i)})-y^{(i)})^2<br>$$<br>有了cost function，我们的目标就是：</p>\n<p>$$<br>\\DeclareMathOperator*{\\argmin}{arg\\,min}<br>\\pmb{\\theta} = \\mathop{\\argmin}<em>{}{\\mathit{J}</em>{\\theta}(x)}<br>$$</p>\n<h2 id=\"求解-theta-的方法\"><a href=\"#求解-theta-的方法\" class=\"headerlink\" title=\"求解 $\\theta$ 的方法\"></a>求解 $\\theta$ 的方法</h2><blockquote>\n<p>基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。——周志华《机器学习》</p>\n</blockquote>\n<p>上述的 cost function 就是基于了均方误差。最小二乘法就是试图找到一条“线”，使所有样本到直线的欧式距离之和最小。</p>\n<p>求解 $\\pmb{\\theta}$ 的方法有两个，一个是梯度下降（gradient descent），一个是通过求导得出极值。</p>\n<h3 id=\"梯度下降（gradient-descent）\"><a href=\"#梯度下降（gradient-descent）\" class=\"headerlink\" title=\"梯度下降（gradient descent）\"></a>梯度下降（gradient descent）</h3><p>首先，梯度下降是通过不断更新 $\\theta$ 的值，而找到最优的情况。对于一个凸函数来说，是让当前的 $\\theta $ 往函数下降最快的方向进行移动，以此更新 $\\theta $ ，而更新的量，就是函数的导数了。所以，对于某一特征系数有更新公式：<br>$$<br>\\theta_j := \\theta_j-\\alpha \\cdot \\frac{1}{m} \\cdot \\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta)<br>$$<br>我们从一个样本来看梯度下降，首先对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：<br>$$<br>\\begin{equation}<br>\\begin{aligned}<br>\\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta) &amp;= \\frac{\\partial}{\\partial\\theta_j}\\frac{1}{2}(h_{\\theta}(x)-y)^2\\<br>&amp;=2\\cdot\\frac{1}{2}(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(h_{\\theta}(x)-y)\\<br>&amp;=(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(\\sum^n_{i=0}\\theta_ix_i-y)\\<br>&amp;=(h_{\\theta}(x)-y)x_j<br>\\end{aligned}<br>\\end{equation}<br>$$<br>于是，更新公式可写为：<br>$$<br>\\begin{aligned}<br>\\theta_j &amp;:= \\theta_j-\\alpha \\cdot(h_{\\theta}(x)-y)x_j\\<br>&amp;:=\\theta_j +\\alpha \\cdot(y-h_{\\theta}(x))x_j<br>\\end{aligned}<br>$$<br>对于一个训练集，我们就得到：<br>$$<br>\\begin{eqnarray<em>}<br>&amp;&amp;\\large{重复直到收敛}{\\<br>&amp;&amp; \\quad \\quad \\theta_j := \\theta_j +\\alpha \\cdot \\frac{1}{m} \\cdot \\sum^{m}<em>{i=1}(y^{(i)}-h</em>{\\theta}(x^{(i)}))x^{(i)}_j\\<br> &amp;&amp;}<br>\\end{eqnarray</em>}<br>$$</p>\n<h3 id=\"求导\"><a href=\"#求导\" class=\"headerlink\" title=\"求导\"></a>求导</h3><blockquote>\n<p>  The “Normal Equation” is a method of finding the optimum theta without iteration.</p>\n</blockquote>\n<p>首先，我们定义一下 $X$，$X$ 是一个 $m \\times n$ 的矩阵，事实上，考虑截距（$\\theta_0$），矩阵应该为  $m \\times (n+1)$ ，</p>\n<p>我们有：<br>$$<br>X = \\left[<br> \\begin{matrix}<br>-(x^{(1)})^T-\\<br>-(x^{(2)})^T- \\<br>\\vdots\\<br>-(x^{(m)})^T-<br>  \\end{matrix}<br>  \\right]<br>$$<br>然后有 $\\pmb{y}$  ：<br>$$<br>\\pmb{y} = \\left[<br> \\begin{matrix}<br>y^{(1)}\\<br>y^{(2)}\\<br>\\vdots\\<br>y^{(m})<br>  \\end{matrix}<br>  \\right],\\pmb{y} \\in \\mathbb{R}^m<br>$$<br>于是有：<br>$$<br>J(\\pmb{\\theta}) = \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})<br>$$<br>因此，对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：<br>$$<br>\\begin{aligned}<br>\\nabla_{\\theta} J(\\pmb{\\theta}) &amp;= \\nabla_{\\theta} \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\\<br>&amp; = \\frac{1}{2}\\nabla_{\\theta} (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\<br>&amp; =\\frac{1}{2}\\nabla_{\\theta} tr (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\<br>&amp; =  \\frac{1}{2}\\nabla_{\\theta}(tr \\pmb{\\theta}^TX^TX\\pmb{\\theta} - 2 tr \\pmb{y}^TX\\pmb{\\theta})\\<br>&amp;=\\frac{1}{2} (X^TX\\pmb{\\theta}+X^TX\\pmb{\\theta}-2X^T\\pmb{y})\\<br>&amp;=X^TX\\pmb{\\theta}-X^T\\pmb{y}<br>\\end{aligned}<br>$$<br>当对 $\\theta$ 的偏导为 $0$ 时，可得极值，得：<br>$$<br>X^TX\\pmb{\\theta} = X^T\\pmb{y}<br>$$<br>得到最优 $\\theta$ 解 ：<br>$$<br>\\pmb{\\theta} = (X^TX)^{-1}X^T\\pmb{y}<br>$$</p>\n<h2 id=\"概率解释（Probabilistic-Interpretation）\"><a href=\"#概率解释（Probabilistic-Interpretation）\" class=\"headerlink\" title=\"概率解释（Probabilistic Interpretation）\"></a>概率解释（Probabilistic Interpretation）</h2><h3 id=\"简单说明\"><a href=\"#简单说明\" class=\"headerlink\" title=\"简单说明\"></a>简单说明</h3><p>在对数据进行概率假设的基础上，最小二乘回归得到的 $\\theta$ 和最大似然法估计的 $\\theta$ 是一致的。所以这是一系列的假设，其前提是认为最小二乘回归（least-squares regression）能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计（maximum likelihood estimation）。</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>首先假设目标变量与输入变量存在以下等量关系：<br>$$<br>\\pmb{y}^{(i)}  = \\pmb{\\theta}^T\\pmb{x}+ \\pmb{\\varepsilon}^{(i)}<br>$$<br>上式的 $\\pmb{\\varepsilon}^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果 (比如可能某些特征对于房价的影响很明显，但我们做回归的时候忽略掉了)或者随机的噪音信息（random noise）。进一步假设 $\\pmb{\\varepsilon}^{(i)}$ 是独立同分布的 (IID ，independently and identically distributed) ，服从高斯分布（Gaussian distribution），其平均值为 $0$，方差（variance）为 $\\sigma^2$。这样就可以把这个假设写成 $\\pmb{\\varepsilon}^{(i)} \\sim \\mathcal{N}(0,\\sigma^2)$。然后 $\\pmb{\\varepsilon}^{(i)}$ 的密度函数就是：<br>$$<br>p(  \\pmb{\\varepsilon}^{(i)} ) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})<br>$$<br>这意味着存在下面的等量关系：<br>$$<br>p(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})<br>$$<br>上式为，在 $\\theta$ 取某个固定值的情况下，这个等式表达为，在 $\\pmb{x}^{(i)}$ 的情况下发生 $\\pmb{y}^{(i)}$ 的概率， 通常可以看做是一个 $\\pmb{y}^{(i)}$ 的函数。当我们要把它当做 $\\theta$ 的函数的时候，就称它为似然函数（likelihood function）在整个数据集下有：<br>$$<br>L(\\pmb{\\theta}) = L(\\pmb{\\theta};X,\\pmb{y}) = p(\\pmb{y}|X;\\pmb{\\theta })<br>$$<br>结合之前对 $ \\pmb{\\varepsilon}^{(i)}$ 的独立性假设（这里对 $\\pmb{y}^{(i)}$ 以及给定的 $\\pmb{x}^{(i)}$ 也都做同样假设），就可以把上面这个等式改写成下面的形式：<br>$$<br>\\begin{align}<br>L(\\pmb{\\theta}) &amp;= \\prod^m_{i=1}(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) \\<br>&amp;= \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})<br>\\end{align}<br>$$<br>最大似然法（maximum likelihood）告诉我们要选择能让数据的似然函数尽可能大的 $\\theta$ 。也就是说，找到  $\\theta$ 能够让函数 $L(\\pmb{\\theta})$ 取到最大值。</p>\n<p>为了找到 $L(\\pmb{\\theta})$ 的最大值，我们不能直接使用 $L(\\pmb{\\theta})$ ，而要使用严格递增的 $L(\\pmb{\\theta})$ 的函数求最大值。使用对数函数来找对数函数 $L(\\pmb{\\theta})$ 的最大值是一种方法，而且求导来说就简单了一些：<br>$$<br>\\begin{align}<br>v&amp; = \\log{\\mit{L}(\\pmb{\\theta})}\\<br>&amp;=\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\<br>&amp;=\\sum^m_{i=1}\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\<br>&amp;=m\\log{ \\frac{1}{\\sqrt{2\\pi}\\sigma} -\\frac{1}{\\sigma^2} \\cdot \\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}<br>\\end{align}<br>$$<br>对于上式 ，由于$m\\log{\\frac{1}{\\sqrt{2\\pi}\\sigma}}$ ，$\\frac{1}{\\sigma^2}$ 值不变，那么 $\\scr{L}(\\pmb{\\theta})$ 取最大，即求下面的式子最小：<br>$$<br>\\frac{1}{2}\\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2<br>$$<br>证毕。</p>\n<h2 id=\"多项式回归（Polynomial-Regession）\"><a href=\"#多项式回归（Polynomial-Regession）\" class=\"headerlink\" title=\"多项式回归（Polynomial Regession）\"></a>多项式回归（Polynomial Regession）</h2><p>多项式回归可以用来拟合二次、三次、高次模型，通过使用 $\\pmb{x}^2,\\sqrt{\\pmb{x}}$ 等进行拟合。 </p>\n<p>这样便将高阶方程模型转换成线性回归模型。这也算是 <strong>特征缩放(Features Scaling)</strong> 的一种。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。<br>机器学习中，我们通过线性回归得到的模型对其它的输入值预测出相对应的输出值。上述的模型我们称它为 假设，函数表达为 $h(x):\\mathcal{X}\\mapsto\\mathcal{Y}$</p>\n<h2 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h2><p>现在，我们有 $m$ 个样本 $\\pmb{x}$,对于每一个样本 $\\pmb{x}^{(i)}$ ，一共有 $n$ 个特征值，为 $\\pmb{x}^{(i)}_{j}$ 。有 $n$ 个系数（模型参数）$\\theta_0\\quad\\theta_1\\dots\\theta_n$。<br>则我们的预测函数为:</p>\n<p>$$<br>h_{\\theta}(x) = \\theta_0 +\\theta_1 x_1+\\theta_2 x_2 +\\dots+\\theta_n x_n<br>$$</p>\n<p>为了简单化函数的表示，我们规定 $x_0 = 1$，因此函数中的的参数 $\\theta_0$ 就是参数 $\\mathcal{bais}$ 。</p>\n<p>上面提到的$\\mathcal{bais}$，它的的作用会在以后的笔记中详细解释。<br>在计算机中，为了简便计算，我们将数据向量化（vectorize）：<br>$$<br>h(\\pmb{x}) = \\sum^{n}_{i=0} \\theta_i x_i = \\pmb{\\theta}^{\\mathit{T}} \\pmb{x},\\quad \\pmb{\\theta} \\in \\mathbb{R}^{n+1}, \\pmb{x} \\in \\mathbb{R}^{n+1}<br>$$<br>在周志华的《机器学习》一书中，则将$h_{\\theta}(\\pmb{x})$，表示为：<br>$$<br>f(\\pmb{x})=\\pmb{w}^T\\pmb{x}+b,\\quad \\pmb{w}\\in \\mathbb{R}^n,\\pmb{x}\\in \\mathbb{R}^n,<br>$$<br>其实两个函数是一样的，因为有$\\theta_0 = b$。但是在计算机中，第一种向量表示比较方便储存数据，我的笔记也就这么记了。</p>\n<p>为了使估计值$\\hat{y}$接近于$y$，我们定义<strong>cost function</strong> :<br>$$<br>\\mathit{J}(\\theta) = \\frac{1}{2m}\\sum ^{m}<em>{i = 1}(h</em>{\\theta}(x^{(i)})-y^{(i)})^2<br>$$<br>有了cost function，我们的目标就是：</p>\n<p>$$<br>\\DeclareMathOperator*{\\argmin}{arg\\,min}<br>\\pmb{\\theta} = \\mathop{\\argmin}<em>{}{\\mathit{J}</em>{\\theta}(x)}<br>$$</p>\n<h2 id=\"求解-theta-的方法\"><a href=\"#求解-theta-的方法\" class=\"headerlink\" title=\"求解 $\\theta$ 的方法\"></a>求解 $\\theta$ 的方法</h2><blockquote>\n<p>基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。——周志华《机器学习》</p>\n</blockquote>\n<p>上述的 cost function 就是基于了均方误差。最小二乘法就是试图找到一条“线”，使所有样本到直线的欧式距离之和最小。</p>\n<p>求解 $\\pmb{\\theta}$ 的方法有两个，一个是梯度下降（gradient descent），一个是通过求导得出极值。</p>\n<h3 id=\"梯度下降（gradient-descent）\"><a href=\"#梯度下降（gradient-descent）\" class=\"headerlink\" title=\"梯度下降（gradient descent）\"></a>梯度下降（gradient descent）</h3><p>首先，梯度下降是通过不断更新 $\\theta$ 的值，而找到最优的情况。对于一个凸函数来说，是让当前的 $\\theta $ 往函数下降最快的方向进行移动，以此更新 $\\theta $ ，而更新的量，就是函数的导数了。所以，对于某一特征系数有更新公式：<br>$$<br>\\theta_j := \\theta_j-\\alpha \\cdot \\frac{1}{m} \\cdot \\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta)<br>$$<br>我们从一个样本来看梯度下降，首先对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：<br>$$<br>\\begin{equation}<br>\\begin{aligned}<br>\\frac{\\partial}{\\partial\\theta_j}\\mathit{J}(\\theta) &amp;= \\frac{\\partial}{\\partial\\theta_j}\\frac{1}{2}(h_{\\theta}(x)-y)^2\\<br>&amp;=2\\cdot\\frac{1}{2}(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(h_{\\theta}(x)-y)\\<br>&amp;=(h_{\\theta}(x)-y)\\cdot \\frac{\\partial}{\\partial\\theta_j}(\\sum^n_{i=0}\\theta_ix_i-y)\\<br>&amp;=(h_{\\theta}(x)-y)x_j<br>\\end{aligned}<br>\\end{equation}<br>$$<br>于是，更新公式可写为：<br>$$<br>\\begin{aligned}<br>\\theta_j &amp;:= \\theta_j-\\alpha \\cdot(h_{\\theta}(x)-y)x_j\\<br>&amp;:=\\theta_j +\\alpha \\cdot(y-h_{\\theta}(x))x_j<br>\\end{aligned}<br>$$<br>对于一个训练集，我们就得到：<br>$$<br>\\begin{eqnarray<em>}<br>&amp;&amp;\\large{重复直到收敛}{\\<br>&amp;&amp; \\quad \\quad \\theta_j := \\theta_j +\\alpha \\cdot \\frac{1}{m} \\cdot \\sum^{m}<em>{i=1}(y^{(i)}-h</em>{\\theta}(x^{(i)}))x^{(i)}_j\\<br> &amp;&amp;}<br>\\end{eqnarray</em>}<br>$$</p>\n<h3 id=\"求导\"><a href=\"#求导\" class=\"headerlink\" title=\"求导\"></a>求导</h3><blockquote>\n<p>  The “Normal Equation” is a method of finding the optimum theta without iteration.</p>\n</blockquote>\n<p>首先，我们定义一下 $X$，$X$ 是一个 $m \\times n$ 的矩阵，事实上，考虑截距（$\\theta_0$），矩阵应该为  $m \\times (n+1)$ ，</p>\n<p>我们有：<br>$$<br>X = \\left[<br> \\begin{matrix}<br>-(x^{(1)})^T-\\<br>-(x^{(2)})^T- \\<br>\\vdots\\<br>-(x^{(m)})^T-<br>  \\end{matrix}<br>  \\right]<br>$$<br>然后有 $\\pmb{y}$  ：<br>$$<br>\\pmb{y} = \\left[<br> \\begin{matrix}<br>y^{(1)}\\<br>y^{(2)}\\<br>\\vdots\\<br>y^{(m})<br>  \\end{matrix}<br>  \\right],\\pmb{y} \\in \\mathbb{R}^m<br>$$<br>于是有：<br>$$<br>J(\\pmb{\\theta}) = \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})<br>$$<br>因此，对 $\\mathit{J}(\\theta)$ 求 $\\theta$ 的偏导：<br>$$<br>\\begin{aligned}<br>\\nabla_{\\theta} J(\\pmb{\\theta}) &amp;= \\nabla_{\\theta} \\frac{1}{2}(X\\pmb{\\theta}-\\pmb{y})^T(X\\pmb{\\theta}-\\pmb{y})\\<br>&amp; = \\frac{1}{2}\\nabla_{\\theta} (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\<br>&amp; =\\frac{1}{2}\\nabla_{\\theta} tr (\\pmb{\\theta}^TX^TX\\pmb{\\theta}-\\pmb{\\theta}^TX^T\\pmb{y}-\\pmb{y}^TX\\pmb{\\theta}+\\pmb{y}^T\\pmb{y})\\<br>&amp; =  \\frac{1}{2}\\nabla_{\\theta}(tr \\pmb{\\theta}^TX^TX\\pmb{\\theta} - 2 tr \\pmb{y}^TX\\pmb{\\theta})\\<br>&amp;=\\frac{1}{2} (X^TX\\pmb{\\theta}+X^TX\\pmb{\\theta}-2X^T\\pmb{y})\\<br>&amp;=X^TX\\pmb{\\theta}-X^T\\pmb{y}<br>\\end{aligned}<br>$$<br>当对 $\\theta$ 的偏导为 $0$ 时，可得极值，得：<br>$$<br>X^TX\\pmb{\\theta} = X^T\\pmb{y}<br>$$<br>得到最优 $\\theta$ 解 ：<br>$$<br>\\pmb{\\theta} = (X^TX)^{-1}X^T\\pmb{y}<br>$$</p>\n<h2 id=\"概率解释（Probabilistic-Interpretation）\"><a href=\"#概率解释（Probabilistic-Interpretation）\" class=\"headerlink\" title=\"概率解释（Probabilistic Interpretation）\"></a>概率解释（Probabilistic Interpretation）</h2><h3 id=\"简单说明\"><a href=\"#简单说明\" class=\"headerlink\" title=\"简单说明\"></a>简单说明</h3><p>在对数据进行概率假设的基础上，最小二乘回归得到的 $\\theta$ 和最大似然法估计的 $\\theta$ 是一致的。所以这是一系列的假设，其前提是认为最小二乘回归（least-squares regression）能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计（maximum likelihood estimation）。</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>首先假设目标变量与输入变量存在以下等量关系：<br>$$<br>\\pmb{y}^{(i)}  = \\pmb{\\theta}^T\\pmb{x}+ \\pmb{\\varepsilon}^{(i)}<br>$$<br>上式的 $\\pmb{\\varepsilon}^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果 (比如可能某些特征对于房价的影响很明显，但我们做回归的时候忽略掉了)或者随机的噪音信息（random noise）。进一步假设 $\\pmb{\\varepsilon}^{(i)}$ 是独立同分布的 (IID ，independently and identically distributed) ，服从高斯分布（Gaussian distribution），其平均值为 $0$，方差（variance）为 $\\sigma^2$。这样就可以把这个假设写成 $\\pmb{\\varepsilon}^{(i)} \\sim \\mathcal{N}(0,\\sigma^2)$。然后 $\\pmb{\\varepsilon}^{(i)}$ 的密度函数就是：<br>$$<br>p(  \\pmb{\\varepsilon}^{(i)} ) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(\\varepsilon^{(i)})^2}{2\\sigma^2})<br>$$<br>这意味着存在下面的等量关系：<br>$$<br>p(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})<br>$$<br>上式为，在 $\\theta$ 取某个固定值的情况下，这个等式表达为，在 $\\pmb{x}^{(i)}$ 的情况下发生 $\\pmb{y}^{(i)}$ 的概率， 通常可以看做是一个 $\\pmb{y}^{(i)}$ 的函数。当我们要把它当做 $\\theta$ 的函数的时候，就称它为似然函数（likelihood function）在整个数据集下有：<br>$$<br>L(\\pmb{\\theta}) = L(\\pmb{\\theta};X,\\pmb{y}) = p(\\pmb{y}|X;\\pmb{\\theta })<br>$$<br>结合之前对 $ \\pmb{\\varepsilon}^{(i)}$ 的独立性假设（这里对 $\\pmb{y}^{(i)}$ 以及给定的 $\\pmb{x}^{(i)}$ 也都做同样假设），就可以把上面这个等式改写成下面的形式：<br>$$<br>\\begin{align}<br>L(\\pmb{\\theta}) &amp;= \\prod^m_{i=1}(\\pmb{y}^{(i)}|\\pmb{x}^{(i)};\\pmb{\\theta }) \\<br>&amp;= \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})<br>\\end{align}<br>$$<br>最大似然法（maximum likelihood）告诉我们要选择能让数据的似然函数尽可能大的 $\\theta$ 。也就是说，找到  $\\theta$ 能够让函数 $L(\\pmb{\\theta})$ 取到最大值。</p>\n<p>为了找到 $L(\\pmb{\\theta})$ 的最大值，我们不能直接使用 $L(\\pmb{\\theta})$ ，而要使用严格递增的 $L(\\pmb{\\theta})$ 的函数求最大值。使用对数函数来找对数函数 $L(\\pmb{\\theta})$ 的最大值是一种方法，而且求导来说就简单了一些：<br>$$<br>\\begin{align}<br>v&amp; = \\log{\\mit{L}(\\pmb{\\theta})}\\<br>&amp;=\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\<br>&amp;=\\sum^m_{i=1}\\log{ \\prod^m_{i=1} \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{exp}(-\\frac{(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}{2\\sigma^2})}\\<br>&amp;=m\\log{ \\frac{1}{\\sqrt{2\\pi}\\sigma} -\\frac{1}{\\sigma^2} \\cdot \\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2}<br>\\end{align}<br>$$<br>对于上式 ，由于$m\\log{\\frac{1}{\\sqrt{2\\pi}\\sigma}}$ ，$\\frac{1}{\\sigma^2}$ 值不变，那么 $\\scr{L}(\\pmb{\\theta})$ 取最大，即求下面的式子最小：<br>$$<br>\\frac{1}{2}\\sum^m_{i=1}(y^{(i)}-\\pmb{\\theta}^T\\pmb{x}^{(i)})^2<br>$$<br>证毕。</p>\n<h2 id=\"多项式回归（Polynomial-Regession）\"><a href=\"#多项式回归（Polynomial-Regession）\" class=\"headerlink\" title=\"多项式回归（Polynomial Regession）\"></a>多项式回归（Polynomial Regession）</h2><p>多项式回归可以用来拟合二次、三次、高次模型，通过使用 $\\pmb{x}^2,\\sqrt{\\pmb{x}}$ 等进行拟合。 </p>\n<p>这样便将高阶方程模型转换成线性回归模型。这也算是 <strong>特征缩放(Features Scaling)</strong> 的一种。</p>\n"},{"title":"SYNU-2015-training-题解","date":"2017-02-12T05:23:16.000Z","mathjax":true,"_content":"\n*题解*\n\n## A - Til the Cows Come Home \n\n### 描述\n\nBessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. \n\nFarmer John's field has N (2 <= N <= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 <= T <= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.\n\nGiven the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists.\n\n### Input\n\n* Line 1: Two integers: T and N \n* Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100.\n\n### Output\n\n* Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1.\n\n### Sample Input\n\n>5 5\n1 2 20\n2 3 30\n3 4 20\n4 5 20\n1 5 100\n\n### Sample Output\n\n>90\n\n### 简述题意与思路\n\n这题是一个很裸的最短路源点为`n`,终点为 `1`。套一下dijkstra的模版就好了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nstruct Edge {\n    int vertex, weight;\n};\nclass Graph {\nprivate:\n    int n;\n    vector<Edge> * edges;\n    bool * visited;\npublic:\n    int * dist;\n    Graph (int input_n) {\n        n = input_n;\n        edges = new vector<Edge>[n];\n        dist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n * sizeof(bool));\n        memset(dist, 0x3f, n * sizeof(int));\n    }\n    ~Graph() {\n        delete[] dist;\n        delete[] edges;\n        delete[] visited;\n    }\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n\n            for(int j = 0; j < edges[min_vertex].size() ;j++ ){\n                Edge tmp = edges[min_vertex][j];\n                if( min_dist + tmp.weight < dist[tmp.vertex]){\n                    dist[tmp.vertex] = min_dist + tmp.weight;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int t, n;\n    scanf(\"%d%d\",&t,&n);\n    Graph g(n);\n    for (int i = 0; i < t; i++) {\n        int a, b, c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        g.insert(a - 1, b - 1, c);\n    }\n    g.dijkstra(n-1);\n    cout << g.dist[0] << endl;\n}\n```\n\n## B - Heavy Transportation\n\n### 描述\n\nBackground \nHugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight. \nFortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know. \n\nProblem \nYou are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo's place) to crossing n (the customer's place). You may assume that there is at least one path. All streets can be travelled in both directions.\n\n### Input\n\nThe first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 <= n <= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.\n\n### Output\n\nThe output for every scenario begins with a line containing \"Scenario #i:\", where i is the number of the scenario starting at 1. Then print a single line containing the maximum allowed weight that Hugo can transport to the customer. Terminate the output for the scenario with a blank line.\n\n### Sample Input\n\n>1\n3 3\n1 2 3\n1 3 4\n2 3 5\n\n### Sample Output\n\n>Scenario #1:\n4\n\n### 简述题意与思路\n\n**题意：** n个点m条边，边的权值为最大承载量。要求输出从1点到n点能运送货物的最大重量。\n**思路：** 这题可以用prime和dijkstra两种方法，即最大生成树和最短路。prime很裸，,disjkstra需要稍加变形，由于在训练dijkstra，我就选择这个了。\n对于dijkstra，其松弛操作由原来的修改为最短路径改为修改为较大权值。且选点操作，改为选取边权较大的点了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nconst int INF = -1;\nstruct Edge {\n    long long vertex, weight;\n};\nclass Graph {\nprivate:\n    int n;\n    vector<Edge> * edges;\n    bool * visited;\npublic:\n    long long * dist;\n    Graph (int input_n) {\n        n = input_n;\n        edges = new vector<Edge>[n];\n        dist = new long long[n];\n        visited = new bool[n];\n        memset(visited, 0, n * sizeof(bool));\n        memset(dist, 0, n * sizeof(long long));\n    }\n    ~Graph() {\n        delete[] dist;\n        delete[] edges;\n        delete[] visited;\n    }\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n\n        for(int i=0;i<edges[0].size(); i++){\n            dist[edges[0][i].vertex] = edges[0][i].weight;\n        }\n\n        visited[0]=1;\n        \n        for(int i = 0;i < n;i++){\n            long long min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){ \n                if(!visited[j] && dist[j] > min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            \n            visited[min_vertex] = 1;\n            \n            for(int j = 0; j < edges[min_vertex].size() ;j++ ){\n                Edge tmp = edges[min_vertex][j];\n                if( min(min_dist , tmp.weight) > dist[tmp.vertex]){\n                    dist[tmp.vertex] = min(min_dist , tmp.weight);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int T;\n    scanf(\"%d\",&T);\n    for(int t = 1; t <= T; t++){\n        int n, m;\n        scanf(\"%d%d\",&n, &m);\n        Graph g(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            g.insert(a - 1, b - 1, c);\n        }\n        g.dijkstra(0);\n        printf(\"Scenario #%d:\\n%lld\\n\\n\",t,g.dist[n-1]);\n    }\n}\n```\n\n## C - Wireless Network \n\n### 描述\n    \nAn earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. \n\nIn the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. \n\n### Input\n\nThe first line contains two integers N and d (1 <= N <= 1001, 0 <= d <= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 <= xi, yi <= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: \n1. \"O p\" (1 <= p <= N), which means repairing computer p. \n2. \"S p q\" (1 <= p, q <= N), which means testing whether computer p and q can communicate. \n\nThe input will not exceed 300000 lines. \n\n### Output\n\nFor each Testing operation, print \"SUCCESS\" if the two computers can communicate, or \"FAIL\" if not.\n\n### Sample Input\n\n>4 1\n0 1\n0 2\n0 3\n0 4\nO 1\nO 2\nO 4\nS 1 4\nO 3\nS 1 4\n\n### Sample Output\n\n>FAIL\nSUCCESS\n\n### 简述题意与思路\n\n**题意：** 给出电脑数量n和距离d，给出n个电脑的坐标。给出操作 O 和 P，O操作表示修复电脑，P操作表示测试两台电脑是否可以通讯，对于P操作输出结果FAIL或者SUCCESS。\n**思路：** 简单的并查集题，对每个O进行Union操作；对于P进行查询集合操作，如果集合相同择SUCCESS，否则FAIL。其中Union进行的条件是，俩电脑距离是否小于d。\n\n### 代码\n\n由于为AC，稍后贴出。注意题意与思路可能会改变。\n\n\n## D - The Suspects \n\n### 描述\n\nSevere acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others. \nIn the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP). \nOnce a member in a group is a suspect, all members in the group are suspects. \nHowever, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.\n\n### Input\n\nThe input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 < n <= 30000 and 0 <= m <= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space. \nA case with n = 0 and m = 0 indicates the end of the input, and need not be processed.\n\n### Output\n\nFor each case, output the number of suspects in one line.\n\n### Sample Input\n\n>100 4\n2 1 2\n5 10 13 11 12 14\n2 0 1\n2 99 2\n200 2\n1 5\n5 1 2 3 4 5\n1 0\n0 0\n\n### Sample Output\n\n>4\n1\n1\n\n### 简述题意与思路\n\n**题意：** 很简单给出人数n和组数m。有m组人群，其中序号为0的那个人为疑似感染患者，输出疑似感染人群的人数。对于那m组人群需要进行合并。\n**思路：** 首先当m为0时，直接输出1，应为只有0号一个人。其他情况，对于m组进行并查集的Union算法，把属于同一组的人标为同一个组。然后输出号0所在那个组的人数就好了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nint const MAX = 30000 +10;\nint mem[MAX];\nint son[MAX],pre[MAX];\n\nvoid init(){\n    for (int i = 0; i < MAX; ++i)\n    {\n        pre[i] = i;\n        son[i] = 1;\n    }\n}\n\nint Find_Set(int x)\n{\n    return x == pre[x] ? x : Find_Set(pre[x]);;\n}\n\nvoid Union(int x, int y){\n    int root1= Find_Set(x), root2= Find_Set(y);;\n    if(root1 != root2){\n        pre[root2] = root1;\n        son[root1] += son[root2];\n    }\n}\n\nint main(){\n\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m) && (n || m)){\n        init();\n        if(m == 0){\n            cout << 1 <<endl;\n            continue;\n        }\n\n        for(int i = 0; i < m;i++)\n        {\n            int  c,one;\n            scanf(\"%d%d\",&c,&one);\n            for(int j= 1;j < c;j++){\n                int two;\n                scanf(\"%d\",&two);\n                Union(one,two);\n            }\n        }\n        printf(\"%d\\n\",son[Find_Set(0)]);\n    }\n    return 0;\n}\n```\n\n\n","source":"_posts/SYNU-2015-training-题解.md","raw":"---\ntitle: SYNU-2015-training-题解\ndate: 2017-02-12 13:23:16\nmathjax: true\ntags: \n    - 题解\ncategories: Algorithm\n---\n\n*题解*\n\n## A - Til the Cows Come Home \n\n### 描述\n\nBessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. \n\nFarmer John's field has N (2 <= N <= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 <= T <= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.\n\nGiven the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists.\n\n### Input\n\n* Line 1: Two integers: T and N \n* Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100.\n\n### Output\n\n* Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1.\n\n### Sample Input\n\n>5 5\n1 2 20\n2 3 30\n3 4 20\n4 5 20\n1 5 100\n\n### Sample Output\n\n>90\n\n### 简述题意与思路\n\n这题是一个很裸的最短路源点为`n`,终点为 `1`。套一下dijkstra的模版就好了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nstruct Edge {\n    int vertex, weight;\n};\nclass Graph {\nprivate:\n    int n;\n    vector<Edge> * edges;\n    bool * visited;\npublic:\n    int * dist;\n    Graph (int input_n) {\n        n = input_n;\n        edges = new vector<Edge>[n];\n        dist = new int[n];\n        visited = new bool[n];\n        memset(visited, 0, n * sizeof(bool));\n        memset(dist, 0x3f, n * sizeof(int));\n    }\n    ~Graph() {\n        delete[] dist;\n        delete[] edges;\n        delete[] visited;\n    }\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n        for(int i = 0;i < n;i++){\n            int min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){\n                if(!visited[j] && dist[j] < min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            visited[min_vertex] = 1;\n\n            for(int j = 0; j < edges[min_vertex].size() ;j++ ){\n                Edge tmp = edges[min_vertex][j];\n                if( min_dist + tmp.weight < dist[tmp.vertex]){\n                    dist[tmp.vertex] = min_dist + tmp.weight;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int t, n;\n    scanf(\"%d%d\",&t,&n);\n    Graph g(n);\n    for (int i = 0; i < t; i++) {\n        int a, b, c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        g.insert(a - 1, b - 1, c);\n    }\n    g.dijkstra(n-1);\n    cout << g.dist[0] << endl;\n}\n```\n\n## B - Heavy Transportation\n\n### 描述\n\nBackground \nHugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight. \nFortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know. \n\nProblem \nYou are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo's place) to crossing n (the customer's place). You may assume that there is at least one path. All streets can be travelled in both directions.\n\n### Input\n\nThe first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 <= n <= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.\n\n### Output\n\nThe output for every scenario begins with a line containing \"Scenario #i:\", where i is the number of the scenario starting at 1. Then print a single line containing the maximum allowed weight that Hugo can transport to the customer. Terminate the output for the scenario with a blank line.\n\n### Sample Input\n\n>1\n3 3\n1 2 3\n1 3 4\n2 3 5\n\n### Sample Output\n\n>Scenario #1:\n4\n\n### 简述题意与思路\n\n**题意：** n个点m条边，边的权值为最大承载量。要求输出从1点到n点能运送货物的最大重量。\n**思路：** 这题可以用prime和dijkstra两种方法，即最大生成树和最短路。prime很裸，,disjkstra需要稍加变形，由于在训练dijkstra，我就选择这个了。\n对于dijkstra，其松弛操作由原来的修改为最短路径改为修改为较大权值。且选点操作，改为选取边权较大的点了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nconst int INF = -1;\nstruct Edge {\n    long long vertex, weight;\n};\nclass Graph {\nprivate:\n    int n;\n    vector<Edge> * edges;\n    bool * visited;\npublic:\n    long long * dist;\n    Graph (int input_n) {\n        n = input_n;\n        edges = new vector<Edge>[n];\n        dist = new long long[n];\n        visited = new bool[n];\n        memset(visited, 0, n * sizeof(bool));\n        memset(dist, 0, n * sizeof(long long));\n    }\n    ~Graph() {\n        delete[] dist;\n        delete[] edges;\n        delete[] visited;\n    }\n    void insert(int x, int y, int weight) {\n        edges[x].push_back(Edge{y, weight});\n        edges[y].push_back(Edge{x, weight});\n    }\n    void dijkstra(int v) {\n        dist[v] = 0;\n\n        for(int i=0;i<edges[0].size(); i++){\n            dist[edges[0][i].vertex] = edges[0][i].weight;\n        }\n\n        visited[0]=1;\n        \n        for(int i = 0;i < n;i++){\n            long long min_dist = INF,min_vertex;\n            for(int j = 0;j < n; j++){ \n                if(!visited[j] && dist[j] > min_dist){\n                    min_dist = dist[j];\n                    min_vertex = j;\n                }\n            }\n            \n            visited[min_vertex] = 1;\n            \n            for(int j = 0; j < edges[min_vertex].size() ;j++ ){\n                Edge tmp = edges[min_vertex][j];\n                if( min(min_dist , tmp.weight) > dist[tmp.vertex]){\n                    dist[tmp.vertex] = min(min_dist , tmp.weight);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int T;\n    scanf(\"%d\",&T);\n    for(int t = 1; t <= T; t++){\n        int n, m;\n        scanf(\"%d%d\",&n, &m);\n        Graph g(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            g.insert(a - 1, b - 1, c);\n        }\n        g.dijkstra(0);\n        printf(\"Scenario #%d:\\n%lld\\n\\n\",t,g.dist[n-1]);\n    }\n}\n```\n\n## C - Wireless Network \n\n### 描述\n    \nAn earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. \n\nIn the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. \n\n### Input\n\nThe first line contains two integers N and d (1 <= N <= 1001, 0 <= d <= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 <= xi, yi <= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: \n1. \"O p\" (1 <= p <= N), which means repairing computer p. \n2. \"S p q\" (1 <= p, q <= N), which means testing whether computer p and q can communicate. \n\nThe input will not exceed 300000 lines. \n\n### Output\n\nFor each Testing operation, print \"SUCCESS\" if the two computers can communicate, or \"FAIL\" if not.\n\n### Sample Input\n\n>4 1\n0 1\n0 2\n0 3\n0 4\nO 1\nO 2\nO 4\nS 1 4\nO 3\nS 1 4\n\n### Sample Output\n\n>FAIL\nSUCCESS\n\n### 简述题意与思路\n\n**题意：** 给出电脑数量n和距离d，给出n个电脑的坐标。给出操作 O 和 P，O操作表示修复电脑，P操作表示测试两台电脑是否可以通讯，对于P操作输出结果FAIL或者SUCCESS。\n**思路：** 简单的并查集题，对每个O进行Union操作；对于P进行查询集合操作，如果集合相同择SUCCESS，否则FAIL。其中Union进行的条件是，俩电脑距离是否小于d。\n\n### 代码\n\n由于为AC，稍后贴出。注意题意与思路可能会改变。\n\n\n## D - The Suspects \n\n### 描述\n\nSevere acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others. \nIn the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP). \nOnce a member in a group is a suspect, all members in the group are suspects. \nHowever, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.\n\n### Input\n\nThe input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 < n <= 30000 and 0 <= m <= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space. \nA case with n = 0 and m = 0 indicates the end of the input, and need not be processed.\n\n### Output\n\nFor each case, output the number of suspects in one line.\n\n### Sample Input\n\n>100 4\n2 1 2\n5 10 13 11 12 14\n2 0 1\n2 99 2\n200 2\n1 5\n5 1 2 3 4 5\n1 0\n0 0\n\n### Sample Output\n\n>4\n1\n1\n\n### 简述题意与思路\n\n**题意：** 很简单给出人数n和组数m。有m组人群，其中序号为0的那个人为疑似感染患者，输出疑似感染人群的人数。对于那m组人群需要进行合并。\n**思路：** 首先当m为0时，直接输出1，应为只有0号一个人。其他情况，对于m组进行并查集的Union算法，把属于同一组的人标为同一个组。然后输出号0所在那个组的人数就好了。\n\n### 代码\n\n```c++\ninclude <iostream>\ninclude <cstring>\ninclude <vector>\ninclude <queue>\ninclude <stdio.h>\nusing namespace std;\nint const MAX = 30000 +10;\nint mem[MAX];\nint son[MAX],pre[MAX];\n\nvoid init(){\n    for (int i = 0; i < MAX; ++i)\n    {\n        pre[i] = i;\n        son[i] = 1;\n    }\n}\n\nint Find_Set(int x)\n{\n    return x == pre[x] ? x : Find_Set(pre[x]);;\n}\n\nvoid Union(int x, int y){\n    int root1= Find_Set(x), root2= Find_Set(y);;\n    if(root1 != root2){\n        pre[root2] = root1;\n        son[root1] += son[root2];\n    }\n}\n\nint main(){\n\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m) && (n || m)){\n        init();\n        if(m == 0){\n            cout << 1 <<endl;\n            continue;\n        }\n\n        for(int i = 0; i < m;i++)\n        {\n            int  c,one;\n            scanf(\"%d%d\",&c,&one);\n            for(int j= 1;j < c;j++){\n                int two;\n                scanf(\"%d\",&two);\n                Union(one,two);\n            }\n        }\n        printf(\"%d\\n\",son[Find_Set(0)]);\n    }\n    return 0;\n}\n```\n\n\n","slug":"SYNU-2015-training-题解","published":1,"updated":"2018-07-03T06:29:50.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9u1j003pplxprifr1vof","content":"<p><em>题解</em></p>\n<h2 id=\"A-Til-the-Cows-Come-Home\"><a href=\"#A-Til-the-Cows-Come-Home\" class=\"headerlink\" title=\"A - Til the Cows Come Home\"></a>A - Til the Cows Come Home</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. </p>\n<p>Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.</p>\n<p>Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists.</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><ul>\n<li>Line 1: Two integers: T and N </li>\n<li>Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100.</li>\n</ul>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><ul>\n<li>Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1.</li>\n</ul>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>5 5<br>1 2 20<br>2 3 30<br>3 4 20<br>4 5 20<br>1 5 100</p>\n</blockquote>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>90</p>\n</blockquote>\n<h3 id=\"简述题意与思路\"><a href=\"#简述题意与思路\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p>这题是一个很裸的最短路源点为<code>n</code>,终点为 <code>1</code>。套一下dijkstra的模版就好了。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">    Graph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">        n = input_n;</span><br><span class=\"line\">        edges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">        dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Graph() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edges[min_vertex].size() ;j++ )&#123;</span><br><span class=\"line\">                Edge tmp = edges[min_vertex][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + tmp.weight &lt; dist[tmp.vertex])&#123;</span><br><span class=\"line\">                    dist[tmp.vertex] = min_dist + tmp.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;t,&amp;n);</span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        g.insert(a - <span class=\"number\">1</span>, b - <span class=\"number\">1</span>, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g.dijkstra(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; g.dist[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-Heavy-Transportation\"><a href=\"#B-Heavy-Transportation\" class=\"headerlink\" title=\"B - Heavy Transportation\"></a>B - Heavy Transportation</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Background<br>Hugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight.<br>Fortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know. </p>\n<p>Problem<br>You are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo’s place) to crossing n (the customer’s place). You may assume that there is at least one path. All streets can be travelled in both directions.</p>\n<h3 id=\"Input-1\"><a href=\"#Input-1\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>The output for every scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line containing the maximum allowed weight that Hugo can transport to the customer. Terminate the output for the scenario with a blank line.</p>\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>1<br>3 3<br>1 2 3<br>1 3 4<br>2 3 5</p>\n</blockquote>\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>Scenario #1:<br>4</p>\n</blockquote>\n<h3 id=\"简述题意与思路-1\"><a href=\"#简述题意与思路-1\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> n个点m条边，边的权值为最大承载量。要求输出从1点到n点能运送货物的最大重量。<br><strong>思路：</strong> 这题可以用prime和dijkstra两种方法，即最大生成树和最短路。prime很裸，,disjkstra需要稍加变形，由于在训练dijkstra，我就选择这个了。<br>对于dijkstra，其松弛操作由原来的修改为最短路径改为修改为较大权值。且选点操作，改为选取边权较大的点了。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> * dist;</span><br><span class=\"line\">    Graph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">        n = input_n;</span><br><span class=\"line\">        edges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">        dist = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Graph() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;edges[<span class=\"number\">0</span>].size(); i++)&#123;</span><br><span class=\"line\">            dist[edges[<span class=\"number\">0</span>][i].vertex] = edges[<span class=\"number\">0</span>][i].weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        visited[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &gt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edges[min_vertex].size() ;j++ )&#123;</span><br><span class=\"line\">                Edge tmp = edges[min_vertex][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min(min_dist , tmp.weight) &gt; dist[tmp.vertex])&#123;</span><br><span class=\"line\">                    dist[tmp.vertex] = min(min_dist , tmp.weight);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; t++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">            g.insert(a - <span class=\"number\">1</span>, b - <span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        g.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Scenario #%d:\\n%lld\\n\\n\"</span>,t,g.dist[n<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-Wireless-Network\"><a href=\"#C-Wireless-Network\" class=\"headerlink\" title=\"C - Wireless Network\"></a>C - Wireless Network</h2><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. </p>\n<p>In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. </p>\n<h3 id=\"Input-2\"><a href=\"#Input-2\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: </p>\n<ol>\n<li>“O p” (1 &lt;= p &lt;= N), which means repairing computer p. </li>\n<li>“S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate. </li>\n</ol>\n<p>The input will not exceed 300000 lines. </p>\n<h3 id=\"Output-2\"><a href=\"#Output-2\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not.</p>\n<h3 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>4 1<br>0 1<br>0 2<br>0 3<br>0 4<br>O 1<br>O 2<br>O 4<br>S 1 4<br>O 3<br>S 1 4</p>\n</blockquote>\n<h3 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>FAIL<br>SUCCESS</p>\n</blockquote>\n<h3 id=\"简述题意与思路-2\"><a href=\"#简述题意与思路-2\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> 给出电脑数量n和距离d，给出n个电脑的坐标。给出操作 O 和 P，O操作表示修复电脑，P操作表示测试两台电脑是否可以通讯，对于P操作输出结果FAIL或者SUCCESS。<br><strong>思路：</strong> 简单的并查集题，对每个O进行Union操作；对于P进行查询集合操作，如果集合相同择SUCCESS，否则FAIL。其中Union进行的条件是，俩电脑距离是否小于d。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>由于为AC，稍后贴出。注意题意与思路可能会改变。</p>\n<h2 id=\"D-The-Suspects\"><a href=\"#D-The-Suspects\" class=\"headerlink\" title=\"D - The Suspects\"></a>D - The Suspects</h2><h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>\n<h3 id=\"Input-3\"><a href=\"#Input-3\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>\n<h3 id=\"Output-3\"><a href=\"#Output-3\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each case, output the number of suspects in one line.</p>\n<h3 id=\"Sample-Input-3\"><a href=\"#Sample-Input-3\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0</p>\n</blockquote>\n<h3 id=\"Sample-Output-3\"><a href=\"#Sample-Output-3\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>4<br>1<br>1</p>\n</blockquote>\n<h3 id=\"简述题意与思路-3\"><a href=\"#简述题意与思路-3\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> 很简单给出人数n和组数m。有m组人群，其中序号为0的那个人为疑似感染患者，输出疑似感染人群的人数。对于那m组人群需要进行合并。<br><strong>思路：</strong> 首先当m为0时，直接输出1，应为只有0号一个人。其他情况，对于m组进行并查集的Union算法，把属于同一组的人标为同一个组。然后输出号0所在那个组的人数就好了。</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> MAX = <span class=\"number\">30000</span> +<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mem[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> son[MAX],pre[MAX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pre[i] = i;</span><br><span class=\"line\">        son[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find_Set</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == pre[x] ? x : Find_Set(pre[x]);;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root1= Find_Set(x), root2= Find_Set(y);;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root1 != root2)&#123;</span><br><span class=\"line\">        pre[root2] = root1;</span><br><span class=\"line\">        son[root1] += son[root2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m) &amp;&amp; (n || m))&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">1</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>  c,one;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c,&amp;one);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j= <span class=\"number\">1</span>;j &lt; c;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> two;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;two);</span><br><span class=\"line\">                Union(one,two);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,son[Find_Set(<span class=\"number\">0</span>)]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><em>题解</em></p>\n<h2 id=\"A-Til-the-Cows-Come-Home\"><a href=\"#A-Til-the-Cows-Come-Home\" class=\"headerlink\" title=\"A - Til the Cows Come Home\"></a>A - Til the Cows Come Home</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. </p>\n<p>Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.</p>\n<p>Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists.</p>\n<h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><ul>\n<li>Line 1: Two integers: T and N </li>\n<li>Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100.</li>\n</ul>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><ul>\n<li>Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1.</li>\n</ul>\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>5 5<br>1 2 20<br>2 3 30<br>3 4 20<br>4 5 20<br>1 5 100</p>\n</blockquote>\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>90</p>\n</blockquote>\n<h3 id=\"简述题意与思路\"><a href=\"#简述题意与思路\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p>这题是一个很裸的最短路源点为<code>n</code>,终点为 <code>1</code>。套一下dijkstra的模版就好了。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * dist;</span><br><span class=\"line\">    Graph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">        n = input_n;</span><br><span class=\"line\">        edges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">        dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Graph() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edges[min_vertex].size() ;j++ )&#123;</span><br><span class=\"line\">                Edge tmp = edges[min_vertex][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min_dist + tmp.weight &lt; dist[tmp.vertex])&#123;</span><br><span class=\"line\">                    dist[tmp.vertex] = min_dist + tmp.weight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;t,&amp;n);</span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        g.insert(a - <span class=\"number\">1</span>, b - <span class=\"number\">1</span>, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g.dijkstra(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; g.dist[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"B-Heavy-Transportation\"><a href=\"#B-Heavy-Transportation\" class=\"headerlink\" title=\"B - Heavy Transportation\"></a>B - Heavy Transportation</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Background<br>Hugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight.<br>Fortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know. </p>\n<p>Problem<br>You are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo’s place) to crossing n (the customer’s place). You may assume that there is at least one path. All streets can be travelled in both directions.</p>\n<h3 id=\"Input-1\"><a href=\"#Input-1\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>The output for every scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line containing the maximum allowed weight that Hugo can transport to the customer. Terminate the output for the scenario with a blank line.</p>\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>1<br>3 3<br>1 2 3<br>1 3 4<br>2 3 5</p>\n</blockquote>\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>Scenario #1:<br>4</p>\n</blockquote>\n<h3 id=\"简述题意与思路-1\"><a href=\"#简述题意与思路-1\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> n个点m条边，边的权值为最大承载量。要求输出从1点到n点能运送货物的最大重量。<br><strong>思路：</strong> 这题可以用prime和dijkstra两种方法，即最大生成树和最短路。prime很裸，,disjkstra需要稍加变形，由于在训练dijkstra，我就选择这个了。<br>对于dijkstra，其松弛操作由原来的修改为最短路径改为修改为较大权值。且选点操作，改为选取边权较大的点了。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vertex, weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Edge&gt; * edges;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> * visited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> * dist;</span><br><span class=\"line\">    Graph (<span class=\"keyword\">int</span> input_n) &#123;</span><br><span class=\"line\">        n = input_n;</span><br><span class=\"line\">        edges = <span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;Edge&gt;[n];</span><br><span class=\"line\">        dist = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[n];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(visited, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">bool</span>));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0</span>, n * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Graph() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] dist;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] edges;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] visited;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        edges[x].push_back(Edge&#123;y, weight&#125;);</span><br><span class=\"line\">        edges[y].push_back(Edge&#123;x, weight&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">        dist[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;edges[<span class=\"number\">0</span>].size(); i++)&#123;</span><br><span class=\"line\">            dist[edges[<span class=\"number\">0</span>][i].vertex] = edges[<span class=\"number\">0</span>][i].weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        visited[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> min_dist = INF,min_vertex;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; n; j++)&#123; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; dist[j] &gt; min_dist)&#123;</span><br><span class=\"line\">                    min_dist = dist[j];</span><br><span class=\"line\">                    min_vertex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            visited[min_vertex] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edges[min_vertex].size() ;j++ )&#123;</span><br><span class=\"line\">                Edge tmp = edges[min_vertex][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( min(min_dist , tmp.weight) &gt; dist[tmp.vertex])&#123;</span><br><span class=\"line\">                    dist[tmp.vertex] = min(min_dist , tmp.weight);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; t++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">            g.insert(a - <span class=\"number\">1</span>, b - <span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        g.dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Scenario #%d:\\n%lld\\n\\n\"</span>,t,g.dist[n<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-Wireless-Network\"><a href=\"#C-Wireless-Network\" class=\"headerlink\" title=\"C - Wireless Network\"></a>C - Wireless Network</h2><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. </p>\n<p>In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. </p>\n<h3 id=\"Input-2\"><a href=\"#Input-2\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: </p>\n<ol>\n<li>“O p” (1 &lt;= p &lt;= N), which means repairing computer p. </li>\n<li>“S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate. </li>\n</ol>\n<p>The input will not exceed 300000 lines. </p>\n<h3 id=\"Output-2\"><a href=\"#Output-2\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not.</p>\n<h3 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>4 1<br>0 1<br>0 2<br>0 3<br>0 4<br>O 1<br>O 2<br>O 4<br>S 1 4<br>O 3<br>S 1 4</p>\n</blockquote>\n<h3 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>FAIL<br>SUCCESS</p>\n</blockquote>\n<h3 id=\"简述题意与思路-2\"><a href=\"#简述题意与思路-2\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> 给出电脑数量n和距离d，给出n个电脑的坐标。给出操作 O 和 P，O操作表示修复电脑，P操作表示测试两台电脑是否可以通讯，对于P操作输出结果FAIL或者SUCCESS。<br><strong>思路：</strong> 简单的并查集题，对每个O进行Union操作；对于P进行查询集合操作，如果集合相同择SUCCESS，否则FAIL。其中Union进行的条件是，俩电脑距离是否小于d。</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>由于为AC，稍后贴出。注意题意与思路可能会改变。</p>\n<h2 id=\"D-The-Suspects\"><a href=\"#D-The-Suspects\" class=\"headerlink\" title=\"D - The Suspects\"></a>D - The Suspects</h2><h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>\n<h3 id=\"Input-3\"><a href=\"#Input-3\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>\n<h3 id=\"Output-3\"><a href=\"#Output-3\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>For each case, output the number of suspects in one line.</p>\n<h3 id=\"Sample-Input-3\"><a href=\"#Sample-Input-3\" class=\"headerlink\" title=\"Sample Input\"></a>Sample Input</h3><blockquote>\n<p>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0</p>\n</blockquote>\n<h3 id=\"Sample-Output-3\"><a href=\"#Sample-Output-3\" class=\"headerlink\" title=\"Sample Output\"></a>Sample Output</h3><blockquote>\n<p>4<br>1<br>1</p>\n</blockquote>\n<h3 id=\"简述题意与思路-3\"><a href=\"#简述题意与思路-3\" class=\"headerlink\" title=\"简述题意与思路\"></a>简述题意与思路</h3><p><strong>题意：</strong> 很简单给出人数n和组数m。有m组人群，其中序号为0的那个人为疑似感染患者，输出疑似感染人群的人数。对于那m组人群需要进行合并。<br><strong>思路：</strong> 首先当m为0时，直接输出1，应为只有0号一个人。其他情况，对于m组进行并查集的Union算法，把属于同一组的人标为同一个组。然后输出号0所在那个组的人数就好了。</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\">include &lt;cstring&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">vector</span>&gt;</span><br><span class=\"line\">include &lt;<span class=\"built_in\">queue</span>&gt;</span><br><span class=\"line\">include &lt;stdio.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> MAX = <span class=\"number\">30000</span> +<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mem[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> son[MAX],pre[MAX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pre[i] = i;</span><br><span class=\"line\">        son[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find_Set</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == pre[x] ? x : Find_Set(pre[x]);;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root1= Find_Set(x), root2= Find_Set(y);;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root1 != root2)&#123;</span><br><span class=\"line\">        pre[root2] = root1;</span><br><span class=\"line\">        son[root1] += son[root2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m) &amp;&amp; (n || m))&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">1</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>  c,one;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c,&amp;one);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j= <span class=\"number\">1</span>;j &lt; c;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> two;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;two);</span><br><span class=\"line\">                Union(one,two);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,son[Find_Set(<span class=\"number\">0</span>)]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"博客的开始——如何搭建Hexo","date":"2016-12-27T01:43:57.000Z","mathjax":true,"_content":"\n## 概述\n\n#### 导语\n\n> Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且能一键部署到GitHub Pages。\n\n首先，不论这篇文章主要是为了安装什么，第一步该做的是先说明一遍大致的过程，以使读者能够清楚，自己究竟在干什么、还有什么没有完成、为什么要这么做。当然，我会给出一些必要的网站，它们以官网为主，庆幸的是，这些官网都有简体中文的支持。最后，说明一下作者的系统为Mint Linux，它和Ubuntu是一样的，并且作者是一个大二菜鸟，如果有错的话，希望大家能够指出错误，我也会立即改正。\n\n### 具体过程\n\n1. 准备安装环境 \n   * Node.js\n   * Git\n2. 安装Hexo\n3. 开始搭建博客\n   * 初始化Hexo\n   * 修改全局配置文件\n   * 一次简单的同步\n4. 添加新文章\n5. 更换主题\n\n### 给出网址\n\n* [Hexo官方网站](https://hexo.io/zh-cn/)\n* [Material主题官网](https://material.vss.im/)\n* [史上最详细的Hexo博客搭建图文教程](https://xuanwo.org/2015/03/26/hexo-intor/)\n\n## 准备安装环境 \n\n### 安装Node.js\n\n很不幸运的是官方给出的 Node.js 安装方法并不是非常有效。因此我通过Baidu找到了一种简单的方法，在此给出过程。\n\n1. 下载\n\n   第一步很简单，就是从官网上下载二进制包。给出地址。\n\n   * [Node.js官网下载地址](https://nodejs.org/en/download/)\n\n2. 解压下载好的 node-v6.9.2-linux-x64.tar.xz 压缩包\n\n   ```\n   $ tar xvf node-v6.9.2-linux-x64.tar.xz \n   ```\n\n   这样，你可以得到一个名为 node-v6.9.2-linux-x64 的文件夹。\n\n3. 验证 Node.js 的版本\n\n   首先进入 node-v6.9.2-linux-x64 文件夹下的 bin 目录，你会发现有两个可执行文件。如下：\n\n   ```\n   $ cd node-v6.9.2-linux-x64/bin\n   $ ls\n   node  npm\n   ```\n\n   接着我们来看看 Node.js 的版本\n\n   ```\n   $ ./node -v\n   v6.9.2\n   ```\n\n   很好，它是最新的6.9.2版本。\n\n4. 把二进制包放到较为规范的地方。\n\n   什么叫较为规范的地方？举个例子，在Windows下，排除自己定义安装路径的软件，你所有的软件都会在这样一个地址下 `C:\\Program Files` 。在Mint Linux上，我把它规定为 `/opt` ，这个路径包含了所有我手动安装的软件，毕竟虽然有 **apt** ，但是总有些软件不能通过apt安装。很好，下面让我们把它挪到那个规范的地方。\n\n   ```\n   $ sudo mv node-v6.9.2-linux-x64 /opt/\n   $ cd /opt\n   $ ls\n   clion  eclipse  google  node-v6.9.2-linux-x64  pycharm  sublime_text\n   ```\n\n   由此你可以发现，我已经成功移动了文件。这里有个小问题，在执行第一句命令的时候，会提示需要密码，不要担心，直接输入root密码就行，它不是明文的，并不会显示字符。\n\n5. 建立软链接，设置全局\n\n   怎么在shell中直接访问呢？就是通过软链接实现。\n\n   ```\n   $ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/node /usr/local/bin/node\n   $ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/npm /usr/local/bin/npm\n   $ cd /usr/local/bin/\n   $ ls |grep '^[n]'\n   node\n   npm\n   ```\n\n   你会发现，在 `/usr/local/bin`这个目录下已经有 **node** 、**npm** 两个文件了。\n\n6. 验证成功\n\n   打开terminal，输入`node -v`和`npm -v` 来检查是否成功。\n\n   ```\n   $ node -v\n   v6.9.2\n   $ npm -v\n   3.10.9\n   ```\n\n   由此Node.js安装完成，看似很复杂，其实很简单。\n\n### 安装Git\n\nGit的安装是通过apt，极其便捷。\n\n```\nsudo apt-get install git\n```\n\n这样就安装完了。这就是包管理的好处。\n\n其次，ssh的配置安装则参考[Git教程 - *廖雪峰的官方网站*](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000) ,这是非常好的git教程网站。\n\n## 安装Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。根据官方教程：\n\n```\n$ npm install -g hexo-cli\n```\n\n如果出现WARNING，那么你可以忽视它。如果出现ERROR，那么请你使用Baidu或者Bing来解决问题，作者病不能，开速有效的替你解决。\n\n## 开始搭建博客\n\n###  初始化Hexo\n\n首先，我打算把博客的根地址定在 `～/Document/` 。那么开始\n\n```\n$ cd ~/Documents/\n$ hexo init Blog\n$ cd Blog\n$ npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n注意，这里有一些问题。执行第二个命令时常常由于网络的问题卡住，那么建议你把npm的源改为淘宝源，具体教程查看[npm设置淘宝镜像](http://www.jianshu.com/p/fb7251740107/comments/330864)\n\n### 修改全局配置文件 \n\n您可以在 `_config.yml` 中修改大部份的配置。当然参考[官方文档](https://hexo.io/zh-cn/docs/configuration.html)以获得最好的支持\n\n当然你可以查看我的修改方法。\n\n#### 网站\n\n| 参数          | 描述      | 我的配置          |\n| ----------- | ------- | ------------- |\n| title       | 网站标题    | Francis'Blog  |\n| subtitle    | 网站副标题   |               |\n| description | 网站描述    |               |\n| author      | 作者的名字   | Andy Francis  |\n| language    | 网站使用的语言 | zh-CN         |\n| timezone    | 网站时区    | Asia/Shanghai |\n\n#### 网址\n\n| 参数                  | 描述                                       | 我的配置                           |\n| ------------------- | ---------------------------------------- | ------------------------------ |\n| `url`               | 网址                                       | https://dongfrancis.github.io/ |\n| `root`              | 网站根目录                                    | /                              |\n| `permalink`         | 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/`    |\n| `permalink_default` | 永久链接中各部分的默认值                             |                                |\n\n#### 目录\n\n| 参数             | 描述                                       | 我的配置             |\n| -------------- | ---------------------------------------- | ---------------- |\n| `source_dir`   | 资源文件夹，这个文件夹用来存放内容。                       | `source`         |\n| `public_dir`   | 公共文件夹，这个文件夹用于存放生成的站点文件。                  | `public`         |\n| `tag_dir`      | 标签文件夹                                    | `tags`           |\n| `archive_dir`  | 归档文件夹                                    | `archives`       |\n| `category_dir` | 分类文件夹                                    | `categories`     |\n| `code_dir`     | Include code 文件夹                         | `downloads/code` |\n| `i18n_dir`     | 国际化（i18n）文件夹                             | `:lang`          |\n| `skip_render`  | 跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 |                  |\n\n#### 文章\n\n| 参数                  | 描述                                       | 我的配置      |\n| ------------------- | ---------------------------------------- | --------- |\n| `new_post_name`     | 新文章的文件名称                                 | :title.md |\n| `default_layout`    | 预设布局                                     | post      |\n| `auto_spacing`      | 在中文和英文之间加入空格                             | false     |\n| `titlecase`         | 把标题转换为 title case                        | false     |\n| `external_link`     | 在新标签中打开链接                                | true      |\n| `filename_case`     | 把文件名称转换为 (1) 小写或 (2) 大写                  | 0         |\n| `render_drafts`     | 显示草稿                                     | false     |\n| `post_asset_folder` | 启动 [Asset 文件夹](https://hexo.io/zh-cn/docs/asset-folders.html) | false     |\n| `relative_link`     | 把链接改为与根目录的相对位址                           | false     |\n| `future`            | 显示未来的文章                                  | true      |\n| `highlight`         | 代码块的设置                                   |           |\n\n#### 分类 & 标签\n\n| 参数                 | 描述   | 我的配置            |\n| ------------------ | ---- | --------------- |\n| `default_category` | 默认分类 | `uncategorized` |\n| `category_map`     | 分类别名 |                 |\n| `tag_map`          | 标签别名 |                 |\n\n#### 日期 / 时间格式\n\nHexo 使用 [Moment.js](http://momentjs.com/) 来解析和显示时间。\n\n| 参数            | 描述   | 我的配置         |\n| ------------- | ---- | ------------ |\n| `date_format` | 日期格式 | `YYYY-MM-DD` |\n| `time_format` | 时间格式 | `H:mm:ss`    |\n\n#### 分页\n\n| 参数               | 描述                    | 我的配置   |\n| ---------------- | --------------------- | ------ |\n| `per_page`       | 每页显示的文章量 (0 = 关闭分页功能) | `10`   |\n| `pagination_dir` | 分页目录                  | `page` |\n\n#### 扩展\n\n| 参数      | 描述                    | 我的配置     |\n| ------- | --------------------- | -------- |\n| `theme` | 当前主题名称。值为`false`时禁用主题 | material |\n\n此theme的配置默认为landscape，我这里的material为其它主题。\n\n#### Deployment\n\n> deploy:\n> ​     type: git\n> ​     repo: git@github.com:DongFrancis/DongFrancis.github.io.git\n> ​     branch: master\n\n### 一次简单的同步\n\n#### 本地尝试\n\n如果以上内容你已经完成那么我们可以试着在本地测试一下，首先你必须进入博客的根目录，其次启动服务。想这样：\n\n```\n$ cd ~/Documents/Blog\n$ hexo generate\n$ hexo server\n```\n\n然后打开浏览器，进入地址 http://localhost:4000/ ，你会发现你的个人博客已经搭建完成！！！\n\n#### 同步到Github Pages\n\n> 如果你想同步到Github Pages，确保你已经完成了 **git的安装与配置**、 **git的ssh设置**、 **Github Pages的申请与建立**、**Deployment的配置** 。\n\n很好，现在我们可以继续了。\n\n##### 安装插件\n\n进入Blog根目录，执行如下操作\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n##### 同步——deploy\n\n在Blog根目录，执行如下操作\n\n```\n$ hexo deploy\n```\n\n##### 验证\n\n打开Github pages的个人主页，如 https://DongFrancis.github.io.git，你可以验证是否同步成功。\n\n## 四、添加新文章\n\n#### 创建一篇新文章 \n\n在Blog根目录下，你可以使用 `new`命令来新建文章。如\n\n```\n$ hexo new \"my-first-blog\"\n```\n\n执行完此命令后，在`source/_posts/` 目录下会有一个新的文件 `my-first-blog.md` 。\n\n#### 测试\n\n毫无疑问，对于自己些的文章，你总希望确认一下是否完美，这样你才可以展示给其它人看。\n\n具体这样来完成：\n\n```\n$ hexo generate\n$ hexo server\n```\n\n很熟悉的俩句话是么？没错，这就是本地测试的俩个命令，第一句的意思是*生成文件*，第二局的意思是*打开本地服务器*  。\n\n#### 同步到Github Pages\n\n很简单使用 **deploy** 命令即可。\n\n```\n$ hexo deploy\n```\n\n执行完命令后，你便可以在Github Pages上查看了。\n\n## 更换主题\n\n我选择的是 Meterial 主题，一句话：好看！\n\n具体的过程和[官网的教程](https://material.vss.im/start/)一样这里就不详细讲了。\n\n## 总结\n\n搭建博客的作用对于不同的人有不同的作用。对于我来说，是希望将自己所学的知识进一步整理与归纳，以此逐步提升自己。希望这篇教程对大家有所帮助。\n","source":"_posts/博客的开始——如何搭建Hexo.md","raw":"---\ntitle: 博客的开始——如何搭建Hexo\ndate: 2016-12-27 09:43:57\nmathjax: true\ntags: Hexo\ncategories: 技术类\n---\n\n## 概述\n\n#### 导语\n\n> Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且能一键部署到GitHub Pages。\n\n首先，不论这篇文章主要是为了安装什么，第一步该做的是先说明一遍大致的过程，以使读者能够清楚，自己究竟在干什么、还有什么没有完成、为什么要这么做。当然，我会给出一些必要的网站，它们以官网为主，庆幸的是，这些官网都有简体中文的支持。最后，说明一下作者的系统为Mint Linux，它和Ubuntu是一样的，并且作者是一个大二菜鸟，如果有错的话，希望大家能够指出错误，我也会立即改正。\n\n### 具体过程\n\n1. 准备安装环境 \n   * Node.js\n   * Git\n2. 安装Hexo\n3. 开始搭建博客\n   * 初始化Hexo\n   * 修改全局配置文件\n   * 一次简单的同步\n4. 添加新文章\n5. 更换主题\n\n### 给出网址\n\n* [Hexo官方网站](https://hexo.io/zh-cn/)\n* [Material主题官网](https://material.vss.im/)\n* [史上最详细的Hexo博客搭建图文教程](https://xuanwo.org/2015/03/26/hexo-intor/)\n\n## 准备安装环境 \n\n### 安装Node.js\n\n很不幸运的是官方给出的 Node.js 安装方法并不是非常有效。因此我通过Baidu找到了一种简单的方法，在此给出过程。\n\n1. 下载\n\n   第一步很简单，就是从官网上下载二进制包。给出地址。\n\n   * [Node.js官网下载地址](https://nodejs.org/en/download/)\n\n2. 解压下载好的 node-v6.9.2-linux-x64.tar.xz 压缩包\n\n   ```\n   $ tar xvf node-v6.9.2-linux-x64.tar.xz \n   ```\n\n   这样，你可以得到一个名为 node-v6.9.2-linux-x64 的文件夹。\n\n3. 验证 Node.js 的版本\n\n   首先进入 node-v6.9.2-linux-x64 文件夹下的 bin 目录，你会发现有两个可执行文件。如下：\n\n   ```\n   $ cd node-v6.9.2-linux-x64/bin\n   $ ls\n   node  npm\n   ```\n\n   接着我们来看看 Node.js 的版本\n\n   ```\n   $ ./node -v\n   v6.9.2\n   ```\n\n   很好，它是最新的6.9.2版本。\n\n4. 把二进制包放到较为规范的地方。\n\n   什么叫较为规范的地方？举个例子，在Windows下，排除自己定义安装路径的软件，你所有的软件都会在这样一个地址下 `C:\\Program Files` 。在Mint Linux上，我把它规定为 `/opt` ，这个路径包含了所有我手动安装的软件，毕竟虽然有 **apt** ，但是总有些软件不能通过apt安装。很好，下面让我们把它挪到那个规范的地方。\n\n   ```\n   $ sudo mv node-v6.9.2-linux-x64 /opt/\n   $ cd /opt\n   $ ls\n   clion  eclipse  google  node-v6.9.2-linux-x64  pycharm  sublime_text\n   ```\n\n   由此你可以发现，我已经成功移动了文件。这里有个小问题，在执行第一句命令的时候，会提示需要密码，不要担心，直接输入root密码就行，它不是明文的，并不会显示字符。\n\n5. 建立软链接，设置全局\n\n   怎么在shell中直接访问呢？就是通过软链接实现。\n\n   ```\n   $ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/node /usr/local/bin/node\n   $ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/npm /usr/local/bin/npm\n   $ cd /usr/local/bin/\n   $ ls |grep '^[n]'\n   node\n   npm\n   ```\n\n   你会发现，在 `/usr/local/bin`这个目录下已经有 **node** 、**npm** 两个文件了。\n\n6. 验证成功\n\n   打开terminal，输入`node -v`和`npm -v` 来检查是否成功。\n\n   ```\n   $ node -v\n   v6.9.2\n   $ npm -v\n   3.10.9\n   ```\n\n   由此Node.js安装完成，看似很复杂，其实很简单。\n\n### 安装Git\n\nGit的安装是通过apt，极其便捷。\n\n```\nsudo apt-get install git\n```\n\n这样就安装完了。这就是包管理的好处。\n\n其次，ssh的配置安装则参考[Git教程 - *廖雪峰的官方网站*](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000) ,这是非常好的git教程网站。\n\n## 安装Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。根据官方教程：\n\n```\n$ npm install -g hexo-cli\n```\n\n如果出现WARNING，那么你可以忽视它。如果出现ERROR，那么请你使用Baidu或者Bing来解决问题，作者病不能，开速有效的替你解决。\n\n## 开始搭建博客\n\n###  初始化Hexo\n\n首先，我打算把博客的根地址定在 `～/Document/` 。那么开始\n\n```\n$ cd ~/Documents/\n$ hexo init Blog\n$ cd Blog\n$ npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n注意，这里有一些问题。执行第二个命令时常常由于网络的问题卡住，那么建议你把npm的源改为淘宝源，具体教程查看[npm设置淘宝镜像](http://www.jianshu.com/p/fb7251740107/comments/330864)\n\n### 修改全局配置文件 \n\n您可以在 `_config.yml` 中修改大部份的配置。当然参考[官方文档](https://hexo.io/zh-cn/docs/configuration.html)以获得最好的支持\n\n当然你可以查看我的修改方法。\n\n#### 网站\n\n| 参数          | 描述      | 我的配置          |\n| ----------- | ------- | ------------- |\n| title       | 网站标题    | Francis'Blog  |\n| subtitle    | 网站副标题   |               |\n| description | 网站描述    |               |\n| author      | 作者的名字   | Andy Francis  |\n| language    | 网站使用的语言 | zh-CN         |\n| timezone    | 网站时区    | Asia/Shanghai |\n\n#### 网址\n\n| 参数                  | 描述                                       | 我的配置                           |\n| ------------------- | ---------------------------------------- | ------------------------------ |\n| `url`               | 网址                                       | https://dongfrancis.github.io/ |\n| `root`              | 网站根目录                                    | /                              |\n| `permalink`         | 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式 | `:year/:month/:day/:title/`    |\n| `permalink_default` | 永久链接中各部分的默认值                             |                                |\n\n#### 目录\n\n| 参数             | 描述                                       | 我的配置             |\n| -------------- | ---------------------------------------- | ---------------- |\n| `source_dir`   | 资源文件夹，这个文件夹用来存放内容。                       | `source`         |\n| `public_dir`   | 公共文件夹，这个文件夹用于存放生成的站点文件。                  | `public`         |\n| `tag_dir`      | 标签文件夹                                    | `tags`           |\n| `archive_dir`  | 归档文件夹                                    | `archives`       |\n| `category_dir` | 分类文件夹                                    | `categories`     |\n| `code_dir`     | Include code 文件夹                         | `downloads/code` |\n| `i18n_dir`     | 国际化（i18n）文件夹                             | `:lang`          |\n| `skip_render`  | 跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 |                  |\n\n#### 文章\n\n| 参数                  | 描述                                       | 我的配置      |\n| ------------------- | ---------------------------------------- | --------- |\n| `new_post_name`     | 新文章的文件名称                                 | :title.md |\n| `default_layout`    | 预设布局                                     | post      |\n| `auto_spacing`      | 在中文和英文之间加入空格                             | false     |\n| `titlecase`         | 把标题转换为 title case                        | false     |\n| `external_link`     | 在新标签中打开链接                                | true      |\n| `filename_case`     | 把文件名称转换为 (1) 小写或 (2) 大写                  | 0         |\n| `render_drafts`     | 显示草稿                                     | false     |\n| `post_asset_folder` | 启动 [Asset 文件夹](https://hexo.io/zh-cn/docs/asset-folders.html) | false     |\n| `relative_link`     | 把链接改为与根目录的相对位址                           | false     |\n| `future`            | 显示未来的文章                                  | true      |\n| `highlight`         | 代码块的设置                                   |           |\n\n#### 分类 & 标签\n\n| 参数                 | 描述   | 我的配置            |\n| ------------------ | ---- | --------------- |\n| `default_category` | 默认分类 | `uncategorized` |\n| `category_map`     | 分类别名 |                 |\n| `tag_map`          | 标签别名 |                 |\n\n#### 日期 / 时间格式\n\nHexo 使用 [Moment.js](http://momentjs.com/) 来解析和显示时间。\n\n| 参数            | 描述   | 我的配置         |\n| ------------- | ---- | ------------ |\n| `date_format` | 日期格式 | `YYYY-MM-DD` |\n| `time_format` | 时间格式 | `H:mm:ss`    |\n\n#### 分页\n\n| 参数               | 描述                    | 我的配置   |\n| ---------------- | --------------------- | ------ |\n| `per_page`       | 每页显示的文章量 (0 = 关闭分页功能) | `10`   |\n| `pagination_dir` | 分页目录                  | `page` |\n\n#### 扩展\n\n| 参数      | 描述                    | 我的配置     |\n| ------- | --------------------- | -------- |\n| `theme` | 当前主题名称。值为`false`时禁用主题 | material |\n\n此theme的配置默认为landscape，我这里的material为其它主题。\n\n#### Deployment\n\n> deploy:\n> ​     type: git\n> ​     repo: git@github.com:DongFrancis/DongFrancis.github.io.git\n> ​     branch: master\n\n### 一次简单的同步\n\n#### 本地尝试\n\n如果以上内容你已经完成那么我们可以试着在本地测试一下，首先你必须进入博客的根目录，其次启动服务。想这样：\n\n```\n$ cd ~/Documents/Blog\n$ hexo generate\n$ hexo server\n```\n\n然后打开浏览器，进入地址 http://localhost:4000/ ，你会发现你的个人博客已经搭建完成！！！\n\n#### 同步到Github Pages\n\n> 如果你想同步到Github Pages，确保你已经完成了 **git的安装与配置**、 **git的ssh设置**、 **Github Pages的申请与建立**、**Deployment的配置** 。\n\n很好，现在我们可以继续了。\n\n##### 安装插件\n\n进入Blog根目录，执行如下操作\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n##### 同步——deploy\n\n在Blog根目录，执行如下操作\n\n```\n$ hexo deploy\n```\n\n##### 验证\n\n打开Github pages的个人主页，如 https://DongFrancis.github.io.git，你可以验证是否同步成功。\n\n## 四、添加新文章\n\n#### 创建一篇新文章 \n\n在Blog根目录下，你可以使用 `new`命令来新建文章。如\n\n```\n$ hexo new \"my-first-blog\"\n```\n\n执行完此命令后，在`source/_posts/` 目录下会有一个新的文件 `my-first-blog.md` 。\n\n#### 测试\n\n毫无疑问，对于自己些的文章，你总希望确认一下是否完美，这样你才可以展示给其它人看。\n\n具体这样来完成：\n\n```\n$ hexo generate\n$ hexo server\n```\n\n很熟悉的俩句话是么？没错，这就是本地测试的俩个命令，第一句的意思是*生成文件*，第二局的意思是*打开本地服务器*  。\n\n#### 同步到Github Pages\n\n很简单使用 **deploy** 命令即可。\n\n```\n$ hexo deploy\n```\n\n执行完命令后，你便可以在Github Pages上查看了。\n\n## 更换主题\n\n我选择的是 Meterial 主题，一句话：好看！\n\n具体的过程和[官网的教程](https://material.vss.im/start/)一样这里就不详细讲了。\n\n## 总结\n\n搭建博客的作用对于不同的人有不同的作用。对于我来说，是希望将自己所学的知识进一步整理与归纳，以此逐步提升自己。希望这篇教程对大家有所帮助。\n","slug":"博客的开始——如何搭建Hexo","published":1,"updated":"2018-07-03T06:29:50.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5e9u1m003qplxps2dkbp0r","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h4 id=\"导语\"><a href=\"#导语\" class=\"headerlink\" title=\"导语\"></a>导语</h4><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且能一键部署到GitHub Pages。</p>\n</blockquote>\n<p>首先，不论这篇文章主要是为了安装什么，第一步该做的是先说明一遍大致的过程，以使读者能够清楚，自己究竟在干什么、还有什么没有完成、为什么要这么做。当然，我会给出一些必要的网站，它们以官网为主，庆幸的是，这些官网都有简体中文的支持。最后，说明一下作者的系统为Mint Linux，它和Ubuntu是一样的，并且作者是一个大二菜鸟，如果有错的话，希望大家能够指出错误，我也会立即改正。</p>\n<h3 id=\"具体过程\"><a href=\"#具体过程\" class=\"headerlink\" title=\"具体过程\"></a>具体过程</h3><ol>\n<li>准备安装环境 <ul>\n<li>Node.js</li>\n<li>Git</li>\n</ul>\n</li>\n<li>安装Hexo</li>\n<li>开始搭建博客<ul>\n<li>初始化Hexo</li>\n<li>修改全局配置文件</li>\n<li>一次简单的同步</li>\n</ul>\n</li>\n<li>添加新文章</li>\n<li>更换主题</li>\n</ol>\n<h3 id=\"给出网址\"><a href=\"#给出网址\" class=\"headerlink\" title=\"给出网址\"></a>给出网址</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo官方网站</a></li>\n<li><a href=\"https://material.vss.im/\" target=\"_blank\" rel=\"noopener\">Material主题官网</a></li>\n<li><a href=\"https://xuanwo.org/2015/03/26/hexo-intor/\" target=\"_blank\" rel=\"noopener\">史上最详细的Hexo博客搭建图文教程</a></li>\n</ul>\n<h2 id=\"准备安装环境\"><a href=\"#准备安装环境\" class=\"headerlink\" title=\"准备安装环境\"></a>准备安装环境</h2><h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>很不幸运的是官方给出的 Node.js 安装方法并不是非常有效。因此我通过Baidu找到了一种简单的方法，在此给出过程。</p>\n<ol>\n<li><p>下载</p>\n<p>第一步很简单，就是从官网上下载二进制包。给出地址。</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">Node.js官网下载地址</a></li>\n</ul>\n</li>\n<li><p>解压下载好的 node-v6.9.2-linux-x64.tar.xz 压缩包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvf node-v6.9.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n<p>这样，你可以得到一个名为 node-v6.9.2-linux-x64 的文件夹。</p>\n</li>\n<li><p>验证 Node.js 的版本</p>\n<p>首先进入 node-v6.9.2-linux-x64 文件夹下的 bin 目录，你会发现有两个可执行文件。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd node-v6.9.2-linux-x64/bin</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">node  npm</span><br></pre></td></tr></table></figure>\n<p>接着我们来看看 Node.js 的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./node -v</span><br><span class=\"line\">v6.9.2</span><br></pre></td></tr></table></figure>\n<p>很好，它是最新的6.9.2版本。</p>\n</li>\n<li><p>把二进制包放到较为规范的地方。</p>\n<p>什么叫较为规范的地方？举个例子，在Windows下，排除自己定义安装路径的软件，你所有的软件都会在这样一个地址下 <code>C:\\Program Files</code> 。在Mint Linux上，我把它规定为 <code>/opt</code> ，这个路径包含了所有我手动安装的软件，毕竟虽然有 <strong>apt</strong> ，但是总有些软件不能通过apt安装。很好，下面让我们把它挪到那个规范的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv node-v6.9.2-linux-x64 /opt/</span><br><span class=\"line\">$ cd /opt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">clion  eclipse  google  node-v6.9.2-linux-x64  pycharm  sublime_text</span><br></pre></td></tr></table></figure>\n<p>由此你可以发现，我已经成功移动了文件。这里有个小问题，在执行第一句命令的时候，会提示需要密码，不要担心，直接输入root密码就行，它不是明文的，并不会显示字符。</p>\n</li>\n<li><p>建立软链接，设置全局</p>\n<p>怎么在shell中直接访问呢？就是通过软链接实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/node /usr/local/bin/node</span><br><span class=\"line\">$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class=\"line\">$ cd /usr/local/bin/</span><br><span class=\"line\">$ ls |grep &apos;^[n]&apos;</span><br><span class=\"line\">node</span><br><span class=\"line\">npm</span><br></pre></td></tr></table></figure>\n<p>你会发现，在 <code>/usr/local/bin</code>这个目录下已经有 <strong>node</strong> 、<strong>npm</strong> 两个文件了。</p>\n</li>\n<li><p>验证成功</p>\n<p>打开terminal，输入<code>node -v</code>和<code>npm -v</code> 来检查是否成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v6.9.2</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">3.10.9</span><br></pre></td></tr></table></figure>\n<p>由此Node.js安装完成，看似很复杂，其实很简单。</p>\n</li>\n</ol>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>Git的安装是通过apt，极其便捷。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>这样就安装完了。这就是包管理的好处。</p>\n<p>其次，ssh的配置安装则参考<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000\" target=\"_blank\" rel=\"noopener\">Git教程 - <em>廖雪峰的官方网站</em></a> ,这是非常好的git教程网站。</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。根据官方教程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>如果出现WARNING，那么你可以忽视它。如果出现ERROR，那么请你使用Baidu或者Bing来解决问题，作者病不能，开速有效的替你解决。</p>\n<h2 id=\"开始搭建博客\"><a href=\"#开始搭建博客\" class=\"headerlink\" title=\"开始搭建博客\"></a>开始搭建博客</h2><h3 id=\"初始化Hexo\"><a href=\"#初始化Hexo\" class=\"headerlink\" title=\"初始化Hexo\"></a>初始化Hexo</h3><p>首先，我打算把博客的根地址定在 <code>～/Document/</code> 。那么开始</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/Documents/</span><br><span class=\"line\">$ hexo init Blog</span><br><span class=\"line\">$ cd Blog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>注意，这里有一些问题。执行第二个命令时常常由于网络的问题卡住，那么建议你把npm的源改为淘宝源，具体教程查看<a href=\"http://www.jianshu.com/p/fb7251740107/comments/330864\" target=\"_blank\" rel=\"noopener\">npm设置淘宝镜像</a></p>\n<h3 id=\"修改全局配置文件\"><a href=\"#修改全局配置文件\" class=\"headerlink\" title=\"修改全局配置文件\"></a>修改全局配置文件</h3><p>您可以在 <code>_config.yml</code> 中修改大部份的配置。当然参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>以获得最好的支持</p>\n<p>当然你可以查看我的修改方法。</p>\n<h4 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td>网站标题</td>\n<td>Francis’Blog</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n<td></td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n<td></td>\n</tr>\n<tr>\n<td>author</td>\n<td>作者的名字</td>\n<td>Andy Francis</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言</td>\n<td>zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区</td>\n<td>Asia/Shanghai</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"网址\"><a href=\"#网址\" class=\"headerlink\" title=\"网址\"></a>网址</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>url</code></td>\n<td>网址</td>\n<td><a href=\"https://dongfrancis.github.io/\" target=\"_blank\" rel=\"noopener\">https://dongfrancis.github.io/</a></td>\n</tr>\n<tr>\n<td><code>root</code></td>\n<td>网站根目录</td>\n<td>/</td>\n</tr>\n<tr>\n<td><code>permalink</code></td>\n<td>文章的 <a href=\"https://hexo.io/zh-cn/docs/permalinks.html\" target=\"_blank\" rel=\"noopener\">永久链接</a> 格式</td>\n<td><code>:year/:month/:day/:title/</code></td>\n</tr>\n<tr>\n<td><code>permalink_default</code></td>\n<td>永久链接中各部分的默认值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>source_dir</code></td>\n<td>资源文件夹，这个文件夹用来存放内容。</td>\n<td><code>source</code></td>\n</tr>\n<tr>\n<td><code>public_dir</code></td>\n<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>\n<td><code>public</code></td>\n</tr>\n<tr>\n<td><code>tag_dir</code></td>\n<td>标签文件夹</td>\n<td><code>tags</code></td>\n</tr>\n<tr>\n<td><code>archive_dir</code></td>\n<td>归档文件夹</td>\n<td><code>archives</code></td>\n</tr>\n<tr>\n<td><code>category_dir</code></td>\n<td>分类文件夹</td>\n<td><code>categories</code></td>\n</tr>\n<tr>\n<td><code>code_dir</code></td>\n<td>Include code 文件夹</td>\n<td><code>downloads/code</code></td>\n</tr>\n<tr>\n<td><code>i18n_dir</code></td>\n<td>国际化（i18n）文件夹</td>\n<td><code>:lang</code></td>\n</tr>\n<tr>\n<td><code>skip_render</code></td>\n<td>跳过指定文件的渲染，您可使用 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">glob 表达式</a>来匹配路径。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>new_post_name</code></td>\n<td>新文章的文件名称</td>\n<td>:title.md</td>\n</tr>\n<tr>\n<td><code>default_layout</code></td>\n<td>预设布局</td>\n<td>post</td>\n</tr>\n<tr>\n<td><code>auto_spacing</code></td>\n<td>在中文和英文之间加入空格</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>titlecase</code></td>\n<td>把标题转换为 title case</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>external_link</code></td>\n<td>在新标签中打开链接</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>filename_case</code></td>\n<td>把文件名称转换为 (1) 小写或 (2) 大写</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>render_drafts</code></td>\n<td>显示草稿</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>post_asset_folder</code></td>\n<td>启动 <a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">Asset 文件夹</a></td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>relative_link</code></td>\n<td>把链接改为与根目录的相对位址</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>future</code></td>\n<td>显示未来的文章</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>highlight</code></td>\n<td>代码块的设置</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分类-amp-标签\"><a href=\"#分类-amp-标签\" class=\"headerlink\" title=\"分类 &amp; 标签\"></a>分类 &amp; 标签</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default_category</code></td>\n<td>默认分类</td>\n<td><code>uncategorized</code></td>\n</tr>\n<tr>\n<td><code>category_map</code></td>\n<td>分类别名</td>\n<td></td>\n</tr>\n<tr>\n<td><code>tag_map</code></td>\n<td>标签别名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"日期-时间格式\"><a href=\"#日期-时间格式\" class=\"headerlink\" title=\"日期 / 时间格式\"></a>日期 / 时间格式</h4><p>Hexo 使用 <a href=\"http://momentjs.com/\" target=\"_blank\" rel=\"noopener\">Moment.js</a> 来解析和显示时间。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>date_format</code></td>\n<td>日期格式</td>\n<td><code>YYYY-MM-DD</code></td>\n</tr>\n<tr>\n<td><code>time_format</code></td>\n<td>时间格式</td>\n<td><code>H:mm:ss</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>per_page</code></td>\n<td>每页显示的文章量 (0 = 关闭分页功能)</td>\n<td><code>10</code></td>\n</tr>\n<tr>\n<td><code>pagination_dir</code></td>\n<td>分页目录</td>\n<td><code>page</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>theme</code></td>\n<td>当前主题名称。值为<code>false</code>时禁用主题</td>\n<td>material</td>\n</tr>\n</tbody>\n</table>\n<p>此theme的配置默认为landscape，我这里的material为其它主题。</p>\n<h4 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h4><blockquote>\n<p>deploy:<br>​     type: git<br>​     repo: <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:DongFrancis/DongFrancis.github.io.git<br>​     branch: master</p>\n</blockquote>\n<h3 id=\"一次简单的同步\"><a href=\"#一次简单的同步\" class=\"headerlink\" title=\"一次简单的同步\"></a>一次简单的同步</h3><h4 id=\"本地尝试\"><a href=\"#本地尝试\" class=\"headerlink\" title=\"本地尝试\"></a>本地尝试</h4><p>如果以上内容你已经完成那么我们可以试着在本地测试一下，首先你必须进入博客的根目录，其次启动服务。想这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/Documents/Blog</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>然后打开浏览器，进入地址 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，你会发现你的个人博客已经搭建完成！！！</p>\n<h4 id=\"同步到Github-Pages\"><a href=\"#同步到Github-Pages\" class=\"headerlink\" title=\"同步到Github Pages\"></a>同步到Github Pages</h4><blockquote>\n<p>如果你想同步到Github Pages，确保你已经完成了 <strong>git的安装与配置</strong>、 <strong>git的ssh设置</strong>、 <strong>Github Pages的申请与建立</strong>、<strong>Deployment的配置</strong> 。</p>\n</blockquote>\n<p>很好，现在我们可以继续了。</p>\n<h5 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h5><p>进入Blog根目录，执行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<h5 id=\"同步——deploy\"><a href=\"#同步——deploy\" class=\"headerlink\" title=\"同步——deploy\"></a>同步——deploy</h5><p>在Blog根目录，执行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<h5 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h5><p>打开Github pages的个人主页，如 <a href=\"https://DongFrancis.github.io.git，你可以验证是否同步成功。\" target=\"_blank\" rel=\"noopener\">https://DongFrancis.github.io.git，你可以验证是否同步成功。</a></p>\n<h2 id=\"四、添加新文章\"><a href=\"#四、添加新文章\" class=\"headerlink\" title=\"四、添加新文章\"></a>四、添加新文章</h2><h4 id=\"创建一篇新文章\"><a href=\"#创建一篇新文章\" class=\"headerlink\" title=\"创建一篇新文章\"></a>创建一篇新文章</h4><p>在Blog根目录下，你可以使用 <code>new</code>命令来新建文章。如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;my-first-blog&quot;</span><br></pre></td></tr></table></figure>\n<p>执行完此命令后，在<code>source/_posts/</code> 目录下会有一个新的文件 <code>my-first-blog.md</code> 。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>毫无疑问，对于自己些的文章，你总希望确认一下是否完美，这样你才可以展示给其它人看。</p>\n<p>具体这样来完成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>很熟悉的俩句话是么？没错，这就是本地测试的俩个命令，第一句的意思是<em>生成文件</em>，第二局的意思是<em>打开本地服务器</em>  。</p>\n<h4 id=\"同步到Github-Pages-1\"><a href=\"#同步到Github-Pages-1\" class=\"headerlink\" title=\"同步到Github Pages\"></a>同步到Github Pages</h4><p>很简单使用 <strong>deploy</strong> 命令即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>执行完命令后，你便可以在Github Pages上查看了。</p>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>我选择的是 Meterial 主题，一句话：好看！</p>\n<p>具体的过程和<a href=\"https://material.vss.im/start/\" target=\"_blank\" rel=\"noopener\">官网的教程</a>一样这里就不详细讲了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>搭建博客的作用对于不同的人有不同的作用。对于我来说，是希望将自己所学的知识进一步整理与归纳，以此逐步提升自己。希望这篇教程对大家有所帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h4 id=\"导语\"><a href=\"#导语\" class=\"headerlink\" title=\"导语\"></a>导语</h4><blockquote>\n<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且能一键部署到GitHub Pages。</p>\n</blockquote>\n<p>首先，不论这篇文章主要是为了安装什么，第一步该做的是先说明一遍大致的过程，以使读者能够清楚，自己究竟在干什么、还有什么没有完成、为什么要这么做。当然，我会给出一些必要的网站，它们以官网为主，庆幸的是，这些官网都有简体中文的支持。最后，说明一下作者的系统为Mint Linux，它和Ubuntu是一样的，并且作者是一个大二菜鸟，如果有错的话，希望大家能够指出错误，我也会立即改正。</p>\n<h3 id=\"具体过程\"><a href=\"#具体过程\" class=\"headerlink\" title=\"具体过程\"></a>具体过程</h3><ol>\n<li>准备安装环境 <ul>\n<li>Node.js</li>\n<li>Git</li>\n</ul>\n</li>\n<li>安装Hexo</li>\n<li>开始搭建博客<ul>\n<li>初始化Hexo</li>\n<li>修改全局配置文件</li>\n<li>一次简单的同步</li>\n</ul>\n</li>\n<li>添加新文章</li>\n<li>更换主题</li>\n</ol>\n<h3 id=\"给出网址\"><a href=\"#给出网址\" class=\"headerlink\" title=\"给出网址\"></a>给出网址</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo官方网站</a></li>\n<li><a href=\"https://material.vss.im/\" target=\"_blank\" rel=\"noopener\">Material主题官网</a></li>\n<li><a href=\"https://xuanwo.org/2015/03/26/hexo-intor/\" target=\"_blank\" rel=\"noopener\">史上最详细的Hexo博客搭建图文教程</a></li>\n</ul>\n<h2 id=\"准备安装环境\"><a href=\"#准备安装环境\" class=\"headerlink\" title=\"准备安装环境\"></a>准备安装环境</h2><h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>很不幸运的是官方给出的 Node.js 安装方法并不是非常有效。因此我通过Baidu找到了一种简单的方法，在此给出过程。</p>\n<ol>\n<li><p>下载</p>\n<p>第一步很简单，就是从官网上下载二进制包。给出地址。</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">Node.js官网下载地址</a></li>\n</ul>\n</li>\n<li><p>解压下载好的 node-v6.9.2-linux-x64.tar.xz 压缩包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvf node-v6.9.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n<p>这样，你可以得到一个名为 node-v6.9.2-linux-x64 的文件夹。</p>\n</li>\n<li><p>验证 Node.js 的版本</p>\n<p>首先进入 node-v6.9.2-linux-x64 文件夹下的 bin 目录，你会发现有两个可执行文件。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd node-v6.9.2-linux-x64/bin</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">node  npm</span><br></pre></td></tr></table></figure>\n<p>接着我们来看看 Node.js 的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./node -v</span><br><span class=\"line\">v6.9.2</span><br></pre></td></tr></table></figure>\n<p>很好，它是最新的6.9.2版本。</p>\n</li>\n<li><p>把二进制包放到较为规范的地方。</p>\n<p>什么叫较为规范的地方？举个例子，在Windows下，排除自己定义安装路径的软件，你所有的软件都会在这样一个地址下 <code>C:\\Program Files</code> 。在Mint Linux上，我把它规定为 <code>/opt</code> ，这个路径包含了所有我手动安装的软件，毕竟虽然有 <strong>apt</strong> ，但是总有些软件不能通过apt安装。很好，下面让我们把它挪到那个规范的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv node-v6.9.2-linux-x64 /opt/</span><br><span class=\"line\">$ cd /opt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">clion  eclipse  google  node-v6.9.2-linux-x64  pycharm  sublime_text</span><br></pre></td></tr></table></figure>\n<p>由此你可以发现，我已经成功移动了文件。这里有个小问题，在执行第一句命令的时候，会提示需要密码，不要担心，直接输入root密码就行，它不是明文的，并不会显示字符。</p>\n</li>\n<li><p>建立软链接，设置全局</p>\n<p>怎么在shell中直接访问呢？就是通过软链接实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/node /usr/local/bin/node</span><br><span class=\"line\">$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class=\"line\">$ cd /usr/local/bin/</span><br><span class=\"line\">$ ls |grep &apos;^[n]&apos;</span><br><span class=\"line\">node</span><br><span class=\"line\">npm</span><br></pre></td></tr></table></figure>\n<p>你会发现，在 <code>/usr/local/bin</code>这个目录下已经有 <strong>node</strong> 、<strong>npm</strong> 两个文件了。</p>\n</li>\n<li><p>验证成功</p>\n<p>打开terminal，输入<code>node -v</code>和<code>npm -v</code> 来检查是否成功。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v6.9.2</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">3.10.9</span><br></pre></td></tr></table></figure>\n<p>由此Node.js安装完成，看似很复杂，其实很简单。</p>\n</li>\n</ol>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>Git的安装是通过apt，极其便捷。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>这样就安装完了。这就是包管理的好处。</p>\n<p>其次，ssh的配置安装则参考<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000\" target=\"_blank\" rel=\"noopener\">Git教程 - <em>廖雪峰的官方网站</em></a> ,这是非常好的git教程网站。</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。根据官方教程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>如果出现WARNING，那么你可以忽视它。如果出现ERROR，那么请你使用Baidu或者Bing来解决问题，作者病不能，开速有效的替你解决。</p>\n<h2 id=\"开始搭建博客\"><a href=\"#开始搭建博客\" class=\"headerlink\" title=\"开始搭建博客\"></a>开始搭建博客</h2><h3 id=\"初始化Hexo\"><a href=\"#初始化Hexo\" class=\"headerlink\" title=\"初始化Hexo\"></a>初始化Hexo</h3><p>首先，我打算把博客的根地址定在 <code>～/Document/</code> 。那么开始</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/Documents/</span><br><span class=\"line\">$ hexo init Blog</span><br><span class=\"line\">$ cd Blog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<p>注意，这里有一些问题。执行第二个命令时常常由于网络的问题卡住，那么建议你把npm的源改为淘宝源，具体教程查看<a href=\"http://www.jianshu.com/p/fb7251740107/comments/330864\" target=\"_blank\" rel=\"noopener\">npm设置淘宝镜像</a></p>\n<h3 id=\"修改全局配置文件\"><a href=\"#修改全局配置文件\" class=\"headerlink\" title=\"修改全局配置文件\"></a>修改全局配置文件</h3><p>您可以在 <code>_config.yml</code> 中修改大部份的配置。当然参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>以获得最好的支持</p>\n<p>当然你可以查看我的修改方法。</p>\n<h4 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td>网站标题</td>\n<td>Francis’Blog</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n<td></td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n<td></td>\n</tr>\n<tr>\n<td>author</td>\n<td>作者的名字</td>\n<td>Andy Francis</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言</td>\n<td>zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区</td>\n<td>Asia/Shanghai</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"网址\"><a href=\"#网址\" class=\"headerlink\" title=\"网址\"></a>网址</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>url</code></td>\n<td>网址</td>\n<td><a href=\"https://dongfrancis.github.io/\" target=\"_blank\" rel=\"noopener\">https://dongfrancis.github.io/</a></td>\n</tr>\n<tr>\n<td><code>root</code></td>\n<td>网站根目录</td>\n<td>/</td>\n</tr>\n<tr>\n<td><code>permalink</code></td>\n<td>文章的 <a href=\"https://hexo.io/zh-cn/docs/permalinks.html\" target=\"_blank\" rel=\"noopener\">永久链接</a> 格式</td>\n<td><code>:year/:month/:day/:title/</code></td>\n</tr>\n<tr>\n<td><code>permalink_default</code></td>\n<td>永久链接中各部分的默认值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>source_dir</code></td>\n<td>资源文件夹，这个文件夹用来存放内容。</td>\n<td><code>source</code></td>\n</tr>\n<tr>\n<td><code>public_dir</code></td>\n<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>\n<td><code>public</code></td>\n</tr>\n<tr>\n<td><code>tag_dir</code></td>\n<td>标签文件夹</td>\n<td><code>tags</code></td>\n</tr>\n<tr>\n<td><code>archive_dir</code></td>\n<td>归档文件夹</td>\n<td><code>archives</code></td>\n</tr>\n<tr>\n<td><code>category_dir</code></td>\n<td>分类文件夹</td>\n<td><code>categories</code></td>\n</tr>\n<tr>\n<td><code>code_dir</code></td>\n<td>Include code 文件夹</td>\n<td><code>downloads/code</code></td>\n</tr>\n<tr>\n<td><code>i18n_dir</code></td>\n<td>国际化（i18n）文件夹</td>\n<td><code>:lang</code></td>\n</tr>\n<tr>\n<td><code>skip_render</code></td>\n<td>跳过指定文件的渲染，您可使用 <a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"noopener\">glob 表达式</a>来匹配路径。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>new_post_name</code></td>\n<td>新文章的文件名称</td>\n<td>:title.md</td>\n</tr>\n<tr>\n<td><code>default_layout</code></td>\n<td>预设布局</td>\n<td>post</td>\n</tr>\n<tr>\n<td><code>auto_spacing</code></td>\n<td>在中文和英文之间加入空格</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>titlecase</code></td>\n<td>把标题转换为 title case</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>external_link</code></td>\n<td>在新标签中打开链接</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>filename_case</code></td>\n<td>把文件名称转换为 (1) 小写或 (2) 大写</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>render_drafts</code></td>\n<td>显示草稿</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>post_asset_folder</code></td>\n<td>启动 <a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">Asset 文件夹</a></td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>relative_link</code></td>\n<td>把链接改为与根目录的相对位址</td>\n<td>false</td>\n</tr>\n<tr>\n<td><code>future</code></td>\n<td>显示未来的文章</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>highlight</code></td>\n<td>代码块的设置</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分类-amp-标签\"><a href=\"#分类-amp-标签\" class=\"headerlink\" title=\"分类 &amp; 标签\"></a>分类 &amp; 标签</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default_category</code></td>\n<td>默认分类</td>\n<td><code>uncategorized</code></td>\n</tr>\n<tr>\n<td><code>category_map</code></td>\n<td>分类别名</td>\n<td></td>\n</tr>\n<tr>\n<td><code>tag_map</code></td>\n<td>标签别名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"日期-时间格式\"><a href=\"#日期-时间格式\" class=\"headerlink\" title=\"日期 / 时间格式\"></a>日期 / 时间格式</h4><p>Hexo 使用 <a href=\"http://momentjs.com/\" target=\"_blank\" rel=\"noopener\">Moment.js</a> 来解析和显示时间。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>date_format</code></td>\n<td>日期格式</td>\n<td><code>YYYY-MM-DD</code></td>\n</tr>\n<tr>\n<td><code>time_format</code></td>\n<td>时间格式</td>\n<td><code>H:mm:ss</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>per_page</code></td>\n<td>每页显示的文章量 (0 = 关闭分页功能)</td>\n<td><code>10</code></td>\n</tr>\n<tr>\n<td><code>pagination_dir</code></td>\n<td>分页目录</td>\n<td><code>page</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>我的配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>theme</code></td>\n<td>当前主题名称。值为<code>false</code>时禁用主题</td>\n<td>material</td>\n</tr>\n</tbody>\n</table>\n<p>此theme的配置默认为landscape，我这里的material为其它主题。</p>\n<h4 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h4><blockquote>\n<p>deploy:<br>​     type: git<br>​     repo: <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:DongFrancis/DongFrancis.github.io.git<br>​     branch: master</p>\n</blockquote>\n<h3 id=\"一次简单的同步\"><a href=\"#一次简单的同步\" class=\"headerlink\" title=\"一次简单的同步\"></a>一次简单的同步</h3><h4 id=\"本地尝试\"><a href=\"#本地尝试\" class=\"headerlink\" title=\"本地尝试\"></a>本地尝试</h4><p>如果以上内容你已经完成那么我们可以试着在本地测试一下，首先你必须进入博客的根目录，其次启动服务。想这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/Documents/Blog</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>然后打开浏览器，进入地址 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> ，你会发现你的个人博客已经搭建完成！！！</p>\n<h4 id=\"同步到Github-Pages\"><a href=\"#同步到Github-Pages\" class=\"headerlink\" title=\"同步到Github Pages\"></a>同步到Github Pages</h4><blockquote>\n<p>如果你想同步到Github Pages，确保你已经完成了 <strong>git的安装与配置</strong>、 <strong>git的ssh设置</strong>、 <strong>Github Pages的申请与建立</strong>、<strong>Deployment的配置</strong> 。</p>\n</blockquote>\n<p>很好，现在我们可以继续了。</p>\n<h5 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h5><p>进入Blog根目录，执行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<h5 id=\"同步——deploy\"><a href=\"#同步——deploy\" class=\"headerlink\" title=\"同步——deploy\"></a>同步——deploy</h5><p>在Blog根目录，执行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<h5 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h5><p>打开Github pages的个人主页，如 <a href=\"https://DongFrancis.github.io.git，你可以验证是否同步成功。\" target=\"_blank\" rel=\"noopener\">https://DongFrancis.github.io.git，你可以验证是否同步成功。</a></p>\n<h2 id=\"四、添加新文章\"><a href=\"#四、添加新文章\" class=\"headerlink\" title=\"四、添加新文章\"></a>四、添加新文章</h2><h4 id=\"创建一篇新文章\"><a href=\"#创建一篇新文章\" class=\"headerlink\" title=\"创建一篇新文章\"></a>创建一篇新文章</h4><p>在Blog根目录下，你可以使用 <code>new</code>命令来新建文章。如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;my-first-blog&quot;</span><br></pre></td></tr></table></figure>\n<p>执行完此命令后，在<code>source/_posts/</code> 目录下会有一个新的文件 <code>my-first-blog.md</code> 。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>毫无疑问，对于自己些的文章，你总希望确认一下是否完美，这样你才可以展示给其它人看。</p>\n<p>具体这样来完成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>很熟悉的俩句话是么？没错，这就是本地测试的俩个命令，第一句的意思是<em>生成文件</em>，第二局的意思是<em>打开本地服务器</em>  。</p>\n<h4 id=\"同步到Github-Pages-1\"><a href=\"#同步到Github-Pages-1\" class=\"headerlink\" title=\"同步到Github Pages\"></a>同步到Github Pages</h4><p>很简单使用 <strong>deploy</strong> 命令即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>执行完命令后，你便可以在Github Pages上查看了。</p>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>我选择的是 Meterial 主题，一句话：好看！</p>\n<p>具体的过程和<a href=\"https://material.vss.im/start/\" target=\"_blank\" rel=\"noopener\">官网的教程</a>一样这里就不详细讲了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>搭建博客的作用对于不同的人有不同的作用。对于我来说，是希望将自己所学的知识进一步整理与归纳，以此逐步提升自己。希望这篇教程对大家有所帮助。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjj5e9tut0005plxplbqhg5if","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tuz000bplxph8c6v5y8"},{"post_id":"cjj5e9tuj0000plxpdt0ne13n","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tv1000fplxpq8ixgytu"},{"post_id":"cjj5e9tuu0006plxpg2uj2tzj","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tv5000iplxpv2hhvhsq"},{"post_id":"cjj5e9tux0009plxpne1iv234","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tv8000mplxp91jy3bpz"},{"post_id":"cjj5e9tun0001plxp2t6qhbas","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tva000pplxpvieot7gd"},{"post_id":"cjj5e9tuy000aplxp9d8u43u2","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvc000splxpbe9q6cu1"},{"post_id":"cjj5e9tv0000eplxp4ovsolbx","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tve000vplxp0szs9j9y"},{"post_id":"cjj5e9tur0004plxpuqlpafei","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvf000xplxpdp9r6o9r"},{"post_id":"cjj5e9tv3000hplxpp08muwe0","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvh0011plxpk0nh7ey4"},{"post_id":"cjj5e9tv7000lplxpedrwthzt","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvj0013plxpqxahxubt"},{"post_id":"cjj5e9tv9000oplxpaql8i42l","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvl0016plxprle812xo"},{"post_id":"cjj5e9tvc000rplxph5eohk3e","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvn0019plxpm2lltwhh"},{"post_id":"cjj5e9tvf000wplxpcpykxq1w","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvo001dplxp7xgmx0xb"},{"post_id":"cjj5e9tvg0010plxpp5a9wr3r","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvq001fplxpj7gzr12d"},{"post_id":"cjj5e9tvi0012plxpjdq93aku","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvs001iplxpdaj50jeu"},{"post_id":"cjj5e9tvd000uplxp948a8v9q","category_id":"cjj5e9tvg000zplxpjgxotvmm","_id":"cjj5e9tvu001lplxpnnb0grgo"},{"post_id":"cjj5e9tvk0015plxphf73vnej","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvv001oplxpk565wpmh"},{"post_id":"cjj5e9tvm0018plxpskv7pv3g","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvx001splxpgv61m0wr"},{"post_id":"cjj5e9tvo001cplxp4q7vvnt8","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvy001vplxp7l45tmxb"},{"post_id":"cjj5e9tvp001eplxpb4ko6jxk","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvy001xplxp6scd7t7e"},{"post_id":"cjj5e9tvs001hplxpkfbngel4","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvz001zplxpon9nkboh"},{"post_id":"cjj5e9tvt001kplxpm6dcfb88","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9tvz0021plxp0b9vamt8"},{"post_id":"cjj5e9tvv001nplxppead064h","category_id":"cjj5e9tvy001tplxpkbeytnyi","_id":"cjj5e9tw00023plxpcfiva0o7"},{"post_id":"cjj5e9tvx001rplxpw7581zs3","category_id":"cjj5e9tvy001tplxpkbeytnyi","_id":"cjj5e9tw10027plxp61u0bb9t"},{"post_id":"cjj5e9u1j003pplxprifr1vof","category_id":"cjj5e9tup0002plxp6yjy6t3e","_id":"cjj5e9u1o003tplxpjrrusr7z"},{"post_id":"cjj5e9u1m003qplxps2dkbp0r","category_id":"cjj5e9u1o003splxpi0fwg1c1","_id":"cjj5e9u1p003wplxpkjgupuor"}],"PostTag":[{"post_id":"cjj5e9tuj0000plxpdt0ne13n","tag_id":"cjj5e9tur0003plxpwk42gvqs","_id":"cjj5e9tv2000gplxprmoz1b8t"},{"post_id":"cjj5e9tuj0000plxpdt0ne13n","tag_id":"cjj5e9tuv0008plxptx620x54","_id":"cjj5e9tv6000jplxpjwhv57g5"},{"post_id":"cjj5e9tun0001plxp2t6qhbas","tag_id":"cjj5e9tv0000dplxpzn0iiy3r","_id":"cjj5e9tv9000nplxpc815m8hi"},{"post_id":"cjj5e9tur0004plxpuqlpafei","tag_id":"cjj5e9tv7000kplxp8eobblrl","_id":"cjj5e9tvd000tplxpb1bxqb9u"},{"post_id":"cjj5e9tut0005plxplbqhg5if","tag_id":"cjj5e9tvb000qplxpu66vo7qe","_id":"cjj5e9tvl0017plxpx68jx23w"},{"post_id":"cjj5e9tut0005plxplbqhg5if","tag_id":"cjj5e9tvf000yplxpd10dxaii","_id":"cjj5e9tvn001aplxpr54k1swh"},{"post_id":"cjj5e9tuu0006plxpg2uj2tzj","tag_id":"cjj5e9tvj0014plxpoeuu603g","_id":"cjj5e9tvt001jplxpzy2mwuvd"},{"post_id":"cjj5e9tuu0006plxpg2uj2tzj","tag_id":"cjj5e9tvn001bplxpssjkidwa","_id":"cjj5e9tvu001mplxpupem0tku"},{"post_id":"cjj5e9tux0009plxpne1iv234","tag_id":"cjj5e9tur0003plxpwk42gvqs","_id":"cjj5e9tvw001qplxp4t776wy6"},{"post_id":"cjj5e9tux0009plxpne1iv234","tag_id":"cjj5e9tvr001gplxpo33wpjm6","_id":"cjj5e9tvy001uplxpf76gp7s6"},{"post_id":"cjj5e9tuy000aplxp9d8u43u2","tag_id":"cjj5e9tvj0014plxpoeuu603g","_id":"cjj5e9tw00022plxph68tl54k"},{"post_id":"cjj5e9tuy000aplxp9d8u43u2","tag_id":"cjj5e9tvy001wplxpn1z61sb1","_id":"cjj5e9tw00024plxp2bsevnlw"},{"post_id":"cjj5e9tv0000eplxp4ovsolbx","tag_id":"cjj5e9tvz0020plxplorc3imt","_id":"cjj5e9tw00026plxpm1intw67"},{"post_id":"cjj5e9tv3000hplxpp08muwe0","tag_id":"cjj5e9tvj0014plxpoeuu603g","_id":"cjj5e9tw2002bplxpbsw9zr32"},{"post_id":"cjj5e9tv3000hplxpp08muwe0","tag_id":"cjj5e9tw10028plxpx89mc636","_id":"cjj5e9tw2002cplxpkji5pqrl"},{"post_id":"cjj5e9tv3000hplxpp08muwe0","tag_id":"cjj5e9tw10029plxp7oi6xppj","_id":"cjj5e9tw3002eplxptv6ifzoc"},{"post_id":"cjj5e9tv7000lplxpedrwthzt","tag_id":"cjj5e9tvj0014plxpoeuu603g","_id":"cjj5e9tw3002gplxpi5anc5v2"},{"post_id":"cjj5e9tv7000lplxpedrwthzt","tag_id":"cjj5e9tvy001wplxpn1z61sb1","_id":"cjj5e9tw4002hplxph14d72qf"},{"post_id":"cjj5e9tv9000oplxpaql8i42l","tag_id":"cjj5e9tw3002fplxpgd4xs6xo","_id":"cjj5e9tw5002kplxph7gk1yol"},{"post_id":"cjj5e9tv9000oplxpaql8i42l","tag_id":"cjj5e9tw4002iplxpfapii6a0","_id":"cjj5e9tw5002lplxpacncpdw4"},{"post_id":"cjj5e9tvc000rplxph5eohk3e","tag_id":"cjj5e9tur0003plxpwk42gvqs","_id":"cjj5e9tw5002nplxpgkfpk164"},{"post_id":"cjj5e9tvc000rplxph5eohk3e","tag_id":"cjj5e9tw4002jplxpzykjsn92","_id":"cjj5e9tw6002oplxpzklkf07p"},{"post_id":"cjj5e9tvd000uplxp948a8v9q","tag_id":"cjj5e9tw5002mplxp3xn4s3ki","_id":"cjj5e9tw6002qplxp49f1fx3z"},{"post_id":"cjj5e9tvf000wplxpcpykxq1w","tag_id":"cjj5e9tw6002pplxpwwlk03ju","_id":"cjj5e9tw8002tplxpdqg716tz"},{"post_id":"cjj5e9tvf000wplxpcpykxq1w","tag_id":"cjj5e9tvj0014plxpoeuu603g","_id":"cjj5e9tw8002uplxpn15vbpn7"},{"post_id":"cjj5e9tvg0010plxpp5a9wr3r","tag_id":"cjj5e9tw7002splxpc0tixkjz","_id":"cjj5e9tw8002wplxprg0xtq2r"},{"post_id":"cjj5e9tvi0012plxpjdq93aku","tag_id":"cjj5e9tur0003plxpwk42gvqs","_id":"cjj5e9tw9002yplxp9jfavg4o"},{"post_id":"cjj5e9tvi0012plxpjdq93aku","tag_id":"cjj5e9tw8002vplxpv9czdz8a","_id":"cjj5e9tw9002zplxpspz2dcdv"},{"post_id":"cjj5e9tvk0015plxphf73vnej","tag_id":"cjj5e9tw9002xplxpkf5vl9yx","_id":"cjj5e9twa0032plxpdvtlu7r4"},{"post_id":"cjj5e9tvk0015plxphf73vnej","tag_id":"cjj5e9tw90030plxptwn4sl6k","_id":"cjj5e9twa0033plxpi9zqog3n"},{"post_id":"cjj5e9tvm0018plxpskv7pv3g","tag_id":"cjj5e9tur0003plxpwk42gvqs","_id":"cjj5e9twb0035plxplke22vhp"},{"post_id":"cjj5e9tvm0018plxpskv7pv3g","tag_id":"cjj5e9twa0031plxpq8yee4ob","_id":"cjj5e9twb0036plxpbyalm1xx"},{"post_id":"cjj5e9tvo001cplxp4q7vvnt8","tag_id":"cjj5e9tw9002xplxpkf5vl9yx","_id":"cjj5e9twc0039plxppcey5wty"},{"post_id":"cjj5e9tvo001cplxp4q7vvnt8","tag_id":"cjj5e9twb0037plxpagfm1kx8","_id":"cjj5e9twc003aplxp8mnpdrpo"},{"post_id":"cjj5e9tvp001eplxpb4ko6jxk","tag_id":"cjj5e9tw9002xplxpkf5vl9yx","_id":"cjj5e9twc003dplxp56yvjkil"},{"post_id":"cjj5e9tvp001eplxpb4ko6jxk","tag_id":"cjj5e9twc003bplxpqwa5ty5o","_id":"cjj5e9twd003eplxptfr4g4ya"},{"post_id":"cjj5e9tvs001hplxpkfbngel4","tag_id":"cjj5e9twc003cplxpqv881ytx","_id":"cjj5e9twd003gplxpjjl83s3d"},{"post_id":"cjj5e9tvt001kplxpm6dcfb88","tag_id":"cjj5e9tw9002xplxpkf5vl9yx","_id":"cjj5e9twf003jplxpzmdyvrf5"},{"post_id":"cjj5e9tvt001kplxpm6dcfb88","tag_id":"cjj5e9twe003hplxp16gxjd0j","_id":"cjj5e9twf003kplxp05ykvi23"},{"post_id":"cjj5e9tvv001nplxppead064h","tag_id":"cjj5e9twe003iplxpt0nil9t9","_id":"cjj5e9twf003mplxpzly0ke5l"},{"post_id":"cjj5e9tvx001rplxpw7581zs3","tag_id":"cjj5e9twe003iplxpt0nil9t9","_id":"cjj5e9twg003nplxpja0btydn"},{"post_id":"cjj5e9u1j003pplxprifr1vof","tag_id":"cjj5e9u1n003rplxpr2rhanmp","_id":"cjj5e9u1o003vplxpd7nwt5v7"},{"post_id":"cjj5e9u1m003qplxps2dkbp0r","tag_id":"cjj5e9u1o003uplxpr4cgmphi","_id":"cjj5e9u1p003xplxpp4q0hm4l"}],"Tag":[{"name":"博弈","_id":"cjj5e9tur0003plxpwk42gvqs"},{"name":"巴什博奕","_id":"cjj5e9tuv0008plxptx620x54"},{"name":"数学","_id":"cjj5e9tv0000dplxpzn0iiy3r"},{"name":"思维技巧","_id":"cjj5e9tv7000kplxp8eobblrl"},{"name":"搜索","_id":"cjj5e9tvb000qplxpu66vo7qe"},{"name":"A*算法","_id":"cjj5e9tvf000yplxpd10dxaii"},{"name":"图论","_id":"cjj5e9tvj0014plxpoeuu603g"},{"name":"并查集","_id":"cjj5e9tvn001bplxpssjkidwa"},{"name":"SG函数","_id":"cjj5e9tvr001gplxpo33wpjm6"},{"name":"dijkstra","_id":"cjj5e9tvy001wplxpn1z61sb1"},{"name":"树形DP","_id":"cjj5e9tvz0020plxplorc3imt"},{"name":"二分图","_id":"cjj5e9tw10028plxpx89mc636"},{"name":"最大匹配","_id":"cjj5e9tw10029plxp7oi6xppj"},{"name":"Muti-treaded","_id":"cjj5e9tw3002fplxpgd4xs6xo"},{"name":"DP","_id":"cjj5e9tw4002iplxpfapii6a0"},{"name":"Nim游戏","_id":"cjj5e9tw4002jplxpzykjsn92"},{"name":"Machine Learning","_id":"cjj5e9tw5002mplxp3xn4s3ki"},{"name":"A\\*","_id":"cjj5e9tw6002pplxpwwlk03ju"},{"name":"Splay","_id":"cjj5e9tw7002splxpc0tixkjz"},{"name":"威佐夫博奕（Wythoff Game）","_id":"cjj5e9tw8002vplxpv9czdz8a"},{"name":"组合数学","_id":"cjj5e9tw9002xplxpkf5vl9yx"},{"name":"容斥原理","_id":"cjj5e9tw90030plxptwn4sl6k"},{"name":"巴什博奕（Bash Game）","_id":"cjj5e9twa0031plxpq8yee4ob"},{"name":"康托展开","_id":"cjj5e9twb0037plxpagfm1kx8"},{"name":"抽屉原理","_id":"cjj5e9twc003bplxpqwa5ty5o"},{"name":"基本 DP","_id":"cjj5e9twc003cplxpqv881ytx"},{"name":"裴蜀等式","_id":"cjj5e9twe003hplxp16gxjd0j"},{"name":"高等数学","_id":"cjj5e9twe003iplxpt0nil9t9"},{"name":"题解","_id":"cjj5e9u1n003rplxpr2rhanmp"},{"name":"Hexo","_id":"cjj5e9u1o003uplxpr4cgmphi"}]}}