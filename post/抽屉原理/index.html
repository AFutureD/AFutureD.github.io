<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AFuture&#39;s Blog</title>
<meta name="description" content="Life & Knowledge" />
<link rel="shortcut icon" href="https://afutured.github.io/favicon.ico?v=1566879662034">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://afutured.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="AFuture&#39;s Blog - Atom Feed" href="https://afutured.github.io/atom.xml">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-140024243-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-140024243-2');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://afutured.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://afutured.github.io/images/avatar.png?v=1566879662034" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">AFuture&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0">抽屉原理简述：</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86">第一抽屉原理：</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86">第二抽屉原理：</a></li>
</ul>
</li>
<li><a href="#hdu_1205-%E5%90%83%E7%B3%96%E6%9E%9C">HDU_1205 吃糖果</a>
<ul>
<li><a href="#problem-description">Problem Description</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#sample-input">Sample Input</a></li>
<li><a href="#sample-output">Sample Output</a></li>
<li><a href="#%E9%A2%98%E8%A7%A3">题解：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hdu_1808-halloween-treats">HDU_1808 Halloween treats</a><br>
*
<ul>
<li><a href="#problem-description-2">Problem Description</a></li>
<li><a href="#input-2">Input</a></li>
<li><a href="#output-2">Output</a></li>
<li><a href="#sample-input-2">Sample Input</a></li>
<li><a href="#sample-output-2">Sample Output</a></li>
<li><a href="#%E9%A2%98%E8%A7%A3-2">题解：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81-2">代码：</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Made by <a href="https://afutured.github.io" target="_blank">AFuture</a> Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://afutured.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">抽屉原理</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2016-12-28 / 3 min read
        </div>
        
        <div class="post-content yue">
          <h2 id="抽屉原理简述">抽屉原理简述：</h2>
<h3 id="第一抽屉原理">第一抽屉原理：</h3>
<blockquote>
<ol>
<li>把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</li>
<li>把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</li>
<li>把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。</li>
</ol>
</blockquote>
<h3 id="第二抽屉原理">第二抽屉原理：</h3>
<blockquote>
<ol>
<li>把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>m</mi><mi>n</mi><mi mathvariant="normal">－</mi><mn>1</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（mn－1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">－</span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>个物体放入n个抽屉中，其中必有一个抽屉中至多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>m</mi><mi mathvariant="normal">—</mi><mn>1</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（m—1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">m</span><span class="mord" style="margin-right:0.02778em;">—</span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</li>
</ol>
</blockquote>
<!-- more -->
<h2 id="hdu_1205-吃糖果">HDU_1205 吃糖果</h2>
<h3 id="problem-description">Problem Description</h3>
<p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。</p>
<h3 id="input">Input</h3>
<p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。</p>
<h3 id="output">Output</h3>
<p>对于每组数据，输出一行，包含一个&quot;Yes&quot;或者&quot;No&quot;。</p>
<h3 id="sample-input">Sample Input</h3>
<p>2<br>
3<br>
4 1 1<br>
5<br>
5 4 3 2 1</p>
<h3 id="sample-output">Sample Output</h3>
<p>No<br>
Yes</p>
<h3 id="题解">题解：</h3>
<p>设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam&gt;sum-max+1；则一定不能吃完，否则能吃完。</p>
<h3 id="代码">代码：</h3>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main()
{ 
  	__int64  n,m,t,max,sum;
    scanf(&quot;%I64d&quot;,&amp;t);
    while(t--){
        sum=0;
        max=0;
        scanf(&quot;%I64d&quot;,&amp;n);
        for(int i=0;i&lt;n;i++){
            scanf(&quot;%I64d&quot;,&amp;m);
            sum+=m;
            if(max&lt;m)
            	max=m;        
        }
        sum-=max;
        if(max&gt;sum+1)
        	printf(&quot;No\n&quot;);
        else
        	printf(&quot;Yes\n&quot;);
    }
        return 0;
}
</code></pre>
<h1 id="hdu_1808-halloween-treats">HDU_1808 Halloween treats</h1>
<h3 id="problem-description-2">Problem Description</h3>
<p>Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year's experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided.</p>
<p>Your job is to help the children and present a solution.</p>
<h3 id="input-2">Input</h3>
<p>The input contains several test cases.<br>
The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , ... , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i.</p>
<p>The last test case is followed by two zeros.</p>
<h3 id="output-2">Output</h3>
<p>For each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print &quot;no sweets&quot; instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.</p>
<h3 id="sample-input-2">Sample Input</h3>
<p>4 5<br>
1 2 3 7 5<br>
3 6<br>
7 11 2 5 13 17<br>
0 0</p>
<h3 id="sample-output-2">Sample Output</h3>
<p>3 5<br>
2 3 4</p>
<h3 id="题解-2">题解：</h3>
<p>有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。</p>
<p>我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，...，a1+...+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c&lt;=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。</p>
<h3 id="代码-2">代码：</h3>
<pre><code class="language-c++">include &lt;cstdio&gt;
include &lt;cstring&gt;

const int MAXN = 1e5+5;
int a[MAXN], SumMod[MAXN], flag[MAXN];

int main()
{
    int c, n;
    while(~scanf(&quot;%d%d&quot;, &amp;c, &amp;n) &amp;&amp; (c+n))
    {
        SumMod[0] = 0;
        memset(flag, 0, sizeof(flag));
        for(int i=1; i&lt;=n; ++i)
            scanf(&quot;%d&quot;, &amp;a[i]);
        for(int i=1; i&lt;=n; ++i)
        {
            SumMod[i] = (SumMod[i-1] + a[i]) % c;  // 处理前缀和，并取模
            if(flag[SumMod[i]] == 0)
                flag[SumMod[i]] = i;
            else                                   // 如果相同的余数在前面出现过
            {
                int j = flag[SumMod[i]] + 1;
                int k = j;
                for(; j&lt;=i; ++j)                   // 公共项即为答案
                    if(j == k) printf(&quot;%d&quot;, j);
                    else printf(&quot; %d&quot;, j);
                break;
            }
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://afutured.github.io/tag/zu-he-shu-xue">
            <span class="flex-auto">组合数学</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://afutured.github.io/tag/chou-ti-yuan-li">
            <span class="flex-auto">抽屉原理</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://afutured.github.io/post/康托展开">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  康托展开
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://afutured.github.io/post/最大子矩阵和">
                <h3 class="post-title">
                  51NOD DP-最大子矩阵和
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://afutured.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
