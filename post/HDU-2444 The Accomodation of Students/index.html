<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AFuture&#39;s Blog</title>
<meta name="description" content="Life & Knowledge" />
<link rel="shortcut icon" href="https://afutured.github.io/favicon.ico?v=1566968384342">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://afutured.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="AFuture&#39;s Blog - Atom Feed" href="https://afutured.github.io/atom.xml">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-140024243-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-140024243-3');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://afutured.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://afutured.github.io/images/avatar.png?v=1566968384342" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">AFuture&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#problem-description">Problem Description：</a></li>
<li><a href="#input">Input：</a></li>
<li><a href="#output">Output：</a></li>
<li><a href="#sample-input">Sample Input：</a></li>
<li><a href="#sample-output">Sample Output：</a></li>
<li><a href="#%E9%A2%98%E8%A7%A3">题解：</a></li>
<li><a href="#code">Code：</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Made by <a href="https://afutured.github.io" target="_blank">AFuture</a> Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://afutured.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">HDU-2444 The Accomodation of Students</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2016-12-28 / 2 min read
        </div>
        
        <div class="post-content yue">
          <p><em>类型： 二分图的判断和最大匹配</em></p>
<!-- more -->
<h3 id="problem-description">Problem Description：</h3>
<p>There are a group of students. Some of them may know each other, while others don't. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other.</p>
<p>Now you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don't know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room.</p>
<p>Calculate the maximum number of pairs that can be arranged into these double rooms.</p>
<h3 id="input">Input：</h3>
<p>For each data set:<br>
The first line gives two integers, n and m(1&lt;n&lt;=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs.</p>
<p>Proceed to the end of file.</p>
<h3 id="output">Output：</h3>
<p>If these students cannot be divided into two groups, print &quot;No&quot;. Otherwise, print the maximum number of pairs that can be arranged in those rooms.</p>
<h3 id="sample-input">Sample Input：</h3>
<p>4 4<br>
1 2<br>
1 3<br>
1 4<br>
2 3<br>
6 5<br>
1 2<br>
1 3<br>
1 4<br>
2 5<br>
3 6</p>
<h3 id="sample-output">Sample Output：</h3>
<p>No<br>
3</p>
<h3 id="题解">题解：</h3>
<p>这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，<br>
建边是双向的所以要除以2。<br>
先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白<br>
色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻<br>
点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集<br>
合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。</p>
<p>其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为：</p>
<ol>
<li>定义一个空集U，放入起始点。</li>
<li>搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。</li>
<li>循环步骤2，如果不能继续则结束。</li>
</ol>
<h3 id="code">Code：</h3>
<pre><code class="language-c++">include&quot;stdio.h&quot;
include&quot;string.h&quot;
include&quot;iostream&quot;
include&quot;queue&quot;
using namespace std;
define N 205
int mark[N],link[N],map[N][N],color[N],n;
int find(int a)       //匈牙利算法
{
	int i;
	for(i=1;i&lt;=n;i++){
		if(!mark[i]&amp;&amp;map[a][i]){
			mark[i]=1;
			if(!link[i]||find(link[i])){ //若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对
				link[i]=a; //若可以则把i配给a
				return 1;
			}
		}
	}
	return 0;
}
int judge()        //判断是否是二分图
{
	int i,cur;
	queueq;       //队列声明
	q.push(1);       //把1加入队列
	while(!q.empty()){
		cur=q.front();      //取队首元素
		q.pop();             //删除队首元素
		for(i=1;i&lt;=n;i++){
			if(map[cur][i]){      //1和2、3认识则把2、3均标记为2；  
				if(color[i]==-1){
					color[i]=1-color[cur];
					q.push(i);
				}
				else if(color[i]==color[cur])      //接下来到2出对时，color[3]=color
					return 0;
			}
		}
	}
	return 1;
}
int main()
{
	int i,j,m,ans;
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=-1){
		memset(link,0,sizeof(link));
		memset(map,0,sizeof(map));
		memset(color,-1,sizeof(color));
		while(m--){
			scanf(&quot;%d%d&quot;,&amp;i,&amp;j);
			map[i][j]=map[j][i]=1;
		}
		if(judge()==0){
			printf(&quot;No\n&quot;);
			continue;
		}
		ans=0;
		for(i=1;i&lt;=n;i++){
			memset(mark,0,sizeof(mark));
			ans+=find(i);
		}
		printf(&quot;%d\n&quot;,ans/2);
	}
	return 0;
}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://afutured.github.io/tag/tu-lun">
            <span class="flex-auto">图论</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://afutured.github.io/tag/er-fen-tu">
            <span class="flex-auto">二分图</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://afutured.github.io/tag/zui-da-pi-pei">
            <span class="flex-auto">最大匹配</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://afutured.github.io/post/HDU-2196 Computer">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  HDU-2196 Computer
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://afutured.github.io/post/HDU-2544 最短路">
                <h3 class="post-title">
                  HDU-2544  最短路
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'bd6ae660d2f64dde8485',
    clientSecret: 'b1b266a3462d7f5d52b94f69423b9988c37cba4b',
    repo: 'afutured.github.io',
    owner: 'afutured',
    admin: ['afutured'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://afutured.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
